/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { DefaultButton, IconButton } from '@fluentui/react/lib/Button';
import { FocusZone, FocusZoneDirection } from '@fluentui/react/lib/FocusZone';
import { IProcessedStyleSet, mergeStyleSets } from '@fluentui/react/lib/Styling';
import { TooltipHost } from '@fluentui/react/lib/Tooltip';
import { classNamesFunction, getId } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { TIMER_DELAY_DEFAULT } from './Carousel.constants';
import {
  ICarouselProps,
  ICarouselState,
  ICarouselStyleProps,
  ICarouselStyles,
  ITooltipIndicatorProps
} from './Carousel.types';

const getClassNames = classNamesFunction<ICarouselStyleProps, ICarouselStyles>();

/**
 * Provides a common carousel format
 *
 * @export
 * @class Carousel
 * @extends {React.Component<ICarouselProps>}
 */
export class CarouselBase extends React.Component<ICarouselProps, ICarouselState> {
  private timer: number | undefined;

  constructor(props: ICarouselProps) {
    super(props);

    const { isAutoPlayDisabled } = props;

    this.state = {
      selectedIndex: 0,
      isAutoplaySuspended: isAutoPlayDisabled,
      isAutoplayButtonPaused: isAutoPlayDisabled,
      tooltipIndicatorsProps: this._getTooltipIndicatorsProps()
    };
  }

  public componentDidMount() {
    this._updatePlayback();
  }

  public componentDidUpdate(prevProps: ICarouselProps, prevState: ICarouselState) {
    const { isAutoPlayDisabled, delay, items, indicatorButtonsAriaLabel } = this.props;
    const { isAutoplaySuspended, isAutoplayButtonPaused } = this.state;

    if (
      prevState.isAutoplaySuspended !== isAutoplaySuspended ||
      prevState.isAutoplayButtonPaused !== isAutoplayButtonPaused ||
      prevProps.delay !== delay
    ) {
      this._updatePlayback();
    } else if (prevProps.isAutoPlayDisabled !== isAutoPlayDisabled) {
      this.setState(
        {
          isAutoplaySuspended: isAutoPlayDisabled,
          isAutoplayButtonPaused: isAutoPlayDisabled
        },
        this._updatePlayback
      );
    }

    if (
      !this._areItemsEqual(prevProps.items, items) ||
      !this._areItemsEqual(prevProps.indicatorButtonsAriaLabel, indicatorButtonsAriaLabel)
    ) {
      this.setState(
        {
          selectedIndex: 0,
          tooltipIndicatorsProps: this._getTooltipIndicatorsProps()
        },
        this._updatePlayback
      );
    }
  }

  public componentWillUnmount() {
    window.clearInterval(this.timer);
  }

  public render() {
    const {
      hideIndicators,
      hideNavigation,
      items,
      orderIndicatorsBeforeControls,
      theme,
      className,
      styles
    } = this.props;
    const { selectedIndex } = this.state;

    const classNames = getClassNames(styles, {
      theme,
      className
    });

    return (
      <div
        className={classNames.root}
        onMouseEnter={this._suspend}
        onMouseLeave={this._unSuspend}
        onFocus={this._suspend}
        onBlur={this._unSuspend}
      >
        <div className={classNames.itemWrapper}>{items[selectedIndex]}</div>
        {orderIndicatorsBeforeControls ? (
          <>
            {!hideIndicators && this._renderIndicators(classNames)}
            {!hideNavigation && this._renderControls(classNames)}
          </>
        ) : (
          <>
            {!hideNavigation && this._renderControls(classNames)}
            {!hideIndicators && this._renderIndicators(classNames)}
          </>
        )}
      </div>
    );
  }

  public goToNextSlide = () => {
    const { items, onNext } = this.props;
    const { selectedIndex } = this.state;

    this.goToSlideIndex((selectedIndex + 1) % items.length);
    onNext?.(selectedIndex);
  };

  public goToPreviousSlide = () => {
    const { items, onPrevious } = this.props;
    const { selectedIndex } = this.state;

    this.goToSlideIndex((items.length + (selectedIndex - 1)) % items.length);
    onPrevious?.(selectedIndex);
  };

  public goToSlideIndex(index: number) {
    const { items, onItemSelected } = this.props;
    const item = items[index];
    if (item) {
      this.setState({ selectedIndex: index }, onItemSelected ? () => onItemSelected(item, index) : undefined);
    }
  }

  private _renderControls(classNames: IProcessedStyleSet<ICarouselStyles>) {
    const {
      navPreviousButtonAriaLabel,
      navNextButtonAriaLabel,
      navPreviousButtonLabel,
      navNextButtonLabel,
      useControlLabels,
      disableNavigationLoop,
      items,
      doneButton,
      skipButton
    } = this.props;
    const tooltipControlStyles = classNames.subComponentStyles.tooltipControl({});
    const controlStyles = classNames.subComponentStyles.control({});

    const tooltipPrevStyles = mergeStyleSets(
      {
        root: ['ba-Carousel-tooltipControl-previous']
      },
      tooltipControlStyles
    );
    const tooltipNextStyles = mergeStyleSets(
      {
        root: ['ba-Carousel-tooltipControl-next']
      },
      tooltipControlStyles
    );

    const controlPrevStyles = mergeStyleSets(
      {
        root: ['ba-Carousel-control-previous']
      },
      controlStyles
    );
    const controlNextStyles = mergeStyleSets(
      {
        root: ['ba-Carousel-control-next']
      },
      controlStyles
    );

    const showSkip = this._canShowSkip();
    const showDismiss = this._canShowDismiss();
    const showPrev = !disableNavigationLoop || this.state.selectedIndex > 0 || showSkip;
    const showNext = !disableNavigationLoop || this.state.selectedIndex < items.length - 1 || showDismiss;

    const prevProps = showSkip
      ? {
          'aria-label': skipButton.skipButtonAriaLabel,
          styles: controlPrevStyles,
          onClick: skipButton.onSkip
        }
      : {
          'aria-label': navPreviousButtonAriaLabel,
          styles: controlPrevStyles,
          onClick: this.goToPreviousSlide
        };

    const nextProps = showDismiss
      ? {
          'aria-label': doneButton.doneButtonAriaLabel,
          styles: controlNextStyles,
          onClick: doneButton.onDone
        }
      : {
          'aria-label': navNextButtonAriaLabel,
          styles: controlNextStyles,
          onClick: this.goToNextSlide
        };

    const prevLabel = showSkip ? skipButton.skipButtonLabel : navPreviousButtonLabel || 'Back';
    const nextLabel = showDismiss ? doneButton.doneButtonLabel : navNextButtonLabel || 'Next';

    const tooltipControls = () => (
      <>
        {showPrev && (
          <TooltipHost content={navPreviousButtonAriaLabel} styles={tooltipPrevStyles}>
            <IconButton iconProps={{ iconName: 'ChevronLeftMed' }} {...prevProps} />
          </TooltipHost>
        )}
        {showNext && (
          <TooltipHost content={navNextButtonAriaLabel} styles={tooltipNextStyles}>
            <IconButton iconProps={{ iconName: 'ChevronRightMed' }} {...nextProps} />
          </TooltipHost>
        )}
      </>
    );

    const labelControls = () => (
      <>
        {showPrev && (
          <TooltipHost styles={tooltipPrevStyles}>
            <DefaultButton styles={tooltipPrevStyles} {...prevProps} text={prevLabel} />
          </TooltipHost>
        )}
        {showNext && (
          <TooltipHost styles={tooltipNextStyles}>
            <DefaultButton styles={tooltipNextStyles} {...nextProps} text={nextLabel} />
          </TooltipHost>
        )}
      </>
    );

    return (
      <div className={classNames.controlsWrapper}>
        {useControlLabels ? labelControls() : tooltipControls()}
      </div>
    );
  }

  private _canShowSkip = () => {
    const { skipButton } = this.props;
    return skipButton?.onSkip !== undefined && this.state.selectedIndex === 0;
  };

  private _canShowDismiss = () => {
    const { items, doneButton } = this.props;
    return doneButton?.onDone !== undefined && this.state.selectedIndex === items.length - 1;
  };

  private _renderIndicator(
    classNames: IProcessedStyleSet<ICarouselStyles>,
    index: number,
    content: string,
    isSelected: boolean
  ) {
    const { disableIndicators } = this.props;
    const indicatorStyle = classNames.subComponentStyles.indicator({});
    const iconName = isSelected ? 'CircleFill' : 'CircleRing';

    const indicatorProps = {
      role: 'tab',
      key: index,
      'aria-label': content,
      'aria-selected': isSelected,
      iconProps: { iconName },
      styles: indicatorStyle,
      className: isSelected ? 'is-active' : undefined
    };

    return disableIndicators ? (
      <IconButton {...indicatorProps} />
    ) : (
      <IconButton
        {...indicatorProps}
        onClick={() => this.goToSlideIndex(index)}
        onFocus={() => this.goToSlideIndex(index)}
      />
    );
  }

  private _renderIndicators(classNames: IProcessedStyleSet<ICarouselStyles>) {
    const { items, playButtonAriaLabel, pauseButtonAriaLabel, hidePlayButton } = this.props;
    const { tooltipIndicatorsProps } = this.state;
    const { selectedIndex, isAutoplayButtonPaused } = this.state;
    const toggleStyle = classNames.subComponentStyles.toggle({});
    const toggleButtonAriaLabel = isAutoplayButtonPaused ? playButtonAriaLabel : pauseButtonAriaLabel;

    return (
      <div className={classNames.indicatorsWrapper}>
        <FocusZone direction={FocusZoneDirection.horizontal} isCircularNavigation={true} role="tablist">
          {items.map((item, index) => {
            const isSelected = index === selectedIndex;
            const { id, content } = tooltipIndicatorsProps[index];

            return (
              <TooltipHost key={id} id={id} content={content}>
                {this._renderIndicator(classNames, index, content, isSelected)}
              </TooltipHost>
            );
          })}
        </FocusZone>
        {!hidePlayButton && (
          <TooltipHost content={toggleButtonAriaLabel}>
            <IconButton
              aria-label={toggleButtonAriaLabel}
              iconProps={{ iconName: isAutoplayButtonPaused ? 'Play' : 'Pause' }}
              styles={mergeStyleSets({ root: ['ba-Carousel-play'] }, toggleStyle)}
              onClick={this._togglePlayPause}
            />
          </TooltipHost>
        )}
      </div>
    );
  }

  private _getTooltipIndicatorsProps(): ITooltipIndicatorProps[] {
    const { items, indicatorButtonsAriaLabel } = this.props;
    const isIndicatorsAriaLabelArray =
      Array.isArray(indicatorButtonsAriaLabel) && indicatorButtonsAriaLabel.length === items.length;

    return isIndicatorsAriaLabelArray
      ? (indicatorButtonsAriaLabel as string[]).map(content => ({
          id: getId('ba-carousel-tooltip'),
          content
        }))
      : items.map(() => ({
          id: getId('ba-carousel-tooltip'),
          content: indicatorButtonsAriaLabel as string
        }));
  }

  private _updatePlayback() {
    const { delay } = this.props;
    const { isAutoplaySuspended: isAutoplaySuspended, isAutoplayButtonPaused } = this.state;

    window.clearInterval(this.timer);

    if (!(isAutoplaySuspended || isAutoplayButtonPaused)) {
      this.timer = window.setInterval(() => this.goToNextSlide(), delay || TIMER_DELAY_DEFAULT);
    }
  }

  private _togglePlayPause = () => {
    this.setState(state => ({
      isAutoplaySuspended: !state.isAutoplayButtonPaused,
      isAutoplayButtonPaused: !state.isAutoplayButtonPaused
    }));
  };

  private _suspend = () => {
    this.setState({ isAutoplaySuspended: true });
  };

  private _unSuspend = () => {
    this.setState({ isAutoplaySuspended: false });
  };

  private _areItemsEqual = (
    prevItems: React.ReactNode[] | string | string[],
    items: React.ReactNode[] | string | string[]
  ) => {
    if (prevItems.length !== items.length) {
      return false;
    }

    for (let i = 0; i < items.length; i++) {
      if (items[i] !== prevItems[i]) {
        return false;
      }
    }

    return true;
  };
}
