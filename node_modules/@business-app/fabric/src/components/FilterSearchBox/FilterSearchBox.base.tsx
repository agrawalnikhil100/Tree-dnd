/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import * as React from 'react';

import { DefaultButton, IButton } from '@fluentui/react/lib/Button';
import { DirectionalHint, ICalloutProps } from '@fluentui/react/lib/Callout';
import { IContextualMenuItem } from '@fluentui/react/lib/ContextualMenu';
import { IIconProps } from '@fluentui/react/lib/Icon';
import { ISearchBox, SearchBox } from '@fluentui/react/lib/SearchBox';
import { IProcessedStyleSet, mergeStyles } from '@fluentui/react/lib/Styling';
import { TooltipHost } from '@fluentui/react/lib/Tooltip';
import { BaseComponent, classNamesFunction, customizable } from '@fluentui/react/lib/Utilities';

import {
  IFilterSearchBoxProps,
  IFilterSearchBoxStyleProps,
  IFilterSearchBoxStyles
} from './FilterSearchBox.types';

const getClassNames = classNamesFunction<IFilterSearchBoxStyleProps, IFilterSearchBoxStyles>();

export interface IFilterSearchBoxState {
  readonly isHovering: boolean;
  readonly isSearchBoxActive: boolean;
  readonly isFilterMenuOpen: boolean;
}

@customizable('FilterSearchBox', ['theme', 'styles'])
export class FilterSearchBoxBase extends BaseComponent<IFilterSearchBoxProps, IFilterSearchBoxState> {
  public readonly state = {
    isHovering: false,
    isSearchBoxActive: false,
    isFilterMenuOpen: false
  };

  private _containerRef = React.createRef<HTMLDivElement>();
  private _searchBoxRef = React.createRef<ISearchBox>();
  private _filterButtonRef = React.createRef<IButton>();
  private _classNames: IProcessedStyleSet<IFilterSearchBoxStyles>;

  public focus() {
    if (this._searchBoxRef.current) {
      this._searchBoxRef.current.focus();
    }
  }

  public dismissMenu() {
    if (this._filterButtonRef.current) {
      this._filterButtonRef.current.dismissMenu();
    }
  }

  public render() {
    this._classNames = this._getClassNames(this.props);

    const { isHovering, isSearchBoxActive, isFilterMenuOpen } = this.state;
    const isActive = isHovering || isSearchBoxActive || isFilterMenuOpen;
    return (
      <div
        ref={this._containerRef}
        className={mergeStyles(this._classNames.root, isActive && this._classNames.active)}
        onMouseEnter={this._onContainerMouseEnter}
        onMouseLeave={this._onContainerMouseLeave}
      >
        {this._renderSearchBox()}
        {this._renderFilterSelection()}
      </div>
    );
  }

  private _onContainerMouseEnter = () => {
    this.setState({ isHovering: true });
  };

  private _onContainerMouseLeave = () => {
    this.setState({ isHovering: false });
  };

  private _renderSearchBox() {
    const {
      searchText,
      onSearchTextChange,
      strings: { searchBoxPlaceholder, searchBoxClearButtonTitle }
    } = this.props;

    return (
      <SearchBox
        componentRef={this._searchBoxRef}
        placeholder={searchBoxPlaceholder}
        ariaLabel={searchBoxPlaceholder}
        styles={{
          root: this._classNames.searchBox,
          field: this._classNames.searchBoxField
        }}
        onFocus={this._onSearchBoxFocus}
        onBlur={this._onSearchBoxBlur}
        onChange={onSearchTextChange}
        clearButtonProps={{ title: searchBoxClearButtonTitle }}
        value={searchText}
      />
    );
  }

  private _onSearchBoxFocus = () => {
    this.setState({ isSearchBoxActive: true });
  };

  private _onSearchBoxBlur = () => {
    this.setState({ isSearchBoxActive: false });
  };

  private _renderFilterSelection() {
    const {
      filters = [],
      selectedFilterKey,
      filterButtonIconName,
      filterCalloutMatchComponentWidth,
      strings: { filterButtonTooltipText }
    } = this.props;

    // If less than two filters, do not render chooser
    if (filters.length < 2) {
      return null;
    }

    // Find selected filter text and map to IContextualMenuItem in a single loop.
    const menuItems: IContextualMenuItem[] = [];
    let selectedFilterText = '';
    filters.forEach(filter => {
      const item: IContextualMenuItem = {
        key: filter.key,
        text: filter.text,
        canCheck: true
      };

      if (filter.key === selectedFilterKey) {
        selectedFilterText = filter.text;
        item.checked = true;
      }

      menuItems.push(item);
    });

    // If filterButtonIconName is provided, do not render the text.
    let iconProps: IIconProps;
    const ariaLabel = selectedFilterText;
    if (!!filterButtonIconName) {
      selectedFilterText = '';
      iconProps = {
        iconName: filterButtonIconName
      };
    }

    let menuCalloutWidth: number;
    let calloutPropsStyles: ICalloutProps['styles'];
    if (this._containerRef.current) {
      menuCalloutWidth = this._containerRef.current.clientWidth;
      calloutPropsStyles = {
        root: {
          maxWidth: menuCalloutWidth
        }
      };
    }

    const buttonRootStyle = filterButtonTooltipText
      ? this._classNames.filterButtonRootInTooltipHost
      : this._classNames.filterButtonRoot;
    const defaultButton = (
      <DefaultButton
        componentRef={this._filterButtonRef}
        styles={{
          root: buttonRootStyle,
          label: selectedFilterText
            ? this._classNames.filterButtonLabel
            : this._classNames.filterButtonNoLabel,
          textContainer: this._classNames.filterButtonTextContainer
        }}
        text={selectedFilterText}
        iconProps={iconProps}
        ariaLabel={ariaLabel}
        menuProps={{
          items: menuItems,
          isBeakVisible: false,
          directionalHint: DirectionalHint.bottomRightEdge,
          onItemClick: this._onFilterMenuItemClick,
          onMenuOpened: this._onFilterMenuOpened,
          onMenuDismissed: this._onFilterMenuDismissed,
          gapSpace: 1,
          calloutProps: {
            styles: calloutPropsStyles,
            target: this._containerRef.current,
            calloutWidth: filterCalloutMatchComponentWidth ? menuCalloutWidth : undefined
          }
        }}
      />
    );

    return (
      <>
        <div className={this._classNames.separator} />
        {filterButtonTooltipText ? (
          <TooltipHost
            content={filterButtonTooltipText}
            calloutProps={{ gapSpace: 0 }}
            styles={{
              root: this._classNames.tooltipHost
            }}
          >
            {defaultButton}
          </TooltipHost>
        ) : (
          // If there is no tooltipText, don't render tooltip component
          <> {defaultButton} </>
        )}
      </>
    );
  }

  private _onFilterMenuItemClick = (_, menuItem: IContextualMenuItem) => {
    const { onFilterChange } = this.props;
    if (onFilterChange) {
      onFilterChange(menuItem.key);
    }
  };

  private _onFilterMenuOpened = () => {
    this.setState({ isFilterMenuOpen: true });
  };

  private _onFilterMenuDismissed = () => {
    this.setState({ isFilterMenuOpen: false, isHovering: false });
  };

  private _getClassNames(props: IFilterSearchBoxProps): IProcessedStyleSet<IFilterSearchBoxStyles> {
    const { theme } = props;

    return getClassNames(props.styles!, {
      theme: theme!
    });
  }
}
