/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { IButtonProps, IconButton } from '@fluentui/react/lib/Button';
import { IIconStyles } from '@fluentui/react/lib/Icon';
import { ColorPicker, IColorPickerStyles } from '@fluentui/react/lib/ColorPicker';
import { getColorFromString, IColor } from '@fluentui/react/lib/Color';
import { Label } from '@fluentui/react/lib/Label';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import { TextField } from '@fluentui/react/lib/TextField';
import { TooltipHost } from '@fluentui/react/lib/Tooltip';
import { getId } from '@fluentui/react/lib/Utilities';
import { classNamesFunction } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { useCallback, useEffect, useState } from 'react';
import { IColorInputProps, IColorInputStyleProps, IColorInputStyles } from './ColorInput.types';
import { defaultColorPickerStyles, defaultTooltipIconProps, defaultTooltipIconStyles } from '.';

const getClassNames = classNamesFunction<IColorInputStyleProps, IColorInputStyles>();

function getColorInputClassNames(props: IColorInputProps) {
  return getClassNames(props.styles!, props);
}

export const ColorInputBase: React.FunctionComponent<IColorInputProps> = (
  props: IColorInputProps
): JSX.Element => {
  const {
    tooltipIconProps,
    colorBoxProps,
    colorTextFieldProps,
    colorPickerProps,
    label,
    tooltipProps,
    styles,
    theme,
    showColorPicker,
    scrollToBottom
  } = props;

  const onTextFieldChange = useCallback(
    (ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>, newValue?: string | undefined): void => {
      setBoxColor((ev.target as HTMLInputElement).value);
    },
    []
  );

  const onTextFieldBlur = useCallback((ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
    const newValue = (ev.target as HTMLInputElement).value;
    setNewColorPickerProps(newValue);
  }, []);

  const onColorChange = useCallback((ev: React.SyntheticEvent<HTMLElement>, selectedColor: IColor): void => {
    setBoxColor(selectedColor.str);
    setNewColorPickerProps(selectedColor.str);
  }, []);

  const onColorBoxClick = useCallback((event: React.MouseEvent<HTMLDivElement>): void => {
    setColorPickerVisibility(value => !value);
  }, []);

  const setNewColorPickerProps = (newColor: string): void => {
    const newProps = { ...pickerProps };
    newProps.color = newColor;
    setColorPickerColorProps(newProps);
  };

  const updatedColorBoxProps = {
    ...colorBoxProps,
    onClick: (ev: React.MouseEvent<HTMLDivElement>) => {
      if (showColorPicker === undefined) {
        onColorBoxClick(ev);
      }
      if (colorBoxProps?.onClick) {
        colorBoxProps.onClick(ev);
      }
    }
  };

  const updatedColorTextFieldProps = {
    ...colorTextFieldProps,
    onChange: (
      ev: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,
      newValue?: string | undefined
    ) => {
      onTextFieldChange(ev);
      colorTextFieldProps?.onChange?.(ev, newValue);
    },
    onBlur: (ev: React.FocusEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      onTextFieldBlur(ev);
      colorTextFieldProps?.onBlur?.(ev);
    }
  };

  let mergedCpRootStyle: string;
  if (colorPickerProps.styles && (colorPickerProps.styles as Partial<IColorPickerStyles>).root) {
    mergedCpRootStyle = mergeStyles(
      defaultColorPickerStyles.root,
      (colorPickerProps.styles as Partial<IColorPickerStyles>).root
    );
  } else {
    mergedCpRootStyle = mergeStyles(defaultColorPickerStyles.root);
  }

  const updatedColorPickerProps = {
    ...colorPickerProps,
    onChange: (ev: React.SyntheticEvent<HTMLElement, Event>, pickerColor: IColor) => {
      onColorChange(ev, pickerColor);
      if (colorPickerProps.onChange) {
        colorPickerProps.onChange(ev, pickerColor);
      }
    },
    styles: { ...colorPickerProps.styles, root: mergedCpRootStyle }
  };

  let mergedTooltipIconRootStyle: string;
  if (
    tooltipIconProps?.iconProps?.styles &&
    (tooltipIconProps.iconProps.styles as Partial<IIconStyles>).root
  ) {
    mergedTooltipIconRootStyle = mergeStyles(
      defaultTooltipIconStyles.root,
      (tooltipIconProps.iconProps.styles as Partial<IIconStyles>).root
    );
  } else {
    mergedTooltipIconRootStyle = mergeStyles(defaultTooltipIconStyles.root);
  }

  let updatedTooltipIconProps: IButtonProps;
  if (tooltipIconProps) {
    if (tooltipIconProps.iconProps) {
      updatedTooltipIconProps = { ...tooltipIconProps };
      updatedTooltipIconProps.iconProps = {
        ...updatedTooltipIconProps.iconProps,
        styles: { ...updatedTooltipIconProps.iconProps.styles, root: mergedTooltipIconRootStyle },
        iconName: updatedTooltipIconProps.iconProps.iconName
          ? updatedTooltipIconProps.iconProps.iconName
          : defaultTooltipIconProps.iconProps.iconName
      };
    } else {
      updatedTooltipIconProps = { ...defaultTooltipIconProps, ...tooltipIconProps };
    }
  } else {
    updatedTooltipIconProps = { ...defaultTooltipIconProps };
  }

  const { color } = colorPickerProps;
  const classNames = getClassNames(styles, { theme });
  const colorInputId = getId('colorInput');
  const tooltipId = getId('tooltip');
  const [boxColor, setBoxColor] = useState(color);
  const [pickerProps, setColorPickerColorProps] = useState(updatedColorPickerProps);
  const [isColorPickerVisible, setColorPickerVisibility] = useState(false);

  let colorPickerDivRef: HTMLDivElement | null = null;
  const executeScroll = () => scrollToRef(colorPickerDivRef);

  useEffect(() => {
    if (isColorPickerVisible && scrollToBottom) {
      executeScroll();
    }
  }, [isColorPickerVisible]);

  useEffect(() => {
    if (showColorPicker !== undefined) {
      setColorPickerVisibility(showColorPicker);
    }
  }, [showColorPicker]);

  return (
    <div className={classNames.root}>
      <div className={classNames.labelContainer}>
        <Label className={classNames.label} htmlFor={colorInputId}>
          {label}
        </Label>
        <TooltipHost id={tooltipId} calloutProps={{ gapSpace: 5 }} {...tooltipProps}>
          <IconButton
            aria-describedby={tooltipId}
            className={classNames.iconTooltip}
            {...updatedTooltipIconProps}
          />
        </TooltipHost>
      </div>
      <div className={classNames.container}>
        <IconButton
          className={props.colorBoxProps?.disabled ? classNames.colorBoxDisabled : classNames.colorBox}
          aria-expanded={isColorPickerVisible}
          onRenderIcon={() => {
            return onRenderIcon(boxColor, props);
          }}
          {...updatedColorBoxProps}
        />
        <TextField
          className={classNames.colorTextField}
          value={getColor(boxColor)}
          {...updatedColorTextFieldProps}
        />
      </div>
      {isColorPickerVisible && (
        <>
          <ColorPicker className={classNames.colorPicker} {...pickerProps} />
          <div
            style={{ float: 'left', clear: 'both' }}
            ref={el => {
              colorPickerDivRef = el;
            }}
          />
        </>
      )}
    </div>
  );
};

const getColor = (color: string | IColor): string => {
  color = typeof color === 'string' ? color : color.str;
  const value = getColorFromString(color);
  return value ? (value.str.indexOf('#') === 0 ? value.str : '#' + value.hex) : color;
};

export function isValidColor(inputColor: string | IColor): string | undefined {
  const color: string = typeof inputColor === 'string' ? inputColor : inputColor.str;
  const value: IColor | undefined = getColorFromString(color);
  return value ? value.str : undefined;
}

const scrollToRef = (ref: HTMLDivElement) => {
  if (ref?.scrollIntoView) {
    ref.scrollIntoView({ behavior: 'smooth' });
  }
};

const onRenderIcon = (boxColor: string | IColor, props: IColorInputProps): JSX.Element => {
  const classNames = getColorInputClassNames(props);

  const iconColor = isValidColor(boxColor);
  if (iconColor) {
    return (
      <svg
        className={classNames.colorBoxSvg}
        aria-hidden="true"
        viewBox="0 0 20 20"
        fill={iconColor}
        xmlns="http://www.w3.org/2000/svg"
      >
        <rect width="100%" height="100%" />
      </svg>
    );
  } else {
    return getNoColorIcon(props);
  }
};

const getNoColorIcon = (props: IColorInputProps): JSX.Element => {
  const classNames = getColorInputClassNames(props);

  return (
    <svg
      className={classNames.colorBoxSvg}
      aria-hidden="true"
      viewBox="0 0 28 28"
      fill="white"
      xmlns="http://www.w3.org/2000/svg"
    >
      <rect width="100%" height="100%" />
      <line
        x1="1.41421"
        y1="2"
        x2="26"
        y2="26.5858"
        stroke="#A80000"
        stroke-width="2"
        stroke-linecap="round"
      />
    </svg>
  );
};
