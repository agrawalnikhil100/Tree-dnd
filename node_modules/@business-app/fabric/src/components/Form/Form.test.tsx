/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import * as React from 'react';
import * as ReactTestUtils from 'react-dom/test-utils';

import * as Enzyme from 'enzyme';
import { TextFieldBase } from '@fluentui/react/lib/TextField';
import { Form } from './Form';
import { IFormProps, IFormResult } from './Form.types';
import { DEFAULT_DEBOUNCE } from './FormBaseInput';
import { FormTextInput } from './inputs/textInput/FormTextInput';
import { IFormTextInputProps } from './inputs/textInput/FormTextInput.types';
import * as Validators from './validators/Validators';

// Add an margin of time for the tests to call the function
export const DEFAULT_DEBOUNCE_TEST = DEFAULT_DEBOUNCE + 50;

describe('Form', () => {
  let formProps: IFormProps;
  let formTextInputProps: IFormTextInputProps;
  const formRequiredTestMessage = 'This field is required';
  const formTextBoxValidatorTestMessage = 'Error message for number field';
  let wrapper: Enzyme.ReactWrapper;

  describe('Form renders for different props', () => {
    beforeEach(() => {
      formProps = {
        onSubmit: () => {
          /* stub */
        }
      };

      formTextInputProps = {
        inputKey: 'field',
        textFieldProps: { label: 'Field' }
      };
    });

    it('Null props', () => {
      formProps.onSubmit = null;
      ReactTestUtils.renderIntoDocument(<Form {...formProps} />);
    });

    it('One form value', () => {
      wrapper = Enzyme.mount(
        <Form {...formProps}>
          <FormTextInput {...formTextInputProps} />
        </Form>
      );

      expect(wrapper.find(TextFieldBase)).toHaveLength(1);
    });

    it('Two form values', () => {
      wrapper = Enzyme.mount(
        <Form {...formProps}>
          <FormTextInput {...formTextInputProps} />
          <FormTextInput {...formTextInputProps} />
        </Form>
      );

      expect(wrapper.find(TextFieldBase)).toHaveLength(2);
    });

    it('Initial form value', () => {
      formTextInputProps.value = 'Value';
      wrapper = Enzyme.mount(
        <Form {...formProps}>
          <FormTextInput {...formTextInputProps} />
        </Form>
      );

      const textInput: HTMLInputElement = wrapper.find('input').getDOMNode() as HTMLInputElement;
      expect(textInput.value).toEqual('Value');
    });
  });

  class ExtendsTextBox extends FormTextInput {
    public setValue(value: string): void {
      super.setValue(value);
    }
  }

  describe('Simple form validates and return values', () => {
    beforeEach(() => {
      jest.useFakeTimers();
      formTextInputProps = {
        inputKey: 'field',
        textFieldProps: { label: 'Field' }
      };
    });

    afterEach(() => {
      jest.clearAllTimers();
    });

    it('Valid values are returned correctly', () => {
      let result: IFormResult;
      wrapper = Enzyme.mount(
        <Form
          onSubmit={(value: IFormResult) => {
            result = value;
          }}
        >
          <FormTextInput inputKey="field" value="Value" />
          <FormTextInput inputKey="fieldnumber" value="2" validators={[Validators.isNumber('')]} />
        </Form>
      );
      const form = wrapper.find('form');
      form.simulate('submit');

      expect(result.field).toEqual('Value');
      expect(result.fieldnumber).toEqual('2');
    });

    it('Invalid values are not returned', () => {
      wrapper = Enzyme.mount(
        <Form
          onSubmit={() => {
            /* stub */
          }}
        >
          <FormTextInput
            inputKey="field"
            validators={[Validators.required(formRequiredTestMessage)]}
            value=""
          />

          <FormTextInput
            inputKey="field2"
            value="NAN"
            validators={[Validators.isNumber(formTextBoxValidatorTestMessage)]}
          />
        </Form>
      );

      const form = wrapper.find('form');
      form.simulate('submit');

      expect(wrapper.find({ errorMessage: formRequiredTestMessage }).length).toBeTruthy();
      expect(wrapper.find({ errorMessage: formTextBoxValidatorTestMessage }).length).toBeTruthy();
    });

    it('Number fields with initial value of 0 are displayed properly', () => {
      wrapper = Enzyme.mount(
        <Form
          onSubmit={() => {
            /* stub */
          }}
        >
          <FormTextInput inputKey="field" value="0" />
        </Form>
      );
      const numberField = wrapper.find(TextFieldBase).getDOMNode();
      const input: HTMLInputElement = numberField.getElementsByTagName('input')[0];
      expect(input.getAttribute('value')).toEqual('0');
    });

    // Disabled unstable test
    it.skip('OnUpdated callback is called without submitting form', done => {
      const updateCallback = jest.fn();
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef} onUpdated={updateCallback}>
          <ExtendsTextBox inputKey="field" value="0" />
        </Form>
      );

      const textBox: ExtendsTextBox = ReactTestUtils.findRenderedComponentWithType(
        formRef.current,
        ExtendsTextBox
      );
      textBox.setValue('1');
      jest.runAllTimers();
      expect(updateCallback).toHaveBeenCalledTimes(1);
      done();
    });

    it('Errors are hidden when pristine', done => {
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef}>
          <ExtendsTextBox inputKey="field" validators={[Validators.required(formRequiredTestMessage)]} />
        </Form>
      );
      // Error message is gated behind <DelayedRender>, tick the clock to make it show up
      jest.runAllTimers();
      const errors: HTMLElement[] = ReactTestUtils.scryRenderedDOMComponentsWithClass(
        formRef.current,
        'ms-TextField-errorMessage'
      ) as HTMLElement[];
      expect(errors.length).toEqual(0);
      done();
    });

    it('Errors are shown when pristine and prop is set', done => {
      wrapper = Enzyme.mount(
        <Form showErrorsWhenPristine={true}>
          <ExtendsTextBox inputKey="field" validators={[Validators.required(formRequiredTestMessage)]} />
        </Form>
      );
      // Error message is gated behind <DelayedRender>, tick the clock to make it show up
      jest.runAllTimers();
      const textBox = wrapper.find(TextFieldBase);
      expect(textBox.prop('errorMessage')).toBeTruthy();
      done();
    });

    it('Debounce interval can be changed', done => {
      jest.useRealTimers();
      const updateCallback = jest.fn();
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef} onUpdated={updateCallback}>
          <ExtendsTextBox inputKey="field" value="0" debounceInterval={3000} />
        </Form>
      );
      const textBox: ExtendsTextBox = ReactTestUtils.findRenderedComponentWithType(
        formRef.current,
        ExtendsTextBox
      );
      textBox.setValue('1');
      setTimeout(() => {
        expect(updateCallback).not.toHaveBeenCalledTimes(1);
        setTimeout(() => {
          expect(updateCallback).toHaveBeenCalledTimes(1);
          done();
        }, 3000);
      }, DEFAULT_DEBOUNCE_TEST);
    });
  });
});
