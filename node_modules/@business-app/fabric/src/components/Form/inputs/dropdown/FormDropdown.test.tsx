/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import * as React from 'react';
import * as ReactTestUtils from 'react-dom/test-utils';

import * as Enzyme from 'enzyme';
import { Form } from '../../Form';
import { IFormResult } from '../../Form.types';
import { FormDropdown } from './FormDropdown';

describe('FormDropdown Unit Tests', () => {
  describe('Renders for all combinations of props', () => {
    it('Null name throws error', () => {
      const consoleMock = jest.spyOn(console, 'error');
      consoleMock.mockImplementation(() => undefined);

      const errorFunction = () => {
        ReactTestUtils.renderIntoDocument(
          <Form onSubmit={undefined}>
            <FormDropdown inputKey={null} value={undefined} />
          </Form>
        );
      };

      expect(errorFunction).toThrow();
      expect(consoleMock).toHaveBeenCalledTimes(2);
      expect((consoleMock as jest.Mock).mock.calls[0][0]).toMatch(
        'Uncaught [Error: FormBaseInput: name must be defined on all form inputs]'
      );

      consoleMock.mockRestore();
    });

    it('Null props still render', () => {
      const wrapper = Enzyme.shallow(
        <Form onSubmit={undefined}>
          <FormDropdown inputKey="name" value={undefined} />
        </Form>
      );

      expect(wrapper.find('ms-Dropdown')).toBeTruthy();
    });

    it('With initial value', () => {
      let result: IFormResult;
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form
          ref={formRef}
          onSubmit={(value: IFormResult) => {
            result = value;
          }}
        >
          <FormDropdown
            inputKey="name"
            dropdownProps={{
              options: [
                { key: 1, text: 'Option 1' },
                { key: 0, text: 'Option 2' },
                { key: 2, text: 'Option 3' }
              ]
            }}
            value={0}
          />
        </Form>
      );

      const form: HTMLFormElement = ReactTestUtils.findRenderedDOMComponentWithTag(
        formRef.current,
        'form'
      ) as HTMLFormElement;
      ReactTestUtils.Simulate.submit(form);

      expect(result.name).toEqual(0);
    });
  });

  describe('Dropdown update tests', () => {
    jest.useFakeTimers();
    beforeEach(() => {
      jest.useFakeTimers();
    });

    afterEach(() => {
      jest.clearAllTimers();
    });

    class ExtendsDropdown extends FormDropdown {
      public setValue(value: number): void {
        super.setValue(value);
      }
    }

    it('Dropdown values update on change', () => {
      const options = [
        {
          key: 0,
          text: ''
        },
        {
          key: 1,
          text: ''
        }
      ];
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef}>
          <FormDropdown
            inputKey="name"
            value={0}
            dropdownProps={{
              options
            }}
          />
        </Form>
      );

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const formDropdown: any = ReactTestUtils.findRenderedComponentWithType(formRef.current, FormDropdown);

      // select first option
      formDropdown._onChange(undefined, options[0]);
      expect(formDropdown.state.currentValue).toEqual(0);

      // select second option
      formDropdown._onChange(undefined, options[1]);
      expect(formDropdown.state.currentValue).toEqual(1);
    });

    it('Multiselect values update on change', () => {
      const options = [
        {
          key: 0,
          text: '',
          selected: false
        },
        {
          key: 1,
          text: '',
          selected: false
        }
      ];
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef}>
          <FormDropdown
            inputKey="name"
            value={0}
            dropdownProps={{
              options,
              multiSelect: true
            }}
          />
        </Form>
      );
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const formDropdown: any = ReactTestUtils.findRenderedComponentWithType(formRef.current, FormDropdown);

      // mark first option
      options[0].selected = true;
      formDropdown._onChange(undefined, options[0]);
      expect(formDropdown.state.currentValue).toEqual([0]);

      // mark second option
      options[1].selected = true;
      formDropdown._onChange(undefined, options[1]);
      expect(formDropdown.state.currentValue).toEqual([0, 1]);

      // unmark first option
      options[0].selected = false;
      formDropdown._onChange(undefined, options[0]);
      expect(formDropdown.state.currentValue).toEqual([1]);

      // mark first option again
      options[0].selected = true;
      formDropdown._onChange(undefined, options[0]);
      expect(formDropdown.state.currentValue).toEqual([1, 0]);

      // unmark first option again
      options[0].selected = false;
      formDropdown._onChange(undefined, options[0]);
      expect(formDropdown.state.currentValue).toEqual([1]);
    });

    // Disabled because of intermittent issues with timer logic.
    it.skip('Dropdown is leading and trailing debounced', done => {
      const updateStub = jest.fn();
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef} onUpdated={updateStub}>
          <ExtendsDropdown
            inputKey="name"
            value={0}
            dropdownProps={{
              options: [
                {
                  key: 0,
                  text: ''
                },
                {
                  key: 1,
                  text: ''
                }
              ]
            }}
          />
        </Form>
      );

      const datePicker: ExtendsDropdown = ReactTestUtils.findRenderedComponentWithType(
        formRef.current,
        ExtendsDropdown
      );
      datePicker.setValue(0);
      expect(updateStub).toHaveBeenCalledTimes(1);
      datePicker.setValue(1);
      expect(updateStub).toHaveBeenCalledTimes(1);
      jest.runAllTimers();
      expect(updateStub).toHaveBeenCalledTimes(2);
      done();
    });
  });
});
