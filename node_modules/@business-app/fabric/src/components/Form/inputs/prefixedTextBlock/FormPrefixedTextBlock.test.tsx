/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
import * as React from 'react';
import * as ReactDom from 'react-dom';
import * as ReactTestUtils from 'react-dom/test-utils';

// Controls
import * as Enzyme from 'enzyme';
import { TextFieldBase } from '@fluentui/react/lib/TextField';
import { Form } from '../../Form';
import { IFormProps } from '../../Form.types';
import { FormPrefixedTextBlock } from './FormPrefixedTextBlock';
import { IFormPrefixedTextBlockProps } from './FormPrefixedTextBlock.types';
import { FormBaseInput } from '../../FormBaseInput';

describe('FormTextInput Unit Tests', () => {
  describe('Renders for all combinations of props', () => {
    let formProps: IFormProps;
    let formPrefixedTextBlockProps: IFormPrefixedTextBlockProps;

    beforeEach(() => {
      formProps = {
        onSubmit: undefined
      };
      formPrefixedTextBlockProps = {
        inputKey: null as any,
        value: undefined
      };
    });

    it('Null name throws error', () => {
      const consoleMock = jest.spyOn(console, 'error');
      consoleMock.mockImplementation(() => undefined);

      const errorFunction = () => {
        Enzyme.mount(
          <Form {...formProps}>
            <FormPrefixedTextBlock {...formPrefixedTextBlockProps} />
          </Form>
        );
      };

      expect(errorFunction).toThrow();
      expect((consoleMock as jest.Mock).mock.calls[0][0]).toMatch(
        'Uncaught [Error: FormBaseInput: name must be defined on all form inputs]'
      );

      consoleMock.mockRestore();
    });

    it('Null props still render', () => {
      formPrefixedTextBlockProps.inputKey = 'name';
      const wrapper = Enzyme.mount(
        <Form {...formProps}>
          <FormPrefixedTextBlock {...formPrefixedTextBlockProps} />
        </Form>
      );

      expect(wrapper.find(TextFieldBase).length).toBe(1);
    });

    it('With initial value', () => {
      formPrefixedTextBlockProps.inputKey = 'name';
      formPrefixedTextBlockProps.value = 'Value';
      const wrapper = Enzyme.mount(
        <Form {...formProps}>
          <FormPrefixedTextBlock {...formPrefixedTextBlockProps} />
        </Form>
      );

      expect(wrapper.find(TextFieldBase).length).toBe(1);
    });
  });

  describe('Textbox update tests', () => {
    jest.useFakeTimers();
    beforeEach(() => {
      jest.useFakeTimers();
    });

    afterEach(() => {
      jest.clearAllTimers();
    });

    class ExtendsPrefixedTextBlock extends FormPrefixedTextBlock {
      public setValue(value: string): void {
        super.setValue(value);
      }
    }

    // Disable unstable test.
    it.skip('PrefixedTextBlock is only trailing debounced', done => {
      const updateStub = jest.fn();
      const formRef = React.createRef<Form>();
      ReactTestUtils.renderIntoDocument(
        <Form ref={formRef} onUpdated={updateStub}>
          <ExtendsPrefixedTextBlock inputKey="name" value={''} />
        </Form>
      );

      const textBlock: ExtendsPrefixedTextBlock = ReactTestUtils.findRenderedComponentWithType(
        formRef.current,
        ExtendsPrefixedTextBlock
      );
      textBlock.setValue('t');
      expect(updateStub).not.toHaveBeenCalled();
      textBlock.setValue('te');
      expect(updateStub).not.toHaveBeenCalled();
      jest.runAllTimers();
      expect(updateStub).toHaveBeenCalled();
      done();
    });

    it('TextInput state updates from props value change', () => {
      const updatedValue = 'updated';
      const formRef = React.createRef<Form>();
      const parent = document.createElement('div');
      ReactDom.render(
        <Form ref={formRef}>
          <FormPrefixedTextBlock inputKey="name" key="key" value={'old value'} />
        </Form>,
        parent
      );
      const textBlockElement: FormPrefixedTextBlock = ReactTestUtils.findRenderedComponentWithType(
        formRef.current,
        FormPrefixedTextBlock
      );
      const propsUpdateSpy = jest.spyOn(FormBaseInput, 'getDerivedStateFromProps');
      ReactDom.render(
        <Form>
          <FormPrefixedTextBlock inputKey="name" key="key" value={updatedValue} />
        </Form>,
        parent
      );

      expect(textBlockElement.state.currentValue).toEqual(updatedValue);
      expect(propsUpdateSpy).toHaveBeenCalledTimes(1);
    });

    it(`TextInput state doesn't update with no new props value`, () => {
      const oldValue = 'old value';
      const formRef = React.createRef<Form>();
      const parent = document.createElement('div');
      ReactDom.render(
        <Form ref={formRef}>
          <FormPrefixedTextBlock inputKey="name" key="key" value={oldValue} />
        </Form>,
        parent
      );
      const textBlockElement: FormPrefixedTextBlock = ReactTestUtils.findRenderedComponentWithType(
        formRef.current,
        FormPrefixedTextBlock
      );
      const setStateSpy = jest.spyOn(textBlockElement, 'setState');
      ReactDom.render(
        <Form>
          <FormPrefixedTextBlock inputKey="name" key="key" value={oldValue} />
        </Form>,
        parent
      );

      expect(setStateSpy).toHaveBeenCalledTimes(0);
    });
  });
});
