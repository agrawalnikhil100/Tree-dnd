/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { Icon } from '@fluentui/react/lib/Icon';
import { IProcessedStyleSet, mergeStyles } from '@fluentui/react/lib/Styling';
import { classNamesFunction } from '@fluentui/react/lib/Utilities';
import { css } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { StepStatus } from '../StepStatus';
import { WizardProgressProps, WizardProgressStyleProps, WizardProgressStyles } from './WizardProgress.types';

interface IWizardProgressState {
  isWizardProgressCollapsedOnSmallScreens?: boolean;
}

const getClassNames = classNamesFunction<WizardProgressStyleProps, WizardProgressStyles>();

export class WizardProgressBase extends React.Component<WizardProgressProps> {
  public state: IWizardProgressState = {
    isWizardProgressCollapsedOnSmallScreens: true
  };

  public render() {
    const {
      styles,
      currentIndex,
      stepStatuses,
      theme,
      className,
      expandButtonLabel,
      collapseButtonLabel,
      onProgressStepClick
    } = this.props;
    const classNames = getClassNames(styles, {
      theme: theme!,
      className
    });

    return (
      <nav
        className={css(classNames.root, this.state.isWizardProgressCollapsedOnSmallScreens && 'is-collapsed')}
      >
        <ol className={classNames.list}>
          {this.props.stepNames.map((stepName, stepIndex) => (
            <li key={stepName} className={classNames.itemWrapper}>
              <div
                className={this.getStepClassName(stepIndex, currentIndex, classNames)}
                aria-label={stepName}
                aria-describedby={`WizardProgress-step${stepIndex}-description WizardProgress-step${stepIndex}-summary-container`}
                // eslint-disable-next-line react/jsx-no-bind
                onClick={onProgressStepClick ? onProgressStepClick.bind(this, stepIndex) : undefined}
                style={{ cursor: onProgressStepClick ? 'pointer' : undefined }}
                role={onProgressStepClick ? 'button' : undefined}
                tabIndex={onProgressStepClick ? 0 : undefined}
              >
                <Icon
                  iconName={getIconForStepStatus(stepStatuses[stepIndex])}
                  className={this.getIconClassName(stepIndex, classNames)}
                />
                <span className={classNames.label}>{stepName}</span>
                <div id={`WizardProgress-step${stepIndex}-summary-container`}>
                  {this.props.stepSummaries[stepIndex].map((summary, i) => (
                    <div key={i} className={classNames.summary}>
                      {summary}
                    </div>
                  ))}
                </div>
              </div>
              <div className={classNames.visuallyHidden} id={`WizardProgress-step${stepIndex}-description`}>
                {this.props.computeAriaDescription(stepIndex)}
              </div>
            </li>
          ))}
        </ol>
        <button
          className={classNames.toggle}
          onClick={this.onToggleClicked}
          aria-expanded={!this.state.isWizardProgressCollapsedOnSmallScreens}
          aria-label={
            this.state.isWizardProgressCollapsedOnSmallScreens ? expandButtonLabel : collapseButtonLabel
          }
          title={this.state.isWizardProgressCollapsedOnSmallScreens ? expandButtonLabel : collapseButtonLabel}
        >
          <Icon iconName="Cancel" />
        </button>
      </nav>
    );
  }

  private getIconClassName(stepIndex: number, classNames: IProcessedStyleSet<WizardProgressStyles>) {
    const { stepStatuses, currentIndex } = this.props;
    const status = stepStatuses[stepIndex];
    switch (status) {
      case StepStatus.Valid:
        return classNames.validIcon;

      case StepStatus.Warning:
        return classNames.warningIcon;

      case StepStatus.Error:
        return classNames.errorIcon;

      case StepStatus.Empty:
        if (stepIndex === currentIndex) {
          return classNames.currentEmptyIcon;
        } else {
          return classNames.emptyIcon;
        }

      default:
        break;
    }

    return '';
  }

  private getStepClassName(
    stepIndex: number,
    currentIndex: number,
    classNames: IProcessedStyleSet<WizardProgressStyles>
  ) {
    let className = '';
    if (stepIndex < currentIndex) {
      className = classNames.passedStep;
    } else if (stepIndex === currentIndex) {
      className = classNames.currentStep;
    } else if (stepIndex > currentIndex) {
      className = classNames.futureStep;
    }

    if (stepIndex === this.props.stepNames.length - 1) {
      className = mergeStyles(className, classNames.lastStep);
    }

    return className;
  }

  private onToggleClicked = () => {
    this.setState({
      isWizardProgressCollapsedOnSmallScreens: !this.state.isWizardProgressCollapsedOnSmallScreens
    });
  };
}

function getIconForStepStatus(stepStatus: StepStatus) {
  switch (stepStatus) {
    case StepStatus.Valid:
      return 'CheckMark';
    case StepStatus.Warning:
      return 'WarningSolid';
    case StepStatus.Error:
      return 'StatusErrorFull';
    case StepStatus.Empty:
      return '';
    default:
      throw new Error('Not implemented');
  }
}
