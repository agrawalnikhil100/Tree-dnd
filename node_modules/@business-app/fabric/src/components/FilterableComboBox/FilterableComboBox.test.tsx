/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import * as Enzyme from 'enzyme';
import 'jest';
import { IComboBoxOption } from '@fluentui/react/lib/ComboBox';
import { SelectableOptionMenuItemType } from '@fluentui/react/lib/SelectableOption';
import * as React from 'react';
import { FilterableComboBox } from './FilterableComboBox';
import filterOptions from './onFilterOptions';

function option(text: string): IComboBoxOption {
  return {
    key: text,
    text
  };
}

function header(text: string): IComboBoxOption {
  return {
    key: text,
    text,
    itemType: SelectableOptionMenuItemType.Header
  };
}

function divider(text: string = 'Divider'): IComboBoxOption {
  return {
    key: 'div_' + ('' + Math.random()).substr(0, 10),
    text,
    itemType: SelectableOptionMenuItemType.Divider
  };
}

describe('FilterableComboBox', () => {
  it('should render', () => {
    const options: IComboBoxOption[] = [option('Red'), option('Blue'), option('Green')];
    const fcb = Enzyme.shallow(<FilterableComboBox options={options} />);

    expect(fcb.exists()).toBeTruthy();
  });

  it('should allow default comboBox behavior when allow.', () => {
    const options: IComboBoxOption[] = [option('Red'), option('Blue'), option('Green')];
    const onChange = jest.fn();
    const wrapper = Enzyme.mount(
      <FilterableComboBox options={options} onChange={onChange} allowFreeform={true} />
    );

    wrapper.find('.ms-Icon').simulate('click');

    const numberOfOptions = wrapper.find('button[role="option"]').length;
    expect(numberOfOptions).toBe(3);
    expect(wrapper.find('button[title="Red"]').length).toBe(1);

    wrapper.find('button[title="Red"]').simulate('click');
    expect(onChange).toBeCalledTimes(1);

    wrapper.unmount();
  });

  it('should allow free form when the appropriate option is set to true', () => {
    const options: IComboBoxOption[] = [option('Red'), option('Blue'), option('Green')];
    const wrapper = Enzyme.mount(
      <FilterableComboBox options={options} allowFreeform={true} selectedKey={''} />
    );

    const allowFreeform = wrapper.prop('allowFreeform');
    expect(allowFreeform).toBe(true);
    expect(wrapper.find('input').get(0).props.value).toBe('');

    wrapper.setProps({ selectedKey: 'Text' });
    wrapper.update();

    expect(wrapper.find('input').get(0).props.value).toBe('Text');
    wrapper.unmount();
  });

  describe('filterOptions', () => {
    it('should return the list of options given if not provided a filter', () => {
      const options = [];
      expect(filterOptions(undefined, options)).toBe(options);
    });

    it("should only include options where the filter is a case-insensitive substring of the option's text value", () => {
      const options: IComboBoxOption[] = [
        option('Foo Bar'),
        option('Bar Foo'),
        option('Baz Boo'),
        option('Qux Cadr'),
        option('RebAR')
      ];

      expect(filterOptions('bar', options).map(op => op.text)).toEqual(['Foo Bar', 'Bar Foo', 'RebAR']);
    });

    it("should include all options underneath a matching header even if the options themselves don't match", () => {
      const options: IComboBoxOption[] = [
        header('Blues'),
        option('Dark Blue'),
        option('Azure'),
        option('Cerulean')
      ];

      expect(filterOptions('blue', options).map(op => op.text)).toEqual([
        'Blues',
        'Dark Blue',
        'Azure',
        'Cerulean'
      ]);
    });

    it('should include the header of a group with at least one match even if the header does not match', () => {
      const options: IComboBoxOption[] = [
        header('Blues'),
        option('Dark Blue'),
        option('Azure'),
        option('Cerulean')
      ];

      expect(filterOptions('ceru', options).map(op => op.text)).toEqual(['Blues', 'Cerulean']);
    });

    it('should strip any trailing divider if actually filtering', () => {
      const options: IComboBoxOption[] = [
        header('Blues'),
        option('Dark Blue'),
        option('Azure'),
        option('Cerulean'),
        divider()
      ];

      expect(
        filterOptions('blue', options).filter(op => op.itemType === SelectableOptionMenuItemType.Divider)
          .length
      ).toBe(0);
    });
  });
});
