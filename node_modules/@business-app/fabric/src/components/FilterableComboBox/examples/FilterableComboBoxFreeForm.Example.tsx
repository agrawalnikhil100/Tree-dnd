/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { IComboBoxOption } from '@fluentui/react/lib/ComboBox';
import { Label } from '@fluentui/react/lib/Label';
import { SelectableOptionMenuItemType } from '@fluentui/react/lib/SelectableOption';
import { Stack } from '@fluentui/react/lib/Stack';
import * as React from 'react';
import { FilterableComboBox } from '../FilterableComboBox';

const tags: IComboBoxOption[] = [
  'Azure',
  'Azure Light',
  'Azure Dark',
  'Black',
  'Cerulean',
  'Gray',
  'Green',
  'Lilac',
  'Rose',
  'Ruby',
  'Yellow',
  'オレンジ',
  '青い'
].map<IComboBoxOption>(name => ({
  key: name.toLowerCase(),
  text: name.indexOf('_') === 0 ? name.substr(1) : name,
  itemType:
    name.indexOf('_') === 0
      ? SelectableOptionMenuItemType.Header
      : name.indexOf('&') === 0
      ? SelectableOptionMenuItemType.Divider
      : SelectableOptionMenuItemType.Normal
}));

export class FilterableComboBoxFreeFormExample extends React.Component<
  {},
  { selectedKey: string; selectedOption: IComboBoxOption | undefined }
> {
  public state = {
    selectedKey: undefined,
    selectedOption: undefined
  };

  public render(): JSX.Element {
    return (
      <Stack maxWidth={400} gap={16}>
        <p>
          <Label>Last selected option: {this.state.selectedKey}</Label>
        </p>
        <FilterableComboBox
          label={'Choose an option'}
          options={tags}
          noResultsMessage={query => (
            <Label
              styles={{ root: { padding: '8px 16px' } }}
            >{`No results found matching "${query}".`}</Label>
          )}
          allowFreeform={true}
          calloutProps={{ calloutMaxHeight: 400 }}
          revertToLastValidOptionOnInvalidFilter={false}
          selectedKey={this.state.selectedKey}
          useComboBoxAsMenuWidth={true}
          disableInputPrediction={true}
          onPendingValueChanged={(option, index, value) => {
            if (option?.text) {
              this.setState({ selectedKey: option.text as string });
            } else if (value !== undefined) {
              // Free form allows empty strings, just checking for undefined
              this.setState({ selectedKey: value });
            }
          }}
          onChange={(evt, option, index, value) =>
            option && this.setState({ selectedKey: option.text as string })
          }
        />
      </Stack>
    );
  }
}
