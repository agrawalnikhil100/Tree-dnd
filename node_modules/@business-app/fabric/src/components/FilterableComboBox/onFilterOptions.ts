/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { IComboBoxOption } from '@fluentui/react/lib/ComboBox';
import { SelectableOptionMenuItemType } from '@fluentui/react/lib/SelectableOption';
import { IFilterableComboBoxProps } from './FilterableComboBox.types';

export const matches = (whole: string, part: string) => whole.toLowerCase().indexOf(part.toLowerCase()) >= 0;

export default function filterOptions(
  filter: string | undefined,
  options: IComboBoxOption[],
  defaultFilter?: IFilterableComboBoxProps['onFilterOptions']
): IComboBoxOption[] {
  if (!filter) {
    return options;
  }

  const groupFiltered = options.reduce(
    (acc, item) => {
      if (item.itemType === SelectableOptionMenuItemType.Header) {
        // always show headers, even if they don't match anything
        acc.currentGroup = item.text;
        item.data = { ...item.data, __group: acc.currentGroup };
        acc.results = acc.results.concat(item);
        acc.currentGroupMatches = matches(item.text, filter);
      } else if (item.itemType === SelectableOptionMenuItemType.Normal || item.itemType === undefined) {
        // itemType undefined defaults to being a normal option
        item.data = { ...item.data, __group: acc.currentGroup };
        if (acc.currentGroupMatches || matches(item.text, filter)) {
          // if there is a current group, show everything underneath that group even if it doesn't match the filter
          acc.results = acc.results.concat(item);
          // as the group has an item, mark it as so
          acc.groupsWithItems[acc.currentGroup] = true;
        }
      } else if (item.itemType === SelectableOptionMenuItemType.Divider) {
        // always add dividers
        item.data = { ...item.data, __group: acc.currentGroup };
        acc.results = acc.results.concat(item);
      }

      return {
        currentGroupMatches: acc.currentGroupMatches,
        currentGroup: acc.currentGroup,
        results: acc.results,
        groupsWithItems: acc.groupsWithItems
      };
    },
    {
      currentGroupMatches: false as boolean,
      currentGroup: undefined as string | undefined,
      results: [] as IComboBoxOption[],
      groupsWithItems: {} as Record<string, boolean>
    }
  );

  // now that we've filtered out all non-matching items
  // we need to filter out all group headers and dividers that have no matching children
  let filtered = groupFiltered.results.filter(
    item => !filter || groupFiltered.groupsWithItems[item.data.__group]
  );

  // OK almost done! if the last element is a divider, get rid of it
  if (
    filtered.length >= 1 &&
    filtered[filtered.length - 1].itemType === SelectableOptionMenuItemType.Divider
  ) {
    filtered = filtered.slice(0, filtered.length - 1);
  }

  return filtered;
}
