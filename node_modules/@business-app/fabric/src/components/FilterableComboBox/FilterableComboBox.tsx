/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { Autofill } from '@fluentui/react/lib/Autofill';
import { ComboBox, IComboBox, IComboBoxOption, IComboBoxProps } from '@fluentui/react/lib/ComboBox';
import * as React from 'react';
import { IFilterableComboBoxProps } from './FilterableComboBox.types';
import filterOptions from './onFilterOptions';

interface IFilterableComboBoxState {
  readonly filter: string | undefined;

  /**
   * Whether the menu is currently open.
   */
  readonly isMenuOpen: boolean;

  /**
   * Correlated with the above, whether the user has input a filter string into the freeform input
   * since the menu was last opened.
   */
  readonly userHasInputFilter: boolean;
}

export function filterableComboBox(ComboBoxComponent: React.ComponentType<IComboBoxProps>) {
  return class FilterableComboBoxBase extends React.Component<
    Omit<IComboBoxProps, 'ref'> & IFilterableComboBoxProps,
    IFilterableComboBoxState
  > {
    public readonly state: IFilterableComboBoxState = {
      filter: this.props.text,
      isMenuOpen: false,
      userHasInputFilter: false
    };

    public readonly comboBoxRef = React.createRef<IComboBox>();

    public readonly filterOptions = (
      userHasInputFilter: boolean,
      onFilterOptions: typeof filterOptions,
      filter: string,
      options: IComboBoxOption[]
    ) => {
      return userHasInputFilter ? onFilterOptions(filter, options, onFilterOptions) : options;
    };

    public onSetFocus = () => {
      if (this.comboBoxRef.current) {
        this.comboBoxRef.current.focus(true, true);
      }
    };

    public render() {
      const { onFilterOptions = filterOptions, options, noResultsMessage, ...rawProps } = this.props;
      const { filter, userHasInputFilter } = this.state;

      const filteredOptions = this.filterOptions(userHasInputFilter, onFilterOptions, filter, options);

      const onRenderLowerContent = () =>
        filteredOptions?.length <= 0
          ? typeof noResultsMessage === 'function'
            ? noResultsMessage(filter)
            : noResultsMessage
          : null;
      return (
        <>
          <ComboBoxComponent
            {...rawProps}
            allowFreeform={true}
            autoComplete="off"
            autofill={{
              ...rawProps.autofill,
              onFocus: this.onAutofillFocus,
              onBlur: this.onAutofillBlur
            }}
            componentRef={this.comboBoxRef}
            options={filteredOptions}
            text={
              this.props.allowFreeform
                ? (this.props.selectedKey as string)
                : this.props.selectedKey
                ? filter
                : undefined
            }
            onChange={this.onChange}
            onMenuDismissed={this.onMenuDismissed}
            onMenuOpen={this.onMenuOpen}
            onPendingValueChanged={this.onPendingValueChanged}
            onRenderLowerContent={onRenderLowerContent}
            onFocus={this.props.openOnClick ? this.onSetFocus : undefined}
          />

          <div
            aria-live="assertive"
            aria-atomic="true"
            style={{ overflow: 'hidden', position: 'absolute', top: -1000, left: -1000, width: 0, height: 0 }}
          >
            {onRenderLowerContent?.()}
          </div>
        </>
      );
    }

    public setFilter = (filter?: string) => this.setState({ filter });

    public onPendingValueChanged = (option?: IComboBoxOption, index?: number, value?: string) => {
      if (value !== undefined) {
        // if this is not undefined, then the user has typed in a value that doesn't directly match an option
        // the user can get into a state where they've closed the menu but are still able to type
        // re-open it please if this is so
        this.tryOpenComboBoxMenu();

        this.setFilter(value);
        this.setState({
          userHasInputFilter: true
        });
      } else if (option !== undefined) {
        const { disableInputPrediction = false } = this.props;

        // here is an interesting case
        // if the user types in an option verbatim
        // this callback is provided the option, but NOT the value string
        // however, this is the same as the user mousing over an option in the list,
        // which we don't want affecting the search query
        // naive heuristic instead is to see if we were just one character away from the option that was given
        // then just assume that the user typed it in
        if (
          !disableInputPrediction &&
          this.state.filter &&
          option.text.toLowerCase().indexOf(this.state.filter.toLowerCase()) >= 0 &&
          this.state.filter.length + 1 === option.text.length
        ) {
          this.setFilter(option.text);
          this.setState({
            userHasInputFilter: true
          });
        }
      }

      if (this.props.onPendingValueChanged) {
        this.props.onPendingValueChanged(option, index, value);
      }
    };

    public onChange = (
      event: React.FormEvent<IComboBox>,
      option?: IComboBoxOption,
      index?: number,
      value?: string
    ) => {
      if (option) {
        // yay it worked, give us an option!
        this.setFilter(option.text);
      } else {
        this.revertIfNeeded();
      }

      if (this.props.onChange) {
        this.props.onChange(event, option, index, value, {
          userHasInputFilter: this.state.userHasInputFilter
        });
      }

      this.onMenuDismissed();
    };

    public onAutofillFocus = (evt?: React.FocusEvent<HTMLInputElement | Autofill>) => {
      if (this.props.autofill && this.props.autofill.onFocus) {
        this.props.autofill.onFocus(evt);
      }
    };

    public onMenuOpen = () => {
      if (!this.state.isMenuOpen) {
        this.setState({
          isMenuOpen: true
        });
      }

      if (this.props.onMenuOpen) {
        this.props.onMenuOpen();
      }
    };

    public onMenuDismissed = () => {
      if (this.state.isMenuOpen) {
        this.setState({
          isMenuOpen: false,
          userHasInputFilter: false
        });
      }

      if (this.props.onMenuDismissed) {
        this.props.onMenuDismissed();
      }
    };

    /**
     * If the user has left an invalid filter in the combobox when exiting the control,
     * (and the control consumer has not disabled this behavior), reset the
     * filter value to the last valid selected option.
     */
    public revertIfNeeded = () => {
      const { options, revertToLastValidOptionOnInvalidFilter = true } = this.props;
      const { filter } = this.state;
      if (!revertToLastValidOptionOnInvalidFilter) {
        return;
      }

      const [optionMatchingFilter] = options.filter(option => option.text.toLowerCase() === filter);
      if (optionMatchingFilter) {
        // it's ok!
        return;
      }

      // it was bad, time to revert
      if (!this.props.selectedKey) {
        return this.setFilter('');
      }

      const [lastValidOption] = this.props.options.filter(option => option.key === this.props.selectedKey);
      if (!lastValidOption) {
        return this.setFilter('');
      }

      return this.setFilter(lastValidOption.text);
    };

    public onAutofillBlur = (evt?: React.FocusEvent<HTMLInputElement | Autofill>) => {
      if (window && window.setTimeout) {
        // Not fantastic
        // We are essentially waiting a short amount of time in order for the combobox menu to fully dismiss
        // before changing the filter, otherwise we see the menu flicker as it animates out
        window.setTimeout(this.revertIfNeeded, 100);
      }

      if (this.props.autofill && this.props.autofill.onBlur) {
        this.props.autofill.onBlur(evt);
      }
    };

    public tryOpenComboBoxMenu() {
      if (this.comboBoxRef.current && !this.state.isMenuOpen && !this.props.disabled) {
        this.comboBoxRef.current.focus(true);
        this.setState({
          isMenuOpen: true
        });
      }
    }
  };
}

export const FilterableComboBox = filterableComboBox(ComboBox);
