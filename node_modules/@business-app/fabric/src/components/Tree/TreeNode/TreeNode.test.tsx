/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { mount, ReactWrapper } from 'enzyme';
import * as React from 'react';
import { ContextualMenuButton } from '../ContextualMenuButton/ContextualMenuButton';
import { ExpandIcon } from '../ExpandIcon/ExpandIcon';
import { TreeAutomationSelectors } from '../Tree.selectors';
import { SelectionType } from '../Tree.types';
import { ITreeNodeState, TreeNode } from './TreeNode';
import { ITreeNodeProps } from './TreeNode.types';

type TreeNodeWrapper = ReactWrapper<ITreeNodeProps, ITreeNodeState>;

function getStateOf(wrapper: TreeNodeWrapper): ITreeNodeState {
  const instance = wrapper.instance();

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return (instance as any).state;
}

function getDefaultProps(overrides?: Partial<ITreeNodeProps>): ITreeNodeProps {
  return {
    itemKey: 'key',
    label: 'label',
    ariaLabel: 'aria label',
    iconProps: { iconName: 'Mail' },
    isFolder: false,
    isSelectionDisabled: false,
    isDisabled: false,
    level: 0,
    setSize: 1,
    indexInParent: 0,
    isExpanded: false,
    isSelected: false,
    isFocusable: true,
    isCollapsible: true,
    hasCommands: true,

    moreCommandsAriaLabel: 'more commands aria label',
    moreIcon: 'More',

    collapsedArrowIcon: 'ChevronRight',

    // Styles
    itemStyle: '',
    itemLabelStyle: '',
    indentSpacerStyle: '',
    menuButtonStyle: '',
    menuButtonOpenStyle: '',
    menuButtonClosedStyle: '',
    menuButtonDisabledStyle: '',
    expandIconButtonStyle: '',
    expandIconStyle: '',
    noExpandIconStyle: '',
    itemIconContainerStyle: '',
    itemIconStyle: '',
    noItemIconStyle: '',

    onSelected: (itemKey: string, type: SelectionType) => {
      /* no-op */
    },
    onDoubleClicked: (itemKey: string) => {
      /* no-op */
    },
    onExpandToggled: (itemKey: string) => {
      /* no-op */
    },

    onItemKeyDown: (itemKey: string, event: React.KeyboardEvent<HTMLElement>) => {
      /* no-op */
    },
    getCommands: (itemKey: string) => [
      {
        key: 'New',
        text: 'New',
        iconProps: { iconName: 'Add' }
      },
      {
        key: 'Mail',
        text: 'Mail',
        iconProps: { iconName: 'Mail' }
      }
    ],

    // Overrides last so they override.
    ...overrides
  };
}

describe('TreeNode', () => {
  it('getItemIsDisabled', () => {
    const onDoubleClicked = jest.fn();

    const props = getDefaultProps({
      isDisabled: true,
      onDoubleClicked: onDoubleClicked
    });

    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);

    // Disabled tests
    expect(wrapper.find(ContextualMenuButton).at(0).props().disabled).toEqual(true);
    wrapper.simulate('contextmenu');
    expect(getStateOf(wrapper).isContextualMenuOpen).toEqual(false);
    wrapper.simulate('doubleclick');
    expect(onDoubleClicked).toHaveBeenCalledTimes(0);
    onDoubleClicked.mockReset();

    // Enable it
    wrapper.setProps({ isDisabled: false });

    // Enabled tests
    expect(wrapper.find(ContextualMenuButton).at(0).props().disabled).toEqual(false);
    wrapper.simulate('contextmenu');
    expect(getStateOf(wrapper).isContextualMenuOpen).toEqual(true);
    wrapper.simulate('doubleclick');
    expect(onDoubleClicked).toHaveBeenCalledTimes(1);
    onDoubleClicked.mockReset();

    wrapper.unmount();
  });

  it('onRenderContextualMenu', () => {
    const mockContextualMenuId = 'contextual-menu-id';
    const contextualMenuSelector = `#${mockContextualMenuId}`;

    const props = getDefaultProps({
      onRenderContextualMenu: () => <div id={mockContextualMenuId} />
    });

    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);

    expect(wrapper.find(contextualMenuSelector).length).toEqual(0);
    expect(getStateOf(wrapper).isContextualMenuOpen).toEqual(false);

    wrapper.simulate('contextmenu');
    expect(getStateOf(wrapper).isContextualMenuOpen).toEqual(true);
    expect(wrapper.find(contextualMenuSelector).length).toEqual(1);

    wrapper.unmount();
  });

  it('allows overriding the default "expand" icon', () => {
    const mockCustomIconId = 'custom-icon-id';
    const customIconSelector = `#${mockCustomIconId}`;

    const props = getDefaultProps({
      onRenderExpandIcon: () => <div id={mockCustomIconId} />
    });

    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);

    expect(wrapper.find(customIconSelector).length).toEqual(1);

    wrapper.unmount();
  });

  it("allows overriding the label's content", () => {
    const mockCustomLabelContentId = 'custom-label-content-id';
    const customLabelContentSelector = `#${mockCustomLabelContentId}`;

    const props = getDefaultProps({
      itemLabelStyle: 'custom-item-label',
      onRenderItemLabelContent: () => <div id={mockCustomLabelContentId}>A custom label</div>
    });

    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);

    expect(wrapper.find(customLabelContentSelector).length).toEqual(1);
    expect(wrapper.find(customLabelContentSelector).at(0).text()).toEqual('A custom label');

    expect(
      wrapper.find(customLabelContentSelector).at(0).parent().hasClass('custom-item-label')
    ).toBeTruthy();

    wrapper.unmount();
  });

  it('Right click menu should not move to button when dismissed (instead, it should dismiss)', () => {
    const menuOpenSelector = `.${TreeAutomationSelectors.openMenuClassName}`;

    const props = getDefaultProps();
    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);

    wrapper.simulate('contextmenu');
    expect(getStateOf(wrapper).isContextualMenuOpen).toEqual(true);
    expect(wrapper.find(menuOpenSelector).length).toEqual(0);

    // Simulate dismissing the menu
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (wrapper.instance() as any)._dismissContextMenu();

    // Menu should close
    expect(getStateOf(wrapper).isContextualMenuOpen).toEqual(false);
    expect(wrapper.find(menuOpenSelector).length).toEqual(0);

    wrapper.unmount();
  });

  it('ContextualMenuButtons should not get rendered when unsupported', () => {
    const props = getDefaultProps();
    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);

    expect(wrapper.find(ContextualMenuButton).length).toEqual(1);
    wrapper.setProps({ hasCommands: false });
    expect(wrapper.find(ContextualMenuButton).length).toEqual(0);
    wrapper.setProps({ hasCommands: true });
    expect(wrapper.find(ContextualMenuButton).length).toEqual(1);
    wrapper.setProps({ getCommands: undefined });
    expect(wrapper.find(ContextualMenuButton).length).toEqual(0);

    wrapper.unmount();
  });

  it('ExpandIcon should stop propagation', () => {
    const props = getDefaultProps({ isCollapsible: true, isFolder: true });
    const wrapper: TreeNodeWrapper = mount(<TreeNode {...props} />);
    let stopPropagationCalledCount = 0;

    expect(wrapper.find(ExpandIcon).length).toEqual(1);
    expect(wrapper.find(ExpandIcon).props().disable).toEqual(false);

    // Propagation should be stopped on click when enabled
    wrapper
      .find(ExpandIcon)
      .at(0)
      .simulate('click', {
        stopPropagation: () => {
          stopPropagationCalledCount++;
        }
      });
    expect(stopPropagationCalledCount).toEqual(1);
    stopPropagationCalledCount = 0;

    // Propagation should be stopped on double click when enabled
    wrapper
      .find(ExpandIcon)
      .at(0)
      .simulate('doubleclick', {
        stopPropagation: () => {
          stopPropagationCalledCount++;
        }
      });
    expect(stopPropagationCalledCount).toEqual(1);
    stopPropagationCalledCount = 0;

    // Disable the expand icon
    wrapper.setProps({ isCollapsible: false });
    expect(wrapper.find(ExpandIcon).props().disable).toEqual(true);

    // Propagation should be stopped on click when disabled
    wrapper
      .find(ExpandIcon)
      .at(0)
      .simulate('click', {
        stopPropagation: () => {
          stopPropagationCalledCount++;
        }
      });
    expect(stopPropagationCalledCount).toEqual(1);
    stopPropagationCalledCount = 0;

    // Propagation should be stopped on double click when disabled
    wrapper
      .find(ExpandIcon)
      .at(0)
      .simulate('doubleclick', {
        stopPropagation: () => {
          stopPropagationCalledCount++;
        }
      });
    expect(stopPropagationCalledCount).toEqual(1);
    stopPropagationCalledCount = 0;

    wrapper.unmount();
  });
});
