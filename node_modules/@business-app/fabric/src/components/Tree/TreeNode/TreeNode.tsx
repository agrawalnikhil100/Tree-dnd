/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import {
  ContextualMenu,
  DirectionalHint,
  IContextualMenuItem,
  IContextualMenuProps
} from '@fluentui/react/lib/ContextualMenu';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import { IPoint, KeyCodes } from '@fluentui/react/lib/Utilities';
import * as React from 'react';

import { ContextualMenuButton } from '../ContextualMenuButton/ContextualMenuButton';
import { ExpandIcon } from '../ExpandIcon/ExpandIcon';
import { ItemIcon } from '../ItemIcon/ItemIcon';
import { NodeLevelIndentation } from '../NodeLevelIndentation/NodeLevelIndentation';
import { SelectionType } from '../Tree.types';
import { ITreeNodeProps } from './TreeNode.types';

export interface ITreeNodeState {
  contextualMenuTargetPoint: IPoint;
  isContextualMenuOpen: boolean;
  menuOpenedForItemKey: string;
  items: IContextualMenuItem[];
}
const contextMenuButtonClass = 'ba-Tree-MenuButton';

export class TreeNode extends React.Component<ITreeNodeProps, ITreeNodeState> {
  private contextMenuRef: React.RefObject<ContextualMenuButton>;
  private static _getStateFromProps(nextProps: ITreeNodeProps, prevState: ITreeNodeState): ITreeNodeState {
    // If the menu is open and the item changed, close the menu.
    if (prevState.isContextualMenuOpen && nextProps.itemKey !== prevState.menuOpenedForItemKey) {
      return {
        contextualMenuTargetPoint: undefined,
        isContextualMenuOpen: false,
        menuOpenedForItemKey: undefined,
        items: []
      };
    }

    return prevState;
  }

  private get _supportsContextualMenu(): boolean {
    const { hasCommands, getCommands } = this.props;
    return hasCommands && !!getCommands;
  }

  public constructor(props: ITreeNodeProps) {
    super(props);
    this.contextMenuRef = React.createRef();

    this.state = TreeNode._getStateFromProps(props, {
      contextualMenuTargetPoint: undefined,
      isContextualMenuOpen: false,
      menuOpenedForItemKey: undefined,
      items: []
    });
  }

  public static getDerivedStateFromProps(nextProps: ITreeNodeProps, prevState: ITreeNodeState) {
    if (!prevState) {
      return null;
    }
    return TreeNode._getStateFromProps(nextProps, prevState);
  }

  public render(): JSX.Element {
    const { itemKey, onRenderItemContainer } = this.props;

    if (onRenderItemContainer) {
      return onRenderItemContainer(itemKey, this._onRenderItemContainer);
    }

    return this._onRenderItemContainer();
  }

  private _onRenderItemContainer = () => {
    const {
      ariaLabel,
      iconProps,
      indentSpacerStyle,
      indexInParent,
      isDisabled,
      isFocusable,
      isSelected,
      itemIconContainerStyle,
      itemIconStyle,
      itemKey,
      itemStyle,
      label,
      level,
      menuButtonClosedStyle,
      menuButtonDisabledStyle,
      menuButtonOpenStyle,
      menuButtonStyle,
      moreCommandsAriaLabel,
      noItemIconStyle,
      onRenderExpandIcon,
      onRenderItemLabel,
      setSize
    } = this.props;

    const { contextualMenuTargetPoint, isContextualMenuOpen, items } = this.state;

    const useTargetPoint = !!contextualMenuTargetPoint;
    const itemAriaLabel = ariaLabel ? ariaLabel : label || itemKey;
    const contextualMenuButtonAriaLabel = !moreCommandsAriaLabel ? '' : moreCommandsAriaLabel;
    const supportsContextualMenu = this._supportsContextualMenu;

    return (
      <div
        className={itemStyle}
        role={'treeitem'}
        aria-disabled={isDisabled}
        aria-level={level + 1}
        aria-expanded={this._getAriaExpanded()}
        aria-selected={isSelected}
        aria-label={itemAriaLabel}
        aria-setsize={setSize === undefined ? undefined : setSize}
        aria-posinset={
          indexInParent === undefined ? undefined : indexInParent + 1 /* PosInSet is 1-indexed */
        }
        data-allow-keyboard-shortcut={true}
        data-disable-click-on-enter={true}
        data-is-focusable={isFocusable}
        onKeyDown={this._handleNodeKeyDown}
        onDoubleClick={!isDisabled ? this._onNodeDoubleClicked : undefined}
        onClick={this._onNodeSelected}
        onContextMenu={this._onContextMenu}
      >
        <NodeLevelIndentation level={level} className={indentSpacerStyle} />
        {onRenderExpandIcon
          ? onRenderExpandIcon(itemKey, this._onRenderExpandIcon)
          : this._onRenderExpandIcon()}
        <ItemIcon
          iconProps={iconProps}
          label={itemAriaLabel}
          itemIconContainerStyle={itemIconContainerStyle}
          itemIconStyle={itemIconStyle}
          noItemIconStyle={noItemIconStyle}
        />
        {onRenderItemLabel ? onRenderItemLabel(itemKey, this._onRenderItemLabel) : this._onRenderItemLabel()}
        {supportsContextualMenu && (
          <ContextualMenuButton
            disabled={isDisabled}
            items={items}
            isOpen={isContextualMenuOpen && !useTargetPoint}
            onClick={this._onMenuButtonClick}
            onDismiss={this._dismissContextMenu}
            directionalHint={DirectionalHint.bottomLeftEdge}
            iconProps={{
              iconName: 'More',
              ariaLabel: contextualMenuButtonAriaLabel
            }}
            ariaLabel={contextualMenuButtonAriaLabel}
            menuClosedStyle={mergeStyles(menuButtonStyle, menuButtonClosedStyle)}
            menuOpenStyle={mergeStyles(menuButtonStyle, menuButtonOpenStyle)}
            menuDisabledStyle={menuButtonDisabledStyle}
            onRenderContextualMenu={this._onRenderContextualMenu}
            ref={this.contextMenuRef}
          />
        )}
        {supportsContextualMenu &&
          isContextualMenuOpen &&
          useTargetPoint &&
          this._onRenderContextualMenu({
            items: items,
            onDismiss: this._dismissContextMenu,
            shouldFocusOnMount: true,
            gapSpace: 5,
            directionalHint: DirectionalHint.bottomLeftEdge,
            isBeakVisible: false,
            ariaLabel: itemAriaLabel,
            target: contextualMenuTargetPoint
          })}
      </div>
    );
  };

  private _onRenderItemLabelContent = (): JSX.Element => {
    const { label } = this.props;

    return <>{label}</>;
  };

  private _onRenderItemLabel = () => {
    const { itemKey, label, itemLabelStyle, onRenderItemLabelContent } = this.props;

    return (
      <div title={label} className={itemLabelStyle} aria-readonly={true}>
        {onRenderItemLabelContent ? onRenderItemLabelContent(itemKey, this._onRenderItemLabelContent) : label}
      </div>
    );
  };

  private _onRenderExpandIcon = () => {
    const {
      isFolder,
      isCollapsible,
      collapsedArrowIcon,
      expandIconButtonStyle,
      expandIconStyle,
      noExpandIconStyle
    } = this.props;

    return (
      <ExpandIcon
        isFolder={isFolder}
        disable={!isCollapsible}
        iconName={collapsedArrowIcon}
        iconClassName={expandIconStyle}
        buttonClassName={expandIconButtonStyle}
        noExpandClassName={noExpandIconStyle}
        onClick={this._onExpandIconClicked}
      />
    );
  };

  private _onRenderContextualMenu = (menuProps: IContextualMenuProps) => {
    const { itemKey, onRenderContextualMenu } = this.props;

    return onRenderContextualMenu ? (
      onRenderContextualMenu(itemKey, menuProps)
    ) : (
      <ContextualMenu {...menuProps} />
    );
  };

  private _getAriaExpanded = (): boolean => {
    const { isFolder, isExpanded } = this.props;

    return isFolder ? !!isExpanded : undefined;
  };

  private _getCommands = () => {
    const { itemKey, getCommands } = this.props;
    return getCommands(itemKey);
  };

  private _handleNodeKeyDown = (event: React.KeyboardEvent<HTMLElement>): void => {
    const { itemKey, isFolder, onExpandToggled, onItemKeyDown, isExpanded, isSelected } = this.props;

    const contextMenuFocused = document.activeElement.classList.contains(contextMenuButtonClass);

    if (!contextMenuFocused && onItemKeyDown) {
      onItemKeyDown(itemKey, event);
    }

    if (event.keyCode === KeyCodes.f10 && event.shiftKey) {
      this._showContextMenu();
      event.stopPropagation();
      event.preventDefault();
    } else if (event.keyCode === KeyCodes.left) {
      if (isFolder && isExpanded) {
        onExpandToggled(itemKey);
        event.stopPropagation();
        event.preventDefault();
      }
    } else if (event.keyCode === KeyCodes.right) {
      if (isFolder && !isExpanded) {
        onExpandToggled(itemKey);
        event.stopPropagation();
        event.preventDefault();
      }
    } else if (event.keyCode === KeyCodes.enter || event.keyCode === KeyCodes.space) {
      event.stopPropagation();
      event.preventDefault();
      if (contextMenuFocused) {
        this._showContextMenu();
      } else {
        this._onNodeSelected(event);
      }
    } else if (event.keyCode === KeyCodes.tab && isSelected) {
      // Without this there is no way to access the context menu via normal use of the keyboard.
      // You would still be able to with f10 + shiftKey, but, from feed back from the accessibility
      // team that is not sufficient.
      if (!contextMenuFocused) {
        event.stopPropagation();
        event.preventDefault();
        this.contextMenuRef.current._button.current.focus();
      }
    }
  };

  private _onExpandIconClicked = (event: React.MouseEvent<HTMLElement>): void => {
    this.props.onExpandToggled(this.props.itemKey);
  };

  private _onNodeDoubleClicked = (event: React.MouseEvent<HTMLElement>): void => {
    if (!event.ctrlKey && !event.shiftKey) {
      const { itemKey } = this.props;
      this.props.onDoubleClicked(itemKey);
    }
  };

  private _onNodeSelected = (
    event: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>
  ): void => {
    const { itemKey } = this.props;
    this.props.onSelected(
      itemKey,
      event.ctrlKey ? SelectionType.Toggle : event.shiftKey ? SelectionType.Block : SelectionType.Single
    );
  };

  private _onContextMenu = (ev: React.MouseEvent<HTMLElement>): void => {
    // Prevent propagation of the event, since we're handling it here.
    ev.stopPropagation();
    ev.preventDefault();

    this._toggleShowMenu({ x: ev.clientX, y: ev.clientY });
  };

  private _onMenuButtonClick = (ev: React.MouseEvent<HTMLButtonElement>): void => {
    // Prevent propagation of the event, since we're handling it here.
    ev.stopPropagation();
    ev.preventDefault();

    this._toggleShowMenu();
  };

  private _toggleShowMenu = (point?: IPoint): void => {
    if (!this.state.isContextualMenuOpen) {
      // Trigger the normal left-click behavior
      this._showContextMenu(point);
    } else {
      // Trigger the normal dismiss behavior
      this._dismissContextMenu();
    }
  };

  private _showContextMenu = (point?: IPoint) => {
    if (this.props.isDisabled && this._supportsContextualMenu) {
      return;
    }

    this.setState({
      items: this._getCommands(),
      isContextualMenuOpen: true,
      contextualMenuTargetPoint: point,
      menuOpenedForItemKey: this.props.itemKey
    });
  };

  private _dismissContextMenu = () => {
    if (!this.state.isContextualMenuOpen) {
      return;
    }

    this.setState({
      items: [],
      isContextualMenuOpen: false,
      contextualMenuTargetPoint: undefined,
      menuOpenedForItemKey: undefined
    });
  };
}
