/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import {
  ContextualMenuItemType,
  ContextualMenu as FabricContextualMenu
} from '@fluentui/react/lib/ContextualMenu';
import { BaseComponent, elementContains, KeyCodes } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { IContextualMenuItem, IContextualMenuProps } from './ContextualMenu.types';

export interface IContextualMenuState {
  displayItems: IContextualMenuItem[];
  loadingTimeout?: number;
}

export class ContextualMenu extends BaseComponent<IContextualMenuProps, IContextualMenuState> {
  private static _activeMenu?: ContextualMenu;

  /**
   * Set this BaseComponent._skipComponentRefResolution to true, bypassing resolution of componentRef.
   */
  protected _skipComponentRefResolution = true;

  private _activeElement?: HTMLElement = document.activeElement as HTMLElement;
  private _targetElement?: HTMLElement;
  private _timers?: number[] = [];

  /** Timeout used to track the closeTimeout on mouseLeave. */
  private closeTimeout?: number;

  private static _getStateFromProps(
    nextProps: IContextualMenuProps,
    prevState: IContextualMenuState
  ): IContextualMenuState {
    const newState = prevState;

    if (nextProps.isSubMenu) {
      let itemsChanged = prevState.displayItems.length !== nextProps.items.length;
      if (!itemsChanged) {
        // Check if same items exist
        itemsChanged = prevState.displayItems.some((value: IContextualMenuItem) => {
          return !nextProps.items.some(nextItem => nextItem.key === value.key);
        });
      }

      if (itemsChanged) {
        newState.displayItems = nextProps.items ? ContextualMenu._arrangeItems(nextProps.items) : [];
      }
    }

    return newState;
  }

  private static _arrangeItems(items: IContextualMenuItem[]): IContextualMenuItem[] {
    const shouldSortMenuItems = items.some(x => x.rank! >= 0);

    items = [...items];
    if (shouldSortMenuItems) {
      ContextualMenu._sortItems(items);
    }

    ContextualMenu._removeConsecutiveSeparators(items);
    return items;
  }

  private static _sortItems(items: IContextualMenuItem[]): void {
    // This is not a stable sort. If we pass items with the same rank, we may not always get them back in the
    // same order.
    items.sort((a, b) => {
      const aRank = a.rank || Number.MAX_VALUE;
      const bRank = b.rank || Number.MAX_VALUE;
      return aRank - bRank;
    });
  }

  private static _removeConsecutiveSeparators(items: IContextualMenuItem[]): void {
    let lastWasSeparator = true;
    for (let menuItemIndex = items.length - 1; menuItemIndex >= 0; menuItemIndex--) {
      const currentIsSeparator =
        items[menuItemIndex].itemType === ContextualMenuItemType.Divider || items[menuItemIndex].name === '-';
      if (currentIsSeparator && lastWasSeparator) {
        items.splice(menuItemIndex, 1);
      }

      lastWasSeparator = currentIsSeparator;
    }
  }

  public constructor(props: IContextualMenuProps) {
    super(props);

    this.state = ContextualMenu._getStateFromProps(props, {
      displayItems: this.props.items ? ContextualMenu._arrangeItems(this.props.items) : [],
      loadingTimeout: this._setTimeout(() => {
        this.setState({ loadingTimeout: undefined });
      }, 100)
    });
  }

  public static getDerivedStateFromProps(nextProps: IContextualMenuProps, prevState: IContextualMenuState) {
    if (!prevState) {
      return null;
    }
    return ContextualMenu._getStateFromProps(nextProps, prevState);
  }

  public render(): JSX.Element {
    if (this.state.loadingTimeout) {
      return null;
    }

    const { className, directionalHint, gapSpace = 5, ariaLabel, items = [] } = this.props;
    const { displayItems } = this.state;

    const hasIcons = !!(items && items.some(item => !!item.icon || !!item.iconProps));

    items.forEach((menuItem: IContextualMenuItem) => {
      menuItem.menuHasIcons = hasIcons;
      if (hasIcons && !menuItem.iconProps && !menuItem.icon) {
        menuItem.iconProps = { iconName: '' };
      }
    });

    return (
      <FabricContextualMenu
        gapSpace={gapSpace}
        directionalHint={directionalHint}
        {...this.props}
        items={displayItems}
        ariaLabel={ariaLabel}
        className={className}
        onDismiss={this._onDismiss}
      />
    );
  }

  public componentDidMount(): void {
    // Ensure we only have a single root menu open, ignore global processing for sub-menus.
    if (!this.props.isSubMenu) {
      if (ContextualMenu._activeMenu) {
        ContextualMenu._activeMenu.dismiss(null, true);
      }

      ContextualMenu._activeMenu = this;
    }

    this._targetElement = this.props.target as HTMLElement;
    this.setState({ loadingTimeout: undefined });

    if (this.props.mouseLeaveDelayMs) {
      // Tracks the mousemove on the document to close if the mouse is outside the menu for a period of time.
      this._events.on(document.body, 'mousemove', (event: React.MouseEvent) => {
        if (
          (this._targetElement && this._targetElement.contains(event.target as HTMLElement)) ||
          this.contains(event.target as HTMLElement)
        ) {
          if (this.closeTimeout) {
            this._clearTimeout(this.closeTimeout);
            delete this.closeTimeout;
          }
        } else {
          if (!this.closeTimeout) {
            this.closeTimeout = this._setTimeout(() => {
              delete this.closeTimeout;
              this.dismiss(event, true);
            }, this.props.mouseLeaveDelayMs || 0);
          }
        }
      });
    }

    this._events.on(document, 'keydown', (event: React.KeyboardEvent) => {
      // If a keystroke was made and we are not focused we need to close the menu.
      // We need to look at shouldFocusOnMount, since it may be an empty menu and we dont want it closed.
      // Don't close the menu for control keys (shift, alt, ctrl)
      if (
        event.which !== KeyCodes.shift &&
        event.which !== KeyCodes.ctrl &&
        event.which !== KeyCodes.alt &&
        !this.props.isSubMenu &&
        !this.props.shouldFocusOnMount &&
        !this.contains(document.activeElement as HTMLElement)
      ) {
        this.dismiss(event, true);
      }
    });
  }

  public componentWillUnmount(): void {
    super.componentWillUnmount();

    if (this.state.loadingTimeout) {
      this._clearTimeout(this.state.loadingTimeout);
    }

    if (this._timers) {
      for (const timer of this._timers) {
        window.clearTimeout(timer);
      }

      this._timers = [];
    }

    // If we are the active root menu we can clear our state on closure.
    if (ContextualMenu._activeMenu === this) {
      delete ContextualMenu._activeMenu;
    }
  }

  public contains(element: HTMLElement | null): boolean {
    return elementContains(ReactDOM.findDOMNode(this) as HTMLElement, element);
  }

  public dismiss(reason?: React.MouseEvent | React.KeyboardEvent, dismissAll?: boolean): void {
    if (this.props.onDismiss) {
      this.props.onDismiss(reason, true);
    }
  }

  private _clearTimeout(timeoutId: number): void {
    if (this._timers) {
      const timerIndex = this._timers.indexOf(timeoutId);
      this._timers.splice(timerIndex, 1);
    }

    window.clearTimeout(timeoutId);
  }

  private _onDismiss = (ev?: React.MouseEvent | React.KeyboardEvent, dismissAll?: boolean): void => {
    // If focus remains in the menu when it is dismissed we will set focus back to the
    // previously focused element.
    if (this._activeElement && this.contains(document.activeElement as HTMLElement)) {
      this._activeElement.focus();
    }

    this.props.onDismiss(ev, dismissAll);
  };

  private _setTimeout(
    callback: (...args: Array<{}>) => void,
    milliseconds?: number,
    ...args: Array<{}>
  ): number {
    const timerId = window.setTimeout(callback, milliseconds, ...args);
    if (!this._timers) {
      this._timers = [];
    }

    this._timers.push(timerId);
    return timerId;
  }
}
