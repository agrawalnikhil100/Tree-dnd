/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { mount, ReactWrapper } from 'enzyme';
import { IconBase } from '@fluentui/react/lib/Icon';
import { Link } from '@fluentui/react/lib/Link';
import { Spinner } from '@fluentui/react/lib/Spinner';
import { setIconOptions } from '@fluentui/react/lib/Styling';
import * as React from 'react';
import { AsyncTree } from './AsyncTree';
import { IAsyncTreeProps } from './AsyncTree.types';
import { ExpandIcon } from './ExpandIcon/ExpandIcon';
import { TreeNode } from './TreeNode/TreeNode';

type AsyncTreeWrapper = ReactWrapper<IAsyncTreeProps>;

const waitTime = 500;
const wait = (ms: number): Promise<void> => new Promise((r, j) => setTimeout(r, ms));

const onResolveItems: IAsyncTreeProps['onResolveItems'] = async item => {
  await wait(waitTime);

  const items = [];
  if (item === null) {
    for (let i = 0; i < 10; i++) {
      items.push({
        key: i.toString(),
        label: `Label-${i.toString()}`
      });
    }
  } else {
    for (let i = 0; i < 10; i++) {
      items.push({
        key: item.key + '/' + i.toString(),
        label: item.label + '/' + i.toString(),
        isFolder: i % 2 === 0
      });
    }
  }

  return [items, null];
};

const onResolveItemsWithFailures = () => {
  const failedItems = [];

  return (async item => {
    await wait(waitTime);

    const items = [];
    if (item === null) {
      for (let i = 0; i < 10; i++) {
        items.push({
          key: i.toString(),
          label: `Label-${i.toString()}`
        });
      }
    } else if (failedItems.indexOf(item) >= 0) {
      // Resolve items after failing initially.
      for (let i = 0; i < 10; i++) {
        items.push({
          key: item.key + '/' + i.toString(),
          label: item.label + '/' + i.toString(),
          isFolder: i % 2 === 0
        });
      }
    } else {
      failedItems.push(item);
      throw new Error();
    }

    return [items, null];
  }) as IAsyncTreeProps['onResolveItems'];
};

const defaultStrings = {
  listAriaLabel: 'list aria label',
  moreCommandsAriaLabel: 'more commands aria label'
};

describe('AsyncTree', () => {
  beforeAll(() => {
    setIconOptions({ disableWarnings: true });
  });

  it('dynamically loads all the "root" items when mounted', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItems} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    expect(wrapper.find(TreeNode).length).toBe(10);

    wrapper.unmount();
  });

  it('correctly renders dynamically loaded items', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItems} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    wrapper.find(TreeNode).forEach((c, index) => {
      expect(c.text()).toBe('Label-' + index);
    });

    wrapper.unmount();
  });

  it('shows a "Loading" sub-item with a spinner while dynamically expanding an item', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItems} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    const firstNode = wrapper.find(TreeNode).at(0);

    // Expand the first node
    firstNode.find(ExpandIcon).simulate('click');

    expect(wrapper.find(TreeNode).length).toBe(11);

    const loadingSubItem = wrapper.find(TreeNode).at(1);

    expect(loadingSubItem.find(Spinner).length).toBe(1);
    expect(loadingSubItem.text()).toBe('Loading...');

    wrapper.unmount();
  });

  it('hides the "Loading" sub-item after dynamically expanding an item', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItems} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    const firstNode = wrapper.find(TreeNode).at(0);

    // Expand the first node
    firstNode.find(ExpandIcon).simulate('click');

    expect(wrapper.find(TreeNode).length).toBe(11);
    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(1);

    // Wait for list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    expect(wrapper.find(TreeNode).length).toBe(20);
    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(0);

    wrapper.unmount();
  });

  it('shows multiple "Loading" sub-items spinning concurrently while dynamically expanding multiple items', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItems} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(0);

    wrapper.update();

    // Expand all nodes
    for (let i = 0; i < 10; i++) {
      wrapper
        .findWhere(x => x.key() === i.toString())
        .find(ExpandIcon)
        .simulate('click');
    }

    wrapper.update();

    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(10);

    wrapper.unmount();
  });

  it('shows an "Error" sub-item if an error occurs while dynamically expanding an item', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItemsWithFailures()} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    const firstNode = wrapper.find(TreeNode).at(0);

    // Expand the first node
    firstNode.find(ExpandIcon).simulate('click');

    // Wait for list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    expect(wrapper.find(TreeNode).length).toBe(11);

    const errorSubItem = wrapper.find(TreeNode).at(1);

    expect(errorSubItem.text()).toBe('Error loading. Try again');
    expect(errorSubItem.find(IconBase).length).toBe(1);
    expect(errorSubItem.find(IconBase).at(0).props().iconName).toBe('ErrorBadge');
    expect(errorSubItem.find(Link).at(0).text()).toBe('Try again');

    wrapper.unmount();
  });

  it('allows the user to retry loading items if an error occurs while dynamically expanding an item', async () => {
    const wrapper: AsyncTreeWrapper = mount(
      <AsyncTree onResolveItems={onResolveItemsWithFailures()} strings={defaultStrings} />
    );

    // Wait for initial list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    const firstNode = wrapper.find(TreeNode).at(0);

    // Expand the first node
    firstNode.find(ExpandIcon).simulate('click');

    // Wait for list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    expect(wrapper.find(TreeNode).length).toBe(11);

    let errorSubItem = wrapper.find(TreeNode).at(1);

    expect(errorSubItem.find(Link).length).toBe(1);

    const retryLink = errorSubItem.find(Link).at(0);

    retryLink.simulate('click');

    // The "Error" sub-item is no longer present.

    errorSubItem = wrapper.find(TreeNode).at(1);
    expect(errorSubItem.text()).not.toBe('Error loading. Try again');

    // The "Loading" sub-item is now present.
    let loadingSubItem = wrapper.find(TreeNode).at(1);

    expect(loadingSubItem.find(Spinner).length).toBe(1);
    expect(loadingSubItem.text()).toBe('Loading...');

    // Wait for list of items to load.
    await wait(waitTime + waitTime / 2);

    wrapper.update();

    expect(wrapper.find(TreeNode).length).toBe(20);

    // Loading sub-item is no longer present.
    loadingSubItem = wrapper.find(TreeNode).at(1);
    expect(loadingSubItem.text()).not.toBe('Loading...');
    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(0);

    wrapper.unmount();
  });
});
