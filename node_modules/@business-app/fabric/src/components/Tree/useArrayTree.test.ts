/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { act, renderHook } from '@testing-library/react-hooks';
import { ITreeItem } from './Tree.types';
import { useArrayTree } from './useArrayTree';

function createRandomItem(level: number) {
  const itemId = Math.floor(Math.random() * 1000);

  return {
    key: `item-${itemId}`,
    label: `Item ${itemId}`,
    level
  };
}

function createRandomItems(itemCount: number, level: number) {
  if (itemCount <= 0) {
    throw new Error('itemCount');
  }

  const items: ITreeItem[] = [];
  for (let i = 0; i < itemCount; i++) {
    items.push(createRandomItem(level));
  }

  return items;
}

describe('useArrayTree', () => {
  it('can be initialized with a collection of top level items', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));
    const { items } = result.current;

    expect(items).toEqual(topLevelItems);
  });

  it('can be initialized with an empty collection of top level items', () => {
    const { result } = renderHook(() => useArrayTree([]));
    const { items } = result.current;

    expect(items).toEqual([]);
  });

  it('can be initialized without a collection of top level items', () => {
    const { result } = renderHook(() => useArrayTree());
    const { items } = result.current;

    expect(items).toEqual([]);
  });

  it("throws if the 'level' property of any of the top level items is not equal to 0 during initialization", () => {
    const topLevelItems = createRandomItems(10, 0);
    topLevelItems[3].level = 1;

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { error } = result;

    expect(error).not.toBeUndefined();
  });

  it('calling getChildrenOf with [null] argument returns the top level items', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { getChildrenOf } = result.current;

    expect(getChildrenOf(null)).toEqual(topLevelItems);
  });

  it('calling getChildrenOf with a leaf item returns an empty array', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { getChildrenOf } = result.current;

    expect(getChildrenOf(topLevelItems[0])).toEqual([]);
  });

  it('calling getChildrenOf returns only the direct children of an item', () => {
    const topLevelItems = createRandomItems(10, 0);
    const secondLevelItems = createRandomItems(10, 1);
    const firstSecondLevelItem = secondLevelItems[0];
    const thirdLevelItems = createRandomItems(10, 2);
    const firstTopLevelItem = topLevelItems[0];

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    let { appendChildrenTo, getChildrenOf } = result.current;

    expect(getChildrenOf(firstTopLevelItem)).toEqual([]);

    act(() => {
      appendChildrenTo(firstTopLevelItem, secondLevelItems);
      appendChildrenTo(firstSecondLevelItem, thirdLevelItems);
    });

    const { items } = result.current;
    ({ appendChildrenTo, getChildrenOf } = result.current);

    expect(items.length).toBe(topLevelItems.length + secondLevelItems.length + thirdLevelItems.length);
    expect(getChildrenOf(firstTopLevelItem)).toEqual(secondLevelItems);
  });

  it('calling getChildrenOf throws when called with an item that is not present in the tree', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { getChildrenOf } = result.current;

    const item = createRandomItem(0);

    expect(() => getChildrenOf(item)).toThrowError('item');
  });

  it('calling appendChildrenTo with a [null] item inserts a collection of items after the last top level element', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { appendChildrenTo } = result.current;

    const moreTopLevelElements = createRandomItems(10, 0);

    act(() => appendChildrenTo(null, moreTopLevelElements));

    const { items } = result.current;

    expect(items).toEqual(topLevelItems.concat(moreTopLevelElements));
  });

  it('calling appendChildrenTo inserts a collection of items after the last child of an item', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { appendChildrenTo } = result.current;

    const children = createRandomItems(10, 1);

    act(() => appendChildrenTo(topLevelItems[0], children));

    const { getChildrenOf } = result.current;

    expect(getChildrenOf(topLevelItems[0])).toEqual(children);
  });

  it('calling appendChildrenTo throws when called with a child that is not at a level below the item', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { appendChildrenTo } = result.current;

    const children = createRandomItems(10, 0);

    expect(() => appendChildrenTo(topLevelItems[0], children)).toThrowError('children');
  });

  it('calling remove removes an item and all its children', () => {
    const topLevelItems = createRandomItems(10, 0);
    const secondLevelItems = createRandomItems(10, 1);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { appendChildrenTo, remove } = result.current;

    act(() => {
      appendChildrenTo(topLevelItems[0], secondLevelItems);
      remove(topLevelItems[0]);
    });

    const { items } = result.current;

    expect(items.indexOf(topLevelItems[0])).not.toBeGreaterThanOrEqual(0);
    expect(items.length).toEqual(topLevelItems.length - 1);
    expect(items).toEqual(topLevelItems.slice(1));
  });

  it('calling replace replaces an item but not its children', () => {
    const topLevelItems = createRandomItems(10, 0);
    const secondLevelItems = createRandomItems(10, 1);
    const replacementItem = createRandomItem(0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { appendChildrenTo, replace } = result.current;

    act(() => {
      appendChildrenTo(topLevelItems[0], secondLevelItems);
      replace(topLevelItems[0], replacementItem);
    });

    const { items, getChildrenOf } = result.current;

    expect(items.indexOf(topLevelItems[0])).not.toBeGreaterThanOrEqual(0);
    expect(items.indexOf(replacementItem)).toBeGreaterThanOrEqual(0);
    expect(getChildrenOf(replacementItem)).toEqual(secondLevelItems);
  });

  it('calling replace throws when called with a replacement item that has a different level', () => {
    const topLevelItems = createRandomItems(10, 0);
    const secondLevelItem = createRandomItems(1, 1)[0];

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { replace } = result.current;

    expect(() => {
      replace(topLevelItems[0], secondLevelItem);
    }).toThrow('replacementItem');
  });

  it('calling refresh returns a different array with the same items', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { items: itemsBefore, refresh } = result.current;

    expect(itemsBefore).toEqual(topLevelItems);

    act(() => {
      refresh();
    });

    const { items: itemsAfter } = result.current;

    expect(itemsAfter).not.toBe(itemsBefore);
    expect(itemsAfter).toEqual(topLevelItems);
  });

  it('calling clear removes all items from the tree', () => {
    const topLevelItems = createRandomItems(10, 0);

    const { result } = renderHook(() => useArrayTree(topLevelItems));

    const { clear } = result.current;

    act(() => {
      clear();
    });

    const { items } = result.current;

    expect(items.length).toBe(0);
  });
});
