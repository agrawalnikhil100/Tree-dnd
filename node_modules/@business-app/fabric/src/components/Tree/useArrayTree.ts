/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import * as React from 'react';
import { ITreeItem } from './Tree.types';

export interface IArrayTree<TTreeItem extends ITreeItem> {
  items: ReadonlyArray<Readonly<TTreeItem>>;
  getChildrenOf(item: Readonly<TTreeItem>): ReadonlyArray<Readonly<TTreeItem>>;
  appendChildrenTo(item: Readonly<TTreeItem> | null, children: ReadonlyArray<Readonly<TTreeItem>>): void;
  replace(item: Readonly<TTreeItem>, replacementItem: Readonly<TTreeItem>): void;
  remove(item: Readonly<TTreeItem>): void;
  clear(): void;
  refresh(): void;
}

export function useArrayTree<TTreeItem extends ITreeItem>(
  topLevelItems: TTreeItem[] = []
): IArrayTree<TTreeItem> {
  if (topLevelItems.some(x => x.level !== 0)) {
    throw new Error('topLevelItems');
  }

  const [treeItems, setTreeItems] = React.useState<TTreeItem[]>([...topLevelItems]);

  const getChildrenOf = React.useCallback(
    (item: TTreeItem | null) => {
      let startIndex: number;
      let itemLevel: number;

      if (item !== null) {
        const itemIndex = treeItems.indexOf(item);

        if (itemIndex < 0) {
          throw new Error('item');
        }
        startIndex = itemIndex;
        itemLevel = item.level;
      } else {
        startIndex = -1;
        itemLevel = -1;
      }

      const children = [];

      let index = startIndex;
      while (index + 1 < treeItems.length && treeItems[index + 1].level > itemLevel) {
        if (treeItems[index + 1].level === itemLevel + 1) {
          children.push(treeItems[index + 1]);
        }

        index++;
      }

      return children;
    },
    [treeItems]
  );

  const appendChildrenTo = React.useCallback(
    (item: Readonly<TTreeItem> | null, children: ReadonlyArray<Readonly<TTreeItem>>) => {
      let itemLevel: number;

      if (item !== null) {
        itemLevel = item.level;
      } else {
        itemLevel = -1;
      }

      if (children.some(x => x.level !== itemLevel + 1)) {
        throw new Error('children');
      }

      setTreeItems(items => {
        let startIndex: number;

        if (item !== null) {
          const itemIndex = items.indexOf(item);

          if (itemIndex < 0) {
            throw new Error('item');
          }
          startIndex = itemIndex;
        } else {
          startIndex = -1;
        }

        let index = startIndex;
        while (index + 1 < items.length && items[index + 1].level > itemLevel) {
          index++;
        }

        const indexOfLastDescendantOrSelf = index;

        items = items.slice();
        items.splice(indexOfLastDescendantOrSelf + 1, 0, ...children);

        return items;
      });
    },
    [setTreeItems]
  );

  const replace = React.useCallback(
    (item: Readonly<TTreeItem>, replacementItem: Readonly<TTreeItem>) => {
      if (item.level !== replacementItem.level) {
        throw new Error('replacementItem');
      }

      if (item.setSize !== replacementItem.setSize) {
        throw new Error('replacementItem');
      }

      setTreeItems(items => {
        const itemIndex = items.indexOf(item);

        if (itemIndex < 0) {
          return items;
        }

        items = items.slice();
        items.splice(itemIndex, 1, replacementItem);

        return items;
      });
    },
    [setTreeItems]
  );

  const remove = React.useCallback(
    (item: TTreeItem) => {
      setTreeItems(items => {
        const itemIndex = items.indexOf(item);

        if (itemIndex < 0) {
          throw new Error('item');
        }

        const startIndex = itemIndex;
        let endIndex = itemIndex;

        const itemLevel = item.level;

        while (endIndex + 1 < items.length && items[endIndex + 1].level > itemLevel) {
          endIndex++;
        }

        items = items.slice();
        items.splice(startIndex, endIndex - startIndex + 1);

        return items;
      });
    },
    [setTreeItems]
  );

  const clear = React.useCallback(() => {
    setTreeItems([]);
  }, [setTreeItems]);

  const refresh = React.useCallback(() => {
    setTreeItems(items => items.slice());
  }, [setTreeItems]);

  return {
    items: treeItems,
    getChildrenOf,
    appendChildrenTo,
    replace,
    remove,
    clear,
    refresh
  };
}
