/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { IContextualMenuItem, IContextualMenuProps } from '@fluentui/react/lib/ContextualMenu';
import { FocusZone, FocusZoneDirection } from '@fluentui/react/lib/FocusZone';
import { IIconProps } from '@fluentui/react/lib/Icon';
import { List } from '@fluentui/react/lib/List';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import { BaseComponent, classNamesFunction, customizable, findIndex } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { ITreeItem, ITreeProps, ITreeStyleProps, ITreeStyles, SelectionType } from './Tree.types';
import { TreeNode } from './TreeNode/TreeNode';

const getClassNames = classNamesFunction<ITreeStyleProps, ITreeStyles>();

export const defaultIconWidth = 26;
export const defaultNodeHeight = 32;

const defaultItemsPerPage = 10;

export type IReadonlyArray<T> = Pick<T[], Exclude<keyof T[], 'push'>>;
export type IReadonlySet<T> = Pick<Set<T>, Exclude<keyof Set<T>, 'add' | 'clear' | 'pizza'>>;
export type IReadonlyMap<K, V> = Pick<
  Map<K, V>,
  Exclude<keyof Map<K, V>, 'add' | 'clear' | 'delete' | 'set'>
>;

/**
 * The state for the tree.
 */
export interface ITreeState<T> {
  items: IReadonlyArray<T>;
  /** Only used for when node caching is disabled. Do not reference outside of that criteria. */
  visibleItems: IReadonlyArray<T>;
  visibleItemKeys: IReadonlySet<string>;
  cachedItemKeys: IReadonlySet<string>;
  keyToItemMap: IReadonlyMap<string, T>;
  keyToVisibleIndexMap: IReadonlyMap<string, number>;

  moreIcon: string;
  collapsedArrowIcon: string;

  selectedItemKeys: IReadonlySet<string>;
  expandedItemKeys: IReadonlySet<string>;

  areExpandedItemsDirty: boolean;
}

// Number.MAX_SAFE_INTEGER doesn't work in IE, so just use a large number.
const maxInt = 99999;

/**
 * A generic Tree component based on Fabric's List.
 */
@customizable('Tree', ['theme', 'styles'])
export class TreeBase<T extends ITreeItem> extends BaseComponent<ITreeProps<T>, ITreeState<T>> {
  private _list: List;
  private _isPendingScrollToSelected: boolean;
  private _focusZone = React.createRef<FocusZone>();
  private _classNames: { [key in keyof ITreeStyles]?: string } = {};
  private _visibleIndexByItem: { [key: string]: number } = {};
  private _cachedStyles: {
    unselectableItem: string;
    item: string;
    selectedItem: string;
    expandIconExpanded: string;
    expandIconButton: string;
    expandIconButtonDisabled: string;
  };

  private _hiddenStyle = { display: 'none' };

  private static _getStateFromProps<I extends ITreeItem>(
    nextProps: ITreeProps<I>,
    prevState: ITreeState<I>
  ): ITreeState<I> {
    const newState = prevState;
    const iconsProp = nextProps.icons;
    const itemsHaveChanged = nextProps.items !== prevState.items;
    const expandedItemKeysHaveChanged =
      prevState.areExpandedItemsDirty ||
      (nextProps.expandedItemKeys && nextProps.expandedItemKeys !== prevState.expandedItemKeys);

    newState.items = nextProps.items;
    newState.areExpandedItemsDirty = false;

    if (nextProps.selectedItemKeys) {
      newState.selectedItemKeys = nextProps.selectedItemKeys;
    }

    if (nextProps.expandedItemKeys) {
      newState.expandedItemKeys = nextProps.expandedItemKeys;
    }

    if (iconsProp) {
      if (iconsProp.more && iconsProp.more !== prevState.moreIcon) {
        newState.moreIcon = iconsProp.more;
      }

      if (iconsProp.collapsedArrow && iconsProp.collapsedArrow !== prevState.collapsedArrowIcon) {
        newState.collapsedArrowIcon = iconsProp.collapsedArrow;
      }
    }

    if (itemsHaveChanged || expandedItemKeysHaveChanged) {
      const keyToVisibleIndexMap = new Map<string, number>();
      const visibleItemKeys = new Set<string>();

      const visibleItems: I[] = [];
      const keyToItemMap = itemsHaveChanged ? new Map<string, I>() : null;
      const cachedItemKeys = itemsHaveChanged ? new Set<string>() : (newState.cachedItemKeys as Set<string>);

      let lastCollapsedLevel = maxInt;
      let visibleIndex: number = 0;

      nextProps.items.forEach((item, index) => {
        if (keyToItemMap) {
          keyToItemMap.set(item.key, item);
        }

        if (item.level <= lastCollapsedLevel) {
          if (newState.expandedItemKeys.has(item.key)) {
            lastCollapsedLevel = maxInt;
          } else {
            lastCollapsedLevel = item.level;
          }

          if (visibleItems) {
            visibleItems.push(item);
          } else {
            cachedItemKeys.add(item.key);
          }

          visibleItemKeys.add(item.key);
          keyToVisibleIndexMap.set(item.key, visibleIndex++);
        }
      });

      newState.keyToVisibleIndexMap = keyToVisibleIndexMap;
      newState.visibleItemKeys = visibleItemKeys;

      if (visibleItems) {
        newState.visibleItems = visibleItems;
      }

      if (keyToItemMap) {
        newState.keyToItemMap = keyToItemMap;
      }

      if (cachedItemKeys) {
        newState.cachedItemKeys = cachedItemKeys;
      }
    }

    return newState;
  }

  public constructor(props: ITreeProps<T>) {
    super(props);

    const initialSelectedItemKeys = new Set<string>();
    if (props.initialSelectedItemKeys) {
      props.initialSelectedItemKeys.forEach(key => initialSelectedItemKeys.add(key));
    }

    const initialExpandedItemKeys = new Set<string>();
    if (props.initialExpandedItemKeys) {
      props.initialExpandedItemKeys.forEach(key => initialExpandedItemKeys.add(key));
    }

    this.state = TreeBase._getStateFromProps(props, {
      items: [],
      visibleItems: [],
      visibleItemKeys: new Set(),
      cachedItemKeys: new Set(),
      keyToItemMap: new Map(),
      keyToVisibleIndexMap: new Map(),
      selectedItemKeys: initialSelectedItemKeys,
      expandedItemKeys: initialExpandedItemKeys,
      areExpandedItemsDirty: true,
      moreIcon: 'More',
      collapsedArrowIcon: 'ChevronRight'
    });
  }

  public static getDerivedStateFromProps<I extends ITreeItem>(
    nextProps: ITreeProps<I>,
    prevState: ITreeState<I>
  ) {
    if (!prevState) {
      return null;
    }
    return TreeBase._getStateFromProps(nextProps, prevState);
  }

  public componentDidUpdate(): void {
    this._applyPendingScroll();
  }

  public render(): JSX.Element {
    this._classNames = this._getClassNames(this.props);

    return (
      <div className={mergeStyles(this._classNames.root)}>
        <div className={mergeStyles(this._classNames.innerRoot)}>
          <FocusZone
            componentRef={this._focusZone}
            direction={FocusZoneDirection.vertical}
            className={this._classNames.focusZone}
          >
            {this._renderScrollViewAndList()}
          </FocusZone>
        </div>
      </div>
    );
  }

  /**
   * Sets focus to the first tree node.
   */
  public focus(): void {
    if (this._focusZone.current) {
      this._focusZone.current.focus();
    }
  }

  private _renderScrollViewAndList = (): JSX.Element => {
    const { scrollView } = this.props;

    if (!!scrollView) {
      const ScrollView = scrollView;
      return <ScrollView className={this._classNames.scrollView}>{this._renderList()}</ScrollView>;
    }
    return <div className={this._classNames.scrollView}>{this._renderList()}</div>;
  };

  private _renderList = (): JSX.Element => {
    const { items, strings } = this.props;

    return (
      <List
        className={this._classNames.list}
        ref={this._saveListRef}
        items={this._getVisibleItems(items)}
        role="tree"
        getKey={this._getKey}
        getPageHeight={this._getPageHeight}
        aria-label={strings.listAriaLabel}
        aria-multiselectable={true}
        onRenderCell={this._onRenderTreeNode}
      />
    );
  };

  private _getKey(item: T) {
    return item.key;
  }

  private _cloneSet(set: IReadonlySet<string>): Set<string> {
    const newSet = new Set<string>();
    set.forEach(key => newSet.add(key));
    return newSet;
  }

  private _onRenderTreeNode = (item: T, index: number, isScrolling: boolean) => {
    const {
      getItemIsCollapsible,
      getItemIsDisabled,
      getItemCommands,
      getItemHasCommands,
      getItemStyle,
      onRenderItemContainer,
      onRenderItemLabel,
      onRenderItemLabelContent,
      onRenderExpandIcon,
      onRenderContextualMenu,
      strings
    } = this.props;

    const customItemContainerRender = onRenderItemContainer ? this._onRenderItemContainer : undefined;
    const customItemLabelRender = onRenderItemLabel ? this._onRenderItemLabel : undefined;
    const customItemLabelContentRender = onRenderItemLabelContent
      ? this._onRenderItemLabelContent
      : undefined;
    const customExpandIconRender = onRenderExpandIcon ? this._onRenderExpandIcon : undefined;
    const customContextualMenuRender = onRenderContextualMenu ? this._onRenderContextualMenu : undefined;
    const customItemStyle = getItemStyle ? this._getItemStyle(item) : undefined;
    const isSelected = this.state.selectedItemKeys.has(item.key);
    const isSelectionDisabled = item.disableSelection;
    const isExpanded = this.state.expandedItemKeys.has(item.key);
    const isCollapsible = !getItemIsCollapsible || getItemIsCollapsible(item);

    let itemStyle: string = this._cachedStyles.item;

    if (!!isSelectionDisabled) {
      itemStyle = this._cachedStyles.unselectableItem;
    } else if (isSelected) {
      itemStyle = this._cachedStyles.selectedItem;
    }

    if (customItemStyle) {
      itemStyle = mergeStyles(itemStyle, customItemStyle);
    }

    return (
      <TreeNode
        itemKey={item.key}
        label={item.label}
        isFolder={item.isFolder}
        level={item.level}
        iconProps={item.iconProps}
        ariaLabel={item.ariaLabel}
        setSize={item.setSize}
        indexInParent={item.indexInParent}
        isSelectionDisabled={isSelectionDisabled}
        isDisabled={getItemIsDisabled && getItemIsDisabled(item)}
        isSelected={isSelected}
        isExpanded={isExpanded}
        isFocusable={!item.disableFocus}
        isCollapsible={isCollapsible}
        moreIcon={this.state.moreIcon}
        collapsedArrowIcon={this.state.collapsedArrowIcon}
        hasCommands={getItemCommands && (!getItemHasCommands || getItemHasCommands(item))}
        getCommands={this._getItemCommands}
        onRenderItemContainer={customItemContainerRender}
        onRenderItemLabel={customItemLabelRender}
        onRenderItemLabelContent={customItemLabelContentRender}
        onRenderExpandIcon={customExpandIconRender}
        onRenderContextualMenu={customContextualMenuRender}
        onSelected={this._onItemSelected}
        onExpandToggled={this._onExpandToggled}
        onDoubleClicked={this._onDoubleClicked}
        onItemKeyDown={this._onItemKeyDown}
        moreCommandsAriaLabel={item.moreCommandsAriaLabel || strings.moreCommandsAriaLabel}
        itemStyle={itemStyle}
        itemLabelStyle={this._classNames.itemLabel}
        indentSpacerStyle={this._classNames.levelIndentSpacer}
        menuButtonStyle={this._classNames.menuButton}
        menuButtonOpenStyle={
          isSelected
            ? this._classNames.menuButtonSelectedRowOpenMenu
            : this._classNames.menuButtonUnselectedRowOpenMenu
        }
        menuButtonClosedStyle={
          isSelected
            ? this._classNames.menuButtonSelectedRowClosedMenu
            : this._classNames.menuButtonUnselectedRowClosedMenu
        }
        menuButtonDisabledStyle={this._classNames.menuButtonDisabled}
        expandIconButtonStyle={
          isCollapsible ? this._cachedStyles.expandIconButton : this._cachedStyles.expandIconButtonDisabled
        }
        expandIconStyle={isExpanded ? this._cachedStyles.expandIconExpanded : this._classNames.expandIcon}
        noExpandIconStyle={this._classNames.noExpandIcon}
        itemIconContainerStyle={this._classNames.itemIconContainer}
        itemIconStyle={this._classNames.itemIcon}
        noItemIconStyle={this._classNames.noItemIcon}
      />
    );
  };

  private _getItemStyle = (item: T) => {
    const { getItemStyle } = this.props;

    if (getItemStyle) {
      const { selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;
      const index = keyToVisibleIndexMap.get(item.key);

      return getItemStyle(item, selectedItemKeys.has(item.key), expandedItemKeys.has(item.key), index);
    }

    return null;
  };

  private _getItemCommands = (itemKey: string): IContextualMenuItem[] => {
    const { getItemCommands } = this.props;
    const { keyToItemMap } = this.state;

    if (getItemCommands) {
      const item = keyToItemMap.get(itemKey);
      return getItemCommands(item);
    }

    return [];
  };

  private _onItemSelected = (itemKey: string, type: SelectionType) => {
    const { onItemSelected } = this.props;
    const { keyToItemMap, selectedItemKeys } = this.state;

    const item = keyToItemMap.get(itemKey);

    if (item.disableSelection) {
      return;
    }

    if (onItemSelected) {
      const { expandedItemKeys, keyToVisibleIndexMap } = this.state;
      const index = keyToVisibleIndexMap.get(itemKey);

      onItemSelected(item, type, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index);
    }

    // Check if selection is being treated as uncontrolled
    if (!this.props.selectedItemKeys) {
      let newSelectedItemKeys: Set<string>;

      if (type === SelectionType.Toggle) {
        newSelectedItemKeys = this._cloneSet(selectedItemKeys);

        if (selectedItemKeys.has(itemKey)) {
          newSelectedItemKeys.delete(itemKey);
        } else {
          newSelectedItemKeys.add(itemKey);
        }
      } else {
        // TODO: add proper support for SelectionType.Block.
        newSelectedItemKeys = new Set<string>();
        newSelectedItemKeys.add(itemKey);
      }

      this.setState({ selectedItemKeys: newSelectedItemKeys });
    }
  };

  private _onRenderItemContainer = (itemKey: string, defaultRender: () => JSX.Element) => {
    const { onRenderItemContainer } = this.props;
    const { keyToItemMap, selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;

    const item = keyToItemMap.get(itemKey);
    const index = keyToVisibleIndexMap.get(itemKey);

    return onRenderItemContainer(
      item,
      selectedItemKeys.has(itemKey),
      expandedItemKeys.has(itemKey),
      index,
      defaultRender
    );
  };

  private _onRenderItemLabel = (itemKey: string, defaultRender: () => JSX.Element) => {
    const { onRenderItemLabel } = this.props;
    const { keyToItemMap, selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;

    const item = keyToItemMap.get(itemKey);
    const index = keyToVisibleIndexMap.get(itemKey);

    return onRenderItemLabel(
      item,
      selectedItemKeys.has(itemKey),
      expandedItemKeys.has(itemKey),
      index,
      defaultRender
    );
  };

  private _onRenderItemLabelContent = (itemKey: string, defaultRender: () => JSX.Element) => {
    const { onRenderItemLabelContent } = this.props;
    const { keyToItemMap, selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;

    const item = keyToItemMap.get(itemKey);
    const index = keyToVisibleIndexMap.get(itemKey);

    return onRenderItemLabelContent(
      item,
      selectedItemKeys.has(itemKey),
      expandedItemKeys.has(itemKey),
      index,
      defaultRender
    );
  };

  private _onRenderExpandIcon = (itemKey: string, defaultRender: () => JSX.Element) => {
    const { onRenderExpandIcon } = this.props;
    const { keyToItemMap, selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;

    const item = keyToItemMap.get(itemKey);
    const index = keyToVisibleIndexMap.get(itemKey);

    return onRenderExpandIcon(
      item,
      selectedItemKeys.has(itemKey),
      expandedItemKeys.has(itemKey),
      index,
      defaultRender
    );
  };

  private _onRenderContextualMenu = (itemKey: string, menuProps: IContextualMenuProps) => {
    const { onRenderContextualMenu } = this.props;
    const { keyToItemMap, selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;

    const item = keyToItemMap.get(itemKey);
    const index = keyToVisibleIndexMap.get(itemKey);

    return onRenderContextualMenu(
      item,
      selectedItemKeys.has(itemKey),
      expandedItemKeys.has(itemKey),
      index,
      menuProps
    );
  };

  private _onItemKeyDown = (itemKey: string, event: React.KeyboardEvent<HTMLElement>) => {
    const { onItemKeyDown } = this.props;
    const { keyToItemMap } = this.state;

    const item = keyToItemMap.get(itemKey);

    if (onItemKeyDown) {
      const { selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;
      const index = keyToVisibleIndexMap.get(itemKey);

      return onItemKeyDown(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, event);
    }
  };

  private _onExpandToggled = (itemKey: string) => {
    const { onItemCollapse, onItemExpand } = this.props;
    const { keyToItemMap, keyToVisibleIndexMap, expandedItemKeys } = this.state;

    const item = keyToItemMap.get(itemKey);

    const isExpanded = expandedItemKeys.has(itemKey);
    const index = keyToVisibleIndexMap.get(itemKey);
    const callbackToUse = isExpanded ? onItemCollapse : onItemExpand;

    if (callbackToUse) {
      callbackToUse(item, index);
    }

    // Check if expansion is being treated as uncontrolled
    if (!this.props.expandedItemKeys) {
      const newExpandedItemKeys = this._cloneSet(expandedItemKeys);
      if (isExpanded) {
        newExpandedItemKeys.delete(itemKey);
      } else {
        newExpandedItemKeys.add(itemKey);
      }

      this.setState(prevState =>
        TreeBase._getStateFromProps(this.props, {
          ...prevState,
          expandedItemKeys: newExpandedItemKeys,
          areExpandedItemsDirty: true
        })
      );
    }
  };

  private _onDoubleClicked = (itemKey: string) => {
    const { onItemDoubleClicked } = this.props;
    const { keyToItemMap } = this.state;

    const item = keyToItemMap.get(itemKey);

    if (onItemDoubleClicked) {
      const { selectedItemKeys, expandedItemKeys, keyToVisibleIndexMap } = this.state;
      const index = keyToVisibleIndexMap.get(itemKey);

      onItemDoubleClicked(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index);
    }
  };

  private _saveListRef = (ref: List) => {
    this._list = ref;
    this._applyPendingScroll();
  };

  private _applyPendingScroll = (): void => {
    const index = this._getSelectedIndex();

    if (this._isPendingScrollToSelected && this._list && index) {
      this._list.scrollToIndex(index, () => this._getNodeHeight(this.props));
      this._isPendingScrollToSelected = false;
    }
  };

  /**
   * Gets the index of the first selected item
   */
  private _getSelectedIndex = (): number | undefined => {
    const { items } = this.props;
    return items && findIndex(items, item => this.state.selectedItemKeys.has(item.key));
  };

  // This method is necessary for List.scrollToIndex to behave correctly while loading.
  private _getPageHeight = (): number => {
    return defaultItemsPerPage * this._getNodeHeight(this.props);
  };

  private _getVisibleItems = (items: ITreeItem[]): ITreeItem[] => {
    this._visibleIndexByItem = {};
    let visibleIndex: number = 0;
    const visibleItems: ITreeItem[] = [];

    let lastCollapsedLevel = maxInt;

    items.forEach((item, index) => {
      if (item.level <= lastCollapsedLevel) {
        if (this.state.expandedItemKeys.has(item.key)) {
          lastCollapsedLevel = maxInt;
        } else {
          lastCollapsedLevel = item.level;
        }

        visibleItems.push(item);
        this._visibleIndexByItem[item.key] = visibleIndex++;
      }
    });

    return visibleItems;
  };

  private _getNodeHeight(props: ITreeProps<T>): number {
    const { nodeHeight } = props;
    return nodeHeight === undefined || nodeHeight === null ? defaultNodeHeight : nodeHeight;
  }

  private _getIconWidth(props: ITreeProps<T>): number {
    const { iconWidth } = props;
    return iconWidth === undefined || iconWidth === null ? defaultIconWidth : iconWidth;
  }

  private _getClassNames(props: ITreeProps<T>): { [key in keyof ITreeStyles]: string } {
    const { className, theme } = props;

    const classNames = getClassNames(props.styles!, {
      className: className,
      theme: theme!,
      nodeHeight: this._getNodeHeight(props),
      iconWidth: this._getIconWidth(props)
    });

    const unselectableItem = mergeStyles(
      classNames.item,
      classNames.itemIsNotSelected,
      classNames.itemIsNotSelectable
    );
    const item = mergeStyles(classNames.item, classNames.itemIsSelectable, classNames.itemIsNotSelected);
    const selectedItem = mergeStyles(classNames.item, classNames.itemIsSelectable, classNames.itemIsSelected);

    const expandIconExpanded = mergeStyles(classNames.expandIcon, classNames.expandIconExpanded);
    const expandIconButton = mergeStyles(classNames.expandIconButton, classNames.expandIconButtonEnabled);
    const expandIconButtonDisabled = mergeStyles(
      classNames.expandIconButton,
      classNames.expandIconButtonDisabled
    );

    this._cachedStyles = {
      unselectableItem,
      item: item,
      selectedItem: selectedItem,
      expandIconExpanded,
      expandIconButton,
      expandIconButtonDisabled
    };

    return classNames;
  }
}
