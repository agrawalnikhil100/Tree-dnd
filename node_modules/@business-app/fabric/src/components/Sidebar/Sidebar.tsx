/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { DefaultButton, IButtonProps, IButtonStyles } from '@fluentui/react/lib/Button';
import { DirectionalHint } from '@fluentui/react/lib/ContextualMenu';
import { FocusZone, FocusZoneDirection } from '@fluentui/react/lib/FocusZone';
import { ScrollablePane } from '@fluentui/react/lib/ScrollablePane';
import { concatStyleSets, getTheme, ITheme } from '@fluentui/react/lib/Styling';
import { BaseComponent, IComponentAs, KeyCodes } from '@fluentui/react/lib/Utilities';
import * as React from 'react';

import { getSidebarClassNames, ISidebarClassNames } from './Sidebar.classNames';
import { getButtonColoredStyles, getCollapsedButtonStyles, getSidebarStyles } from './Sidebar.styles';
import { ISidebar, ISidebarItemProps, ISidebarProps } from './Sidebar.types';
import { SidebarAccordion } from './SidebarAccordion';
import { SidebarButton } from './SidebarButton';
import { getSidebarChildrenStyles } from './SidebarButton.styles';

export interface ISidebarState {
  // whether the sidebar is currently collapsed or not.
  isCollapsed: boolean;
}

export class Sidebar extends BaseComponent<ISidebarProps, ISidebarState> implements ISidebar {
  private _theme: ITheme;
  private _classNames: ISidebarClassNames;
  private _buttonStyles: IButtonStyles;

  constructor(props: ISidebarProps) {
    super(props);

    this.state = {
      isCollapsed: props.collapsible && props.defaultIsCollapsed
    };
  }

  /*
   * ComponentDidMount is used in the sidebar to adjust the height of the sidebar content
   * to allow the content scrollbar to be correctly sized.
   */
  public componentDidMount() {
    this.updateSidebarContentHeight();
  }

  public render(): JSX.Element {
    const {
      theme,
      styles,
      buttonStyles,
      collapseButtonStyles,
      className,
      collapsible,
      collapseButtonAriaLabel,
      footerItems,
      id,
      items,
      renderCustomHeader
    } = this.props;

    this._theme = theme || getTheme();
    this._buttonStyles = getButtonColoredStyles(theme, buttonStyles);
    this._classNames = getSidebarClassNames(
      getSidebarStyles(theme, styles),
      className,
      this.state.isCollapsed,
      id
    );

    const ButtonAs = this._getButtonAs();

    return (
      <div className={this._classNames.root} aria-expanded={!this.state.isCollapsed}>
        <ScrollablePane
          className={this._classNames.content}
          styles={{
            contentContainer: {
              overflowX: 'hidden'
            }
          }}
        >
          {collapsible && (
            <ButtonAs
              key={'baSidebarCollapsibleButton'}
              iconProps={{ iconName: 'GlobalNavButton' }}
              onClick={this.toggleCollapsed}
              ariaLabel={collapseButtonAriaLabel}
              theme={this._theme}
              aria-expanded={!this.state.isCollapsed}
              styles={concatStyleSets(this._buttonStyles, collapseButtonStyles, {
                root: { width: 'auto' },
                icon: { margin: 'auto' }
              })}
              onRenderIcon={this.props.onRenderCollapseButtonIcon}
              data-telemetry-id={this.props.telemetryId}
            />
          )}
          <FocusZone direction={FocusZoneDirection.vertical}>
            {renderCustomHeader && <>{renderCustomHeader(this.state.isCollapsed)}</>}
            <nav role="menu">
              {items && items.map((item: ISidebarItemProps) => this._renderItemInSidebar(item))}
            </nav>
          </FocusZone>
        </ScrollablePane>
        {footerItems && (
          <FocusZone
            direction={FocusZoneDirection.vertical}
            className={this._classNames.footer}
            key={`baSidebarFooter${id}`}
          >
            <nav role="menu">
              {footerItems.map((item: ISidebarItemProps) => this._renderItemInSidebar(item))}
            </nav>
          </FocusZone>
        )}
      </div>
    );
  }

  public toggleCollapsed = (): void => {
    this.setState((prevState: ISidebarState) => {
      return { isCollapsed: !prevState.isCollapsed };
    });

    if (this.props.onCollapseChanged) {
      this.props.onCollapseChanged();
    }
  };

  public setCollapsed(newValue: boolean): void {
    if (this.state.isCollapsed === newValue) {
      return;
    }

    this.setState({ isCollapsed: newValue });

    if (this.props.onCollapseChanged) {
      this.props.onCollapseChanged();
    }
  }

  public getCollapsed(): boolean {
    return this.state.isCollapsed;
  }

  private updateSidebarContentHeight = (): void => {
    const parentId = this.props.id ? this.props.id : '';
    const sidebar = document.getElementsByClassName(`ba-Sidebar-${parentId}`)[0] as HTMLElement;
    const sidebarFooter = document.getElementsByClassName(`ba-SidebarFooter-${parentId}`)[0] as HTMLElement;
    const sidebarContent = document.getElementsByClassName(`ba-SidebarContent-${parentId}`)[0] as HTMLElement;

    if (sidebarContent && sidebar && sidebarFooter) {
      sidebarContent.setAttribute(
        'style',
        'height: ' + (sidebar.offsetHeight - sidebarFooter.offsetHeight + 'px')
      );
    }
  };

  private _renderItemInSidebar(item: ISidebarItemProps): JSX.Element {
    if (!item) {
      return null;
    }

    if (item.onRender) {
      return item.onRender(item, null) as JSX.Element;
    }

    if (item.items && item.items.length > 0) {
      return this._renderSidebarItemWithChildren(item);
    }

    return this._renderSidebarButton(item);
  }

  private _renderSidebarButton(
    item: ISidebarItemProps,
    overrideCollapse: boolean = false,
    dismissMenu?: () => void
  ): JSX.Element {
    if (!item) {
      return null;
    }

    const ButtonAs = this._getButtonAs(item);
    const {
      active,
      disabled,
      href,
      iconProps,
      styles,
      subMenuIconProps,
      target,
      title,
      name,
      telemetryId
    } = item;

    return (
      <div key={item.key}>
        <ButtonAs
          aria-current={active ? 'page' : undefined}
          ariaLabel={name}
          checked={active}
          className={this._getClassNames('ba-SidebarButton', item)}
          disabled={disabled}
          href={href}
          iconProps={iconProps ? iconProps : { iconName: '' }}
          menuIconProps={this.state.isCollapsed ? null : subMenuIconProps}
          onClick={this._onItemClick(item, dismissMenu)}
          role={'menuitem'}
          styles={concatStyleSets(this._buttonStyles, styles)}
          target={target}
          text={this.state.isCollapsed && !overrideCollapse ? null : item.name}
          theme={this._theme}
          title={title ? title : name}
          data-telemetry-id={telemetryId}
          id={item.id}
        />
      </div>
    );
  }

  private _renderSidebarItemWithChildren(item: ISidebarItemProps): JSX.Element {
    if (!item || !item.items) {
      return null;
    }

    const numActiveChildren = item.items.filter((child: ISidebarItemProps) => {
      return child.active;
    }).length;

    if (!this.state.isCollapsed && item.items) {
      return this._renderSidebarAccordion(item, numActiveChildren);
    }

    return this._renderSidebarButtonWithMenu(item, numActiveChildren);
  }

  private _renderSidebarAccordion(item: ISidebarItemProps, numActiveChildren: number): JSX.Element {
    if (!item || !item.items) {
      return null;
    }

    return (
      <div className={this._getClassNames('ba-SidebarAccordion', item)} key={item.key}>
        <SidebarAccordion
          checked={numActiveChildren > 0 ? true : false}
          text={item.name}
          iconProps={item.iconProps}
          menuIconProps={item.subMenuIconProps}
          role={'menuitem'}
          ariaLabel={item.name}
          title={item.tooltip || item.title}
          styles={item.styles}
          theme={this._theme}
          aria-current={numActiveChildren > 0 ? true : false}
          buttonAs={DefaultButton}
          onRenderContent={() => this._renderAccordionItems(item.items)}
          onOpen={this.updateSidebarContentHeight}
          onClose={this.updateSidebarContentHeight}
          data-telemetry-id={item.telemetryId}
        />
      </div>
    );
  }

  private _renderAccordionItems(items: ISidebarItemProps[]): JSX.Element {
    if (!items) {
      return null;
    }

    const children = items.map((item: ISidebarItemProps) => {
      const iconStyles =
        item.iconProps && item.iconProps.iconName
          ? null
          : {
              icon: {
                width: '0',
                margin: '0'
              }
            };

      const style = item.styles;
      item.styles = concatStyleSets(getSidebarChildrenStyles(this._theme, item.styles)!, iconStyles);
      const button = this._renderSidebarButton(item);
      item.styles = style;
      return button;
    });

    return <div role="menu">{children}</div>;
  }

  private _renderSidebarButtonWithMenu(item: ISidebarItemProps, numActiveChildren: number): JSX.Element {
    if (!item || !item.items) {
      return null;
    }

    const children = item.items.map((child: ISidebarItemProps) => {
      child.onRender = this._renderSidebarButtonMenuItem;
      return child;
    });

    if (item.name) {
      children.unshift({
        key: item.name + '-header',
        name: item.name,
        iconProps: { iconName: '' },
        className: 'ba-SidebarContextualMenuButton-header ',
        disabled: true,
        styles: concatStyleSets(this._buttonStyles, {
          rootDisabled: {
            backgroundColor: this._theme.palette.white
          },
          labelDisabled: {
            color: this._theme.palette.neutralPrimary
          }
        }),
        onRender: this._renderSidebarButtonMenuItem
      });
    }

    const ButtonAs = this._getButtonAs(item);

    return (
      <div key={item.key}>
        <ButtonAs
          key={item.key}
          text={this.state.isCollapsed ? '' : item.name}
          iconProps={item.iconProps}
          menuIconProps={this.state.isCollapsed ? { iconName: '' } : item.subMenuIconProps}
          menuProps={{
            items: children,
            directionalHint: DirectionalHint.rightTopEdge,
            ariaLabel: item.name,
            calloutProps: {
              styles: {
                root: {
                  borderWidth: '0'
                }
              }
            }
          }}
          menuTriggerKeyCode={KeyCodes.right}
          className={this._getClassNames('ba-SidebarContextualMenuButton', item)}
          role="menuitem"
          ariaLabel={item.name}
          title={item.title ? item.title : item.name}
          styles={concatStyleSets(this._buttonStyles, item.styles, getCollapsedButtonStyles(this._theme))}
          theme={this._theme}
          checked={numActiveChildren > 0 ? true : false}
          aria-current={numActiveChildren > 0 ? true : false}
          disabled={item.disabled}
          onClick={this._onItemClick(item)}
        />
      </div>
    );
  }

  private _onItemClick(
    item: ISidebarItemProps,
    dismissMenu?: () => void
  ): (ev: React.MouseEvent<HTMLButtonElement | HTMLAnchorElement>) => void {
    if (!item) {
      return null;
    }

    return (ev: React.MouseEvent<HTMLButtonElement>): void => {
      if (item.active && !this.props.redirectIfActive) {
        return;
      }

      if (item.onClick) {
        item.onClick(ev, item);
      }

      // Handle `defaultPrevented` the same way as in Fluent UI:
      // https://github.com/microsoft/fluentui/blob/aa142e7c4b64e62db238e727a86b5f2a774a229a/packages/office-ui-fabric-react/src/components/Button/BaseButton.tsx#L539
      if (dismissMenu && !ev.defaultPrevented) {
        dismissMenu();
      }
    };
  }

  private _getButtonAs(item?: ISidebarItemProps): IComponentAs<IButtonProps> {
    if (item && item.buttonAs) {
      return item.buttonAs;
    } else if (this.props.defaultButton) {
      return this.props.defaultButton;
    }

    return SidebarButton;
  }

  private _getClassNames(defaultClass: string, item: ISidebarItemProps): string {
    let className = defaultClass + ' ';
    className += item.className ? item.className : '';
    return className;
  }

  private _renderSidebarButtonMenuItem = (item: ISidebarItemProps, dismissMenu: () => void): JSX.Element => {
    const iconStyles =
      item.iconProps && item.iconProps.iconName
        ? null
        : {
            icon: {
              width: '0',
              marginRight: '0'
            }
          };

    return this._renderSidebarButton(
      {
        ...item,
        styles: concatStyleSets(
          item.styles,
          { root: { backgroundColor: this._theme.palette.white } },
          iconStyles
        )
      },
      true,
      dismissMenu
    );
  };
}
