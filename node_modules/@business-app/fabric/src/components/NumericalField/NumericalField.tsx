/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
/* eslint-disable max-classes-per-file */

import { TextField } from '@fluentui/react/lib/TextField';
import { css } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { INumericalFieldProps } from './NumericalField.types';

const stripCommas = /,/g;
const stripEndingPeriod = /\.$/g;

export interface INumericalFieldState {
  /**
   * The current string form of the contents of the numerical field.
   */
  stringValue: string;

  /**
   * The current formatted string form of the contents of the numerical field.
   */
  formattedValue: string;

  /**
   * The last string value of the text field that could successfully be parsed as numerical.
   */
  lastValidValue: string;

  /**
   * The previously received value passed on props.
   */
  prevPropValue: number;
}
/**
 * An abstract textfield control that performs numerical validation on its contents,
 * resetting back to the last known valid value on invalid input.
 */
export abstract class NumericalField<
  Props extends INumericalFieldProps = INumericalFieldProps
> extends React.Component<Props, INumericalFieldState> {
  private static readonly defaultFormatter: Intl.NumberFormat = new Intl.NumberFormat(undefined, {
    maximumFractionDigits: 20
  });

  /**
   * Returns whether a string can be parsed as a valid value for this field.
   * This is meant to decide what type of "numerical" field the implementation supports.
   * @param stringValue The string value of the textfield to validate
   */
  protected abstract isValid(stringValue: string): boolean;

  constructor(props: Props) {
    super(props);

    this.state = NumericalField.makeStateFromProps(props);
  }

  public static getDerivedStateFromProps(nextProps: INumericalFieldProps, prevState: INumericalFieldState) {
    if (nextProps.value !== prevState.prevPropValue && nextProps.value !== Number(prevState.lastValidValue)) {
      return NumericalField.makeStateFromProps(nextProps);
    }
    return null;
  }

  public render(): JSX.Element {
    const { textFieldProps, formatValue } = this.props;

    const { stringValue, formattedValue } = this.state;

    return (
      <TextField
        {...textFieldProps}
        className={css('ba-NumericalField', textFieldProps && textFieldProps.className)}
        value={formatValue === false ? stringValue : formattedValue}
        onChange={this.applyInput}
        onBlur={this.onBlur}
      />
    );
  }

  private static makeStateFromProps = (props: INumericalFieldProps): INumericalFieldState => {
    return {
      stringValue: props.value !== undefined ? String(props.value) : '',
      formattedValue:
        props.value !== undefined ? NumericalField.formatAsNumericalString(String(props.value)) : '',
      lastValidValue: props.value !== undefined ? String(props.value) : '',
      prevPropValue: props.value
    };
  };

  private static formatAsNumericalString = (value: string): string => {
    try {
      const asNumber = Number(value);
      return isNaN(asNumber) ? value : NumericalField.defaultFormatter.format(asNumber);
    } catch (err) {
      // an error while formatting should never crash the control
      return value;
    }
  };

  private applyInput = (
    _: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,
    originalValue: string
  ): void => {
    // Strips all commas out of input
    let preparedValue = originalValue.replace(stripCommas, '');
    // Trim all bordering whitespace
    preparedValue = preparedValue.trim();

    if (!preparedValue || this.isValid(preparedValue)) {
      this.setState({
        formattedValue: originalValue,
        stringValue: preparedValue,
        lastValidValue: preparedValue,
        prevPropValue: this.props.value
      });
    } else {
      this.setState({
        formattedValue: originalValue,
        stringValue: preparedValue,
        prevPropValue: this.props.value
      });
    }
  };

  private onBlur = (): void => {
    const { lastValidValue } = this.state;

    const lastValidNumericalValue = lastValidValue ? Number(lastValidValue) : undefined;
    if (lastValidNumericalValue !== this.props.value && this.props.onBlurred) {
      this.props.onBlurred(lastValidNumericalValue);
    }

    // JS accepts numbers ending with periods
    // but we don't
    const stringValue = lastValidValue.replace(stripEndingPeriod, '');

    // correct the input to the last known correct value
    // or blank if the field was emptied
    this.setState({
      stringValue: stringValue || '',
      formattedValue:
        lastValidNumericalValue !== undefined ? NumericalField.formatAsNumericalString(stringValue) : ''
    });
  };
}

/** An editable textfield control that only accepts whole integers. */
export class IntegerField extends NumericalField {
  protected isValid(stringValue: string): boolean {
    return isInteger(Number(stringValue));
  }
}

/** An editable textfield control that only accepts positive integers or zero. */
export class NaturalNumberField extends NumericalField {
  protected isValid(stringValue: string): boolean {
    return isInteger(Number(stringValue)) && Number(stringValue) >= 0;
  }
}

// This is a shim for `Number.isInteger`, as it is not available in all browsers (IE11)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isInteger(value: any): value is number {
  if (typeof value !== 'number') {
    return false;
  }

  if (!isFinite(value) || Math.floor(value) !== value) {
    return false;
  }

  return true;
}
