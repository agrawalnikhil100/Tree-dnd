/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { mergeStyles } from '@fluentui/style-utilities';
import { classNamesFunction } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { getAccessibilityHighlightStyles } from './HighlightedText.styles';
import {
  IHighlightedTextProps,
  IHighlightedTextStyleProps,
  IHighlightedTextStyles
} from './HighlightedText.types';

const getClassNames = classNamesFunction<IHighlightedTextStyleProps, IHighlightedTextStyles>();

/**
 * List of strings in order, broken up by their being highlighted or not
 * e.g. [{ str: "Hello", isHighlighted: false }, { str: "there, world!", isHighlighted: true }]
 */
type AnnotatedStrings = Array<{ str: string; isHighlighted: boolean }>;

/** Component that allows for displaying text with portions of the text highlighted. */
export class HighlightedTextBase extends React.PureComponent<IHighlightedTextProps> {
  private get classNames() {
    const { styles, theme } = this.props;
    return getClassNames(styles, { theme: theme! });
  }

  public render() {
    return <>{this.mapTextToHighlights()}</>;
  }

  private mapTextToHighlights(): JSX.Element {
    const { text, highlights, labels } = this.props;
    if (highlights.length === 0) {
      return <>{text}</>;
    }

    const strings = this.toStrings(text, highlights);

    return <>{this.renderStrings(strings, labels)}</>;
  }

  private renderStrings(strings: AnnotatedStrings, labels: IHighlightedTextProps['labels']): JSX.Element[] {
    const highlightedClassName = mergeStyles(
      this.classNames.highlights,
      getAccessibilityHighlightStyles(labels)
    );
    return strings.map(strObj => {
      if (strObj.isHighlighted) {
        return (
          <>
            <span className={highlightedClassName}>{strObj.str}</span>
          </>
        );
      } else {
        return <>{strObj.str}</>;
      }
    });
  }

  private toStrings(text: string, highlights: IHighlightedTextProps['highlights']): AnnotatedStrings {
    // start by sorting all highlights according to their effective start index, with length as tie-breaker
    const sortedHighlights = [...highlights].sort((a, b) => {
      const aStart = Math.min(a.startIndex, a.startIndex + a.length);
      const bStart = Math.min(b.startIndex, b.startIndex + b.length);
      const indexDifference = aStart - bStart;
      if (indexDifference === 0) {
        return a.length - b.length;
      }
      return indexDifference;
    });

    // end result - will contain a series of highlighted and non-highlighted strings in sequence
    const strings: AnnotatedStrings = [];

    let justHighlighted: boolean | undefined;
    let currentHighlightIndex = 0;
    let currentHighlight = sortedHighlights[0];

    for (let i = 0; i < text.length; i++) {
      // handle negative indexing
      let effectiveStart = currentHighlight
        ? Math.min(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
        : undefined;
      let effectiveEnd = currentHighlight
        ? Math.max(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
        : undefined;

      // if the current highlight ends before the current character, find the next highlight that could apply
      while (currentHighlight && i >= effectiveEnd) {
        currentHighlightIndex++;
        currentHighlight = sortedHighlights[currentHighlightIndex];
        // handle negative indexing again
        effectiveStart = currentHighlight
          ? Math.min(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
          : undefined;
        effectiveEnd = currentHighlight
          ? Math.max(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
          : undefined;
      }

      let highlighted = false;
      if (currentHighlight) {
        // now that we have a highlight that could apply, check if our character is between start and start + length
        highlighted = i >= effectiveStart && i < effectiveEnd;
      }

      const currentCharacter = text[i];
      if (highlighted !== justHighlighted) {
        // add a new entry to the result if we have changed highlight parity
        strings.push({
          str: currentCharacter,
          isHighlighted: highlighted
        });
      } else {
        // otherwise, if the latest result entry is our same parity, simply append our character
        const recentStringObject = strings[strings.length - 1];
        strings[strings.length - 1] = {
          str: recentStringObject.str + currentCharacter,
          isHighlighted: recentStringObject.isHighlighted
        };
      }

      justHighlighted = highlighted;
    }

    return strings;
  }
}
