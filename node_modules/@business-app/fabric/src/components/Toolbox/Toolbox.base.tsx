/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { BaseButton, Button, CommandButton, IButton } from '@fluentui/react/lib/Button';
import { FocusZone, FocusZoneDirection, IFocusZoneProps } from '@fluentui/react/lib/FocusZone';
import { Icon } from '@fluentui/react/lib/Icon';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import {
  BaseComponent,
  classNamesFunction,
  customizable,
  divProperties,
  getId,
  getNativeProps,
  IComponentAs,
  KeyCodes
} from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { ToolboxAutomationSelectors } from './Toolbox.selectors';
import { IToolboxProps, IToolboxStyleProps, IToolboxStyles } from './Toolbox.types';
import { ToolboxItem } from './ToolboxItem';
import { IToolboxItemProps } from './ToolboxItem.types';
import { Resizer, ResizerLocation } from './../Resizer';

const getClassNames = classNamesFunction<IToolboxStyleProps, IToolboxStyles>();
const DefaultWidth = 280;

/**
 *  Usage:
 *
 *   <Toolbox>
 *     <ToolboxItem headerText="Foo">
 *       <Label>Toolbox> #1</Label>
 *     </ToolboxItem>
 *     <ToolboxItem headerText="Bar">
 *       <Label>Toolbox> #2</Label>
 *     </ToolboxItem>
 *     <ToolboxItem headerText="Bas">
 *       <Label>Toolbox> #3</Label>
 *     </ToolboxItem>
 *   </Toolbox>
 */

export interface IToolboxState {
  links: IToolboxItemProps[];
  linksAreExpanded: boolean;
  drawerIsExpanded: boolean;
  selectedKey: string | null;
  width: number;
  keyToIndexMapping: { [key: string]: number };
  keyToTabIds: { [key: string]: string };
  keyToRef: { [key: string]: React.RefObject<IButton> };
  pivotId: string;
}

/**
 * Determines if the provided item is a ToolboxItem
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isToolBoxItem(item: any): item is ToolboxItem {
  return !!item && typeof item === 'object' && item.type === ToolboxItemType;
}

const ToolboxItemType = React.createElement(ToolboxItem).type;

@customizable('Toolbox', ['theme', 'styles'])
export class ToolboxBase extends BaseComponent<IToolboxProps, IToolboxState> {
  private _focusZone = React.createRef<FocusZone>();
  private _classNames: { [key in keyof IToolboxStyles]?: string } = {};

  public static _getStateFromProps(nextProps: IToolboxProps, prevState: IToolboxState): IToolboxState {
    const newState = prevState;
    newState.links = ToolboxBase._getToolboxLinks(nextProps, newState);

    if (
      nextProps.selectedKey !== undefined &&
      nextProps.selectedKey !== null &&
      ToolboxBase._isKeyValid(nextProps.selectedKey, newState)
    ) {
      // Use the selectedKey prop if it is provided/valid.
      newState.selectedKey = nextProps.selectedKey;
      newState.drawerIsExpanded = true;
    } else if (nextProps.selectedKey === null || !ToolboxBase._isKeyValid(newState.selectedKey, newState)) {
      // Close the drawer if requested or if the previous state is no longer valid.
      newState.selectedKey = null;
      newState.drawerIsExpanded = false;
    }

    if (nextProps.expandLinks !== undefined && nextProps.expandLinks !== null) {
      newState.linksAreExpanded = nextProps.expandLinks;
    }

    return newState;
  }

  /**
   * Gets the set of ToolboxLinks as array of ToolboxItemProps
   * The set of Links is determined by child components of type ToolboxItem
   */
  private static _getToolboxLinks(props: IToolboxProps, state: IToolboxState): IToolboxItemProps[] {
    const links: IToolboxItemProps[] = [];

    // Reset the mappings
    state.keyToIndexMapping = {};
    state.keyToTabIds = {};
    state.keyToRef = {};

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    React.Children.map(props.children, (child: ToolboxItem | any) => {
      if (isToolBoxItem(child)) {
        const newItemIndex = links.length;
        const pivotItem = child;
        const itemKey = pivotItem.props.itemKey || newItemIndex.toString();

        links.push({
          className: pivotItem.props.className,
          headerText: pivotItem.props.headerText,
          headerButtonProps: pivotItem.props.headerButtonProps,
          ariaLabel: pivotItem.props.ariaLabel,
          itemKey,
          itemIcon: pivotItem.props.itemIcon,
          onRenderItemLink: pivotItem.props.onRenderItemLink,
          keytipProps: pivotItem.props.keytipProps,
          disabled: pivotItem.props.disabled
        });
        state.keyToIndexMapping[itemKey] = newItemIndex;
        state.keyToTabIds[itemKey] = this._getTabId(newItemIndex, state);
        state.keyToRef[itemKey] = React.createRef<IButton>();
      }
    });

    return links;
  }

  /**
   * Generates the Id for the tab button.
   */
  private static _getTabId(index: number, state: IToolboxState): string {
    return state.pivotId + `-Tab${index}`;
  }

  /**
   * whether the key exists in the pivot items.
   */
  private static _isKeyValid(itemKey: string | undefined, state: IToolboxState): boolean {
    return itemKey !== undefined && state.keyToIndexMapping[itemKey] !== undefined;
  }

  public constructor(props: IToolboxProps) {
    super(props);

    const initialKeyPropProvided = props.initialSelectedKey !== undefined;
    this.state = ToolboxBase._getStateFromProps(props, {
      links: [],
      selectedKey: initialKeyPropProvided ? props.initialSelectedKey : null,
      linksAreExpanded: !!props.expandLinksInitially,
      drawerIsExpanded: initialKeyPropProvided,
      keyToIndexMapping: {},
      keyToTabIds: {},
      keyToRef: {},
      pivotId: getId('Toolbox'),
      width: DefaultWidth
    });
  }

  public static getDerivedStateFromProps(nextProps: IToolboxProps, prevState: IToolboxState) {
    if (!prevState) {
      return null;
    }
    return ToolboxBase._getStateFromProps(nextProps, prevState);
  }

  public render(): JSX.Element {
    const divProps = getNativeProps(this.props, divProperties);
    this._classNames = this._getClassNames(this.props);

    return (
      <div className={this._classNames.root} {...divProps}>
        {this._renderToolboxLinks()}
        {this._renderToolboxDrawer()}
      </div>
    );
  }

  /**
   * Sets focus to the first pivot tab.
   */
  public focus(): void {
    this._focusZone.current?.focus();
  }

  /**
   * Renders the set of links to route between drawers
   */
  private _renderToolboxLinks = (): JSX.Element => {
    const items = this.state.links.map(this._renderToolboxLink);
    const { linksAreExpanded } = this.state;
    const { strings } = this.props;
    const collapseButtonTitle =
      strings.expandCollapseTooltip ?? (linksAreExpanded ? strings.collapseTooltip : strings.expandTooltip);

    const ToolboxLinksContainer = this._toolboxLinksContainer();

    return (
      <ToolboxLinksContainer
        componentRef={this._focusZone}
        direction={FocusZoneDirection.vertical}
        className={this._classNames.focusZone}
      >
        <ul className={this._classNames.list} role="tablist">
          <CommandButton
            className={mergeStyles(
              ToolboxAutomationSelectors.expandCollapseLinksClassName,
              this._classNames.item
            )}
            onClick={this._onCollapseButtonClick}
            onKeyPress={this._onCollapseButtonKeyPress}
            aria-expanded={linksAreExpanded}
            name={collapseButtonTitle}
            title={collapseButtonTitle}
            ariaLabel={collapseButtonTitle}
          >
            {this._renderLinkContent({ itemIcon: 'GlobalNavButton', itemKey: 'collapseButton' })}
          </CommandButton>
          {items}
        </ul>
      </ToolboxLinksContainer>
    );
  };

  private _toolboxLinksContainer = () => {
    let Container: IComponentAs<IFocusZoneProps> = FocusZone;

    if (this.props.toolboxLinksContainerAs) {
      Container = this.props.toolboxLinksContainerAs;
    }

    return Container;
  };

  private _renderToolboxLink = (link: IToolboxItemProps): JSX.Element => {
    const { itemKey, headerButtonProps } = link;
    const tabId = this.state.keyToTabIds[itemKey];
    const { onRenderItemLink } = link;
    let linkContent: JSX.Element | null;
    const isSelected: boolean =
      this.state.selectedKey === itemKey && this.state.drawerIsExpanded && !link.disabled;

    if (onRenderItemLink) {
      linkContent = onRenderItemLink(link, this._renderLinkContent);
    } else {
      linkContent = this._renderLinkContent(link);
    }

    const linkStyles = mergeStyles(
      ToolboxAutomationSelectors.toolTabClassName,
      isSelected ? this._classNames.itemIsSelected : this._classNames.item,
      link.className
    );

    return (
      <CommandButton
        {...headerButtonProps}
        componentRef={this.state.keyToRef[itemKey] || undefined}
        id={tabId}
        key={itemKey}
        className={linkStyles}
        onClick={!link.disabled && this._onLinkClick.bind(this, itemKey)}
        onKeyPress={!link.disabled && this._onKeyPress.bind(this, itemKey)}
        ariaLabel={link.ariaLabel}
        role="tab"
        aria-selected={this.state.selectedKey === itemKey}
        name={link.headerText}
        title={link.headerText}
        keytipProps={link.keytipProps}
        disabled={link.disabled}
      >
        {isSelected && this._renderSelectionIndicator()}
        {linkContent}
      </CommandButton>
    );
  };

  private _renderLinkContent = (link?: IToolboxItemProps): JSX.Element => {
    if (!link) {
      return <></>;
    }

    const { itemIcon, headerText } = link;
    const { linksAreExpanded } = this.state;

    return (
      <span className={this._classNames.itemContent} aria-hidden={true}>
        {itemIcon !== undefined && (
          <span className={this._classNames.iconContainer}>
            <Icon iconName={itemIcon} className={this._classNames.icon} />
          </span>
        )}
        {headerText !== undefined && !!linksAreExpanded && (
          <span className={this._classNames.text}> {headerText}</span>
        )}
      </span>
    );
  };

  private _renderSelectionIndicator = () => {
    return <div role="presentation" className={this._classNames.selectionIndicator} />;
  };

  private _onCollapseButtonClick = (ev: React.MouseEvent<HTMLButtonElement>) => {
    ev.preventDefault();
    this._toggleCollapsed();
  };

  private _onCollapseButtonKeyPress = (ev: React.KeyboardEvent<HTMLButtonElement>): void => {
    if (ev.which === KeyCodes.enter) {
      ev.preventDefault();
      this._toggleCollapsed();
    }
  };

  private _toggleCollapsed() {
    // Only manage link expansion state when the component is being used as an uncontrolled component
    if (this.props.expandLinks === undefined) {
      this.setState(state => {
        const expandLinks = !state.linksAreExpanded;

        // When we are managing the expansion state, we need to call this callback
        // from within setState to ensure it has the correct state value when called.
        this._onToggleExpandLinks(expandLinks);

        return { linksAreExpanded: expandLinks };
      });
    } else {
      this._onToggleExpandLinks(!this.state.linksAreExpanded);
    }
  }

  private _onToggleExpandLinks = (expand: boolean) => {
    this.props.onToggleExpandLinks?.(expand);
  };

  /**
   * Renders the current Toolbox Item
   */
  private _renderToolboxDrawer = (): JSX.Element | null => {
    const { selectedKey, links } = this.state;

    const index = this.state.keyToIndexMapping[selectedKey];
    const selectedLink = links[index];
    if (selectedLink && selectedLink.disabled) {
      return <></>;
    }

    const selectedTabId = this.state.keyToTabIds[selectedKey];
    const selectedChild = React.Children.toArray(this.props.children)[index];
    const closeTitle = this.props.strings.closeTooltip;

    return (
      <div
        role="tabpanel"
        aria-labelledby={selectedTabId}
        className={this._classNames.drawer}
        style={{ width: this.state.width }}
      >
        <React.Fragment>
          <div className={this._classNames.drawerHeaderRegion}>
            <h2 className={this._classNames.drawerHeader}>{selectedLink ? selectedLink.headerText : null}</h2>
            <CommandButton
              className={mergeStyles(
                ToolboxAutomationSelectors.closeDrawerClassName,
                this._classNames.drawerClose
              )}
              onClick={this._dismissDrawer}
              title={closeTitle}
            >
              <Icon className={this._classNames.drawerCloseIcon} iconName="Cancel" />
            </CommandButton>
          </div>
          {selectedChild}
        </React.Fragment>
        {this.props.isResizable && (
          <Resizer
            size={this.state.width}
            onSizeChanged={(newSize: number) => this.setState({ width: newSize })}
            location={ResizerLocation.Right}
          />
        )}
      </div>
    );
  };

  /**
   * Handles the onClick event on ToolboxLinks
   */
  private _onLinkClick(
    itemKey: string,
    ev: React.MouseEvent<HTMLAnchorElement | HTMLButtonElement | HTMLDivElement | BaseButton | Button>
  ): void {
    ev.preventDefault();
    this._updateSelectedItem(itemKey);
  }

  /**
   * Handle the onKeyPress event on the ToolboxLinks
   */
  private _onKeyPress(
    itemKey: string,
    ev: React.KeyboardEvent<HTMLAnchorElement | HTMLButtonElement | HTMLDivElement | BaseButton | Button>
  ): void {
    if (ev.which === KeyCodes.enter) {
      ev.preventDefault();
      this._updateSelectedItem(itemKey);
    }
  }

  /**
   * Updates the state with the new selected index
   */
  private _updateSelectedItem(itemKey: string): void {
    const { selectedKey, drawerIsExpanded } = this.state;

    if (selectedKey === itemKey && drawerIsExpanded) {
      this._clearSelectedItem();
    } else {
      // Only manage selected key state when the component is being used as an uncontrolled component
      if (this.props.selectedKey === undefined) {
        this.setState({
          selectedKey: itemKey,
          drawerIsExpanded: true
        });
      }

      if (ToolboxBase._isKeyValid(itemKey, this.state)) {
        this.props.onSelectedItemChanged?.(itemKey, false);
      }
    }
  }

  private _dismissDrawer = () => {
    this._focusCurrentLink();
    this._clearSelectedItem(true);
  };

  /** Focus the tab button for the currently selected link. */
  private _focusCurrentLink = (): void => {
    const selectedKey = this.state.selectedKey;

    if (selectedKey !== null && selectedKey !== undefined) {
      const currentTabRef = this.state.keyToRef[selectedKey];

      currentTabRef?.current?.focus();
    }
  };

  private _clearSelectedItem = (clearedViaDismissButton: boolean = false) => {
    // Only manage selected key state when the component is being used as an uncontrolled component
    if (this.props.selectedKey === undefined) {
      this.setState({
        selectedKey: null,
        drawerIsExpanded: false
      });
    }

    const { onSelectedItemChanged } = this.props;

    onSelectedItemChanged?.(null, clearedViaDismissButton);
  };

  private _getClassNames(props: IToolboxProps): { [key in keyof IToolboxStyles]: string } {
    const { theme } = props;
    const { linksAreExpanded, drawerIsExpanded } = this.state;

    return getClassNames(props.styles!, {
      theme: theme!,
      linksAreExpanded,
      drawerIsExpanded
    });
  }
}
