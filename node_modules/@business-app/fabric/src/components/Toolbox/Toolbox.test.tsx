/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { mount, ReactWrapper } from 'enzyme';
import { CommandButton, IBaseButtonProps } from '@fluentui/react/lib/Button';
import { FocusZone, IFocusZoneProps } from '@fluentui/react/lib/FocusZone';
import { setIconOptions } from '@fluentui/react/lib/Styling';
import { KeyCodes } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { Toolbox } from './Toolbox';
import { IToolboxState, ToolboxBase } from './Toolbox.base';
import { ToolboxAutomationSelectors } from './Toolbox.selectors';
import { IToolboxProps, ToolboxStrings } from './Toolbox.types';
import { ToolboxItem } from './ToolboxItem';
import { Resizer } from './../Resizer';

// Suppress icon warnings. https://github.com/OfficeDev/office-ui-fabric-react/wiki/Using-icons
setIconOptions({ disableWarnings: true });

const strings: ToolboxStrings = {
  closeTooltip: 'close',
  expandCollapseTooltip: 'show or hide menu items'
};

type ToolboxWrapper = ReactWrapper<IToolboxProps, IToolboxState>;

function getState(wrapper: ToolboxWrapper): IToolboxState {
  return (wrapper.childAt(0).instance() as React.Component<IToolboxProps, IToolboxState>).state;
}

describe('Toolbox', () => {
  it('onSelectedItemChanged called with null on clicking the close icon', () => {
    const onSelectedItemChanged = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox onSelectedItemChanged={onSelectedItemChanged} selectedKey="key" strings={strings}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </Toolbox>
    );

    // find the close button
    const closeButton = wrapper
      .find<IBaseButtonProps>(CommandButton)
      .filterWhere(x => x.props().title === strings.closeTooltip);

    expect(closeButton.props().onClick).toBeDefined();
    closeButton.props().onClick!({} as never);
    expect(onSelectedItemChanged).toBeCalledWith(null, true);

    wrapper.unmount();
  });

  it('onSelectedItemChanged called with correct parameters on clicking Toolbox Item (controlled)', () => {
    const myKey = 'mykey';
    const disabledTabKey = 'disabledTabKey';
    const testHeader = 'testHeader';
    const disabledTabHeader = 'disabledHeader';
    const onSelectedItemChanged = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox onSelectedItemChanged={onSelectedItemChanged} selectedKey={null} strings={strings}>
        <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="anotherKey" />
        <ToolboxItem headerText={testHeader} itemIcon="Product" itemKey={myKey} />
        <ToolboxItem
          headerText={disabledTabHeader}
          itemIcon="Edit"
          itemKey={disabledTabKey}
          disabled={true}
        />
      </Toolbox>
    );

    // find the command button inside the toolbox item
    const commandButtons = wrapper.find<IBaseButtonProps>(CommandButton);
    const linkButton = commandButtons.filterWhere(x => x.props().name === testHeader);

    expect(linkButton.props().onClick).toBeDefined();
    const preventDefaultFunction = jest.fn();

    // Click on the toolbox item will call onSelectedItemChange with correct value
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(myKey, false);

    // Clicking again should result in the same outcome, since the component is controlled and we didn't update the props.
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(myKey, false);

    // Clicking on a disabled tool should not change the selection
    const disabledButton = commandButtons.filterWhere(x => x.props().name === disabledTabHeader);
    if (disabledButton.props().onClick) {
      disabledButton.props().onClick({ preventDefault: preventDefaultFunction } as never);
    }
    expect(onSelectedItemChanged).not.toBeCalledWith(disabledTabKey, false);

    wrapper.unmount();
  });

  it('onSelectedItemChanged called with correct parameters on clicking Toolbox Item (uncontrolled)', () => {
    const myKey = 'mykey';
    const anotherKey = 'anotherKey';
    const testHeader = 'testHeader';
    const disabledTabKey = 'disabledTabKey';
    const disabledTabHeader = 'disabledHeader';
    const onSelectedItemChanged = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox onSelectedItemChanged={onSelectedItemChanged} strings={strings}>
        <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey={anotherKey} />
        <ToolboxItem headerText={testHeader} itemIcon="Product" itemKey={myKey} />
        <ToolboxItem
          headerText={disabledTabHeader}
          itemIcon="Edit"
          itemKey={disabledTabKey}
          disabled={true}
        />
      </Toolbox>
    );

    // find the command button inside the toolbox item
    const commandButtons = wrapper.find<IBaseButtonProps>(CommandButton);
    const linkButton = commandButtons.filterWhere(x => x.props().name === testHeader);

    expect(linkButton.props().onClick).toBeDefined();
    const preventDefaultFunction = jest.fn();

    // Click on the toolbox item will call onSelectedItemChange with correct value
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(myKey, false);

    // Clicking on the toolbox item again will unselect current item (call onSelectedItem change with empty string)
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(null, false);

    // Open the tool yet again
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(myKey, false);

    // Switch tools while a tool is open
    const otherLinkButton = commandButtons.filterWhere(x => x.props().name === 'item0header');
    otherLinkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(anotherKey, false);

    // Clicking on a disabled tool should not change the selection
    const disabledButton = commandButtons.filterWhere(x => x.props().name === disabledTabHeader);
    if (disabledButton.props().onClick) {
      disabledButton.props().onClick({ preventDefault: preventDefaultFunction } as never);
    }
    expect(onSelectedItemChanged).not.toBeCalledWith(disabledTabKey, false);

    wrapper.unmount();
  });

  it('onToggleExpandLinks called with correct parameters (controlled)', () => {
    const onToggleExpandLinks = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox onToggleExpandLinks={onToggleExpandLinks} expandLinks={false} strings={strings}>
        <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="anotherKey" />
      </Toolbox>
    );

    // find the command button inside the toolbox item
    const linkButton = wrapper.find<IBaseButtonProps>(CommandButton).first();

    expect(linkButton.props().onClick).toBeDefined();
    const preventDefaultFunction = jest.fn();

    // Expand links
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onToggleExpandLinks).toBeCalledWith(true);

    // Clicking again should result in the same outcome, since the component is controlled and we didn't update the props.
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onToggleExpandLinks).toBeCalledWith(true);

    wrapper.unmount();
  });

  it('onToggleExpandLinks called with correct parameters (uncontrolled)', () => {
    const onToggleExpandLinks = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox onToggleExpandLinks={onToggleExpandLinks} expandLinksInitially={false} strings={strings}>
        <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="anotherKey" />
      </Toolbox>
    );

    // find the command button inside the toolbox item
    const linkButton = wrapper.find<IBaseButtonProps>(CommandButton).first();

    expect(linkButton.props().onClick).toBeDefined();
    const preventDefaultFunction = jest.fn();

    // Expand links
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onToggleExpandLinks).toBeCalledWith(true);

    // Clicking again should collapse links
    linkButton.props().onClick!({ preventDefault: preventDefaultFunction } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onToggleExpandLinks).toBeCalledWith(false);

    wrapper.unmount();
  });

  it('toolbox link corresponds to keypress', () => {
    const myKey = 'mykey';
    const disabledTabKey = 'disabledTabKey';
    const disabledTabHeader = 'disabledHeader';
    const onSelectedItemChanged = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox onSelectedItemChanged={onSelectedItemChanged} strings={strings}>
        <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="anotherKey" />
        <ToolboxItem headerText={'testHeader'} itemIcon="Product" itemKey={myKey} />
        <ToolboxItem
          headerText={disabledTabHeader}
          itemIcon="Edit"
          itemKey={disabledTabKey}
          disabled={true}
        />
      </Toolbox>
    );

    // find the command button inside the toolbox item
    const commandButtons = wrapper.find<IBaseButtonProps>(CommandButton);
    const linkButton = commandButtons.filterWhere(x => x.props().name === 'testHeader');

    expect(linkButton.props().onKeyPress).toBeDefined();
    const preventDefaultFunction = jest.fn();

    // keypress on the toolbox with enter key will call onSelectedItemChange with correct value
    linkButton.props().onKeyPress!({
      preventDefault: preventDefaultFunction,
      which: KeyCodes.enter
    } as never);
    expect(preventDefaultFunction).toBeCalled();
    expect(onSelectedItemChanged).toBeCalledWith(myKey, false);

    // keypress with a different key than enter
    const preventDefaultFunction2 = jest.fn();
    linkButton.props().onKeyPress!({ preventDefault: preventDefaultFunction2, which: KeyCodes.a } as never);
    expect(preventDefaultFunction2).not.toBeCalled();

    // Keypress enter on a disabled tool should not change the selection
    const disabledButton = commandButtons.filterWhere(x => x.props().name === disabledTabHeader);
    if (disabledButton.props().onKeyPress) {
      disabledButton.props().onKeyPress!({
        preventDefault: preventDefaultFunction,
        which: KeyCodes.enter
      } as never);
    }
    expect(onSelectedItemChanged).not.toBeCalledWith(disabledTabKey, false);

    wrapper.unmount();
  });

  describe('expand/collapse button', () => {
    describe('using expandCollapseTooltip', () => {
      let wrapper: ToolboxWrapper;
      beforeEach(() => {
        wrapper = mount(
          <ToolboxBase
            strings={{
              expandCollapseTooltip: 'expand/collapse',
              expandTooltip: 'expand',
              collapseTooltip: 'collapse',
              closeTooltip: 'close'
            }}
          >
            <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="key0" />
          </ToolboxBase>
        );
      });

      afterAll(() => wrapper.unmount());

      it('should start collapsed', () => {
        const expandCollapseButton = wrapper.find<IBaseButtonProps>(CommandButton).first();
        expect(expandCollapseButton.props().title).toBe('expand/collapse');
        expect(expandCollapseButton.props().ariaLabel).toBe('expand/collapse');

        expect(getState(wrapper).linksAreExpanded).toBe(false);
      });

      it('should switch to expanded when button is clicked', () => {
        wrapper.find<IBaseButtonProps>(CommandButton).first().props().onClick!({
          preventDefault: jest.fn()
        } as never);
        wrapper.update();

        const expandCollapseButton = wrapper.find<IBaseButtonProps>(CommandButton).first();
        expect(expandCollapseButton.props().title).toBe('expand/collapse');
        expect(expandCollapseButton.props().ariaLabel).toBe('expand/collapse');
        expect(getState(wrapper).linksAreExpanded).toBe(true);
      });
    });

    describe('deprecated - using expandTooltip and collapseTooltip', () => {
      let wrapper: ToolboxWrapper;
      beforeEach(() => {
        wrapper = mount(
          <ToolboxBase
            strings={{ expandTooltip: 'expand', collapseTooltip: 'collapse', closeTooltip: 'close' }}
          >
            <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="key0" />
          </ToolboxBase>
        );
      });
      afterAll(() => wrapper.unmount());

      it('should start with expandTooltip', () => {
        const expandButton = wrapper.find<IBaseButtonProps>(CommandButton).first();
        expect(expandButton.props().title).toBe('expand');
        expect(getState(wrapper).linksAreExpanded).toBe(false);
      });

      it('should switch to collapseTooltip when clicked', () => {
        const expandButton = wrapper.find<IBaseButtonProps>(CommandButton).first();
        expandButton.props().onClick!({ preventDefault: jest.fn() } as never);
        wrapper.update();

        expect(wrapper.find<IBaseButtonProps>(CommandButton).first().props().ariaLabel).toBe('collapse');
        expect(getState(wrapper).linksAreExpanded).toBe(true);
      });
    });
  });

  it('onRenderItem link', () => {
    const onRenderLink = jest.fn();
    const wrapper: ToolboxWrapper = mount(
      <Toolbox strings={strings}>
        <ToolboxItem
          headerText={'item0header'}
          itemIcon="Cake"
          itemKey="key0"
          onRenderItemLink={onRenderLink}
        />
      </Toolbox>
    );

    expect(onRenderLink).toBeCalled();

    wrapper.unmount();
  });

  it('focus', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase strings={strings}>
        <ToolboxItem headerText={'item0header'} itemIcon="Cake" itemKey="key0" />
      </ToolboxBase>
    );

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const instance = wrapper.childAt(0).instance() as any;
    expect(instance.focus).toBeDefined();
    const focusZoneFn = jest.fn();
    instance._focusZone.current.focus = focusZoneFn;
    instance.focus();
    expect(focusZoneFn).toHaveBeenCalled();

    wrapper.unmount();
  });

  it('initialSelectedKey', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase initialSelectedKey="key2" strings={strings}>
        <ToolboxItem headerText={'header1'} itemIcon="Product" itemKey="key1" />
        <ToolboxItem headerText={'header2'} itemIcon="Product" itemKey="key2" />
        <ToolboxItem headerText={'header3'} itemIcon="Product" itemKey="key3" />
      </ToolboxBase>
    );
    expect(getState(wrapper).selectedKey).toEqual('key2');

    wrapper.unmount();
  });

  it('selectedKey has priority over initialSelectedKey', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase initialSelectedKey="key2" selectedKey={'key3'} strings={strings}>
        <ToolboxItem headerText={'header1'} itemIcon="Product" itemKey="key1" />
        <ToolboxItem headerText={'header2'} itemIcon="Product" itemKey="key2" />
        <ToolboxItem headerText={'header3'} itemIcon="Product" itemKey="key3" />
      </ToolboxBase>
    );
    expect(getState(wrapper).selectedKey).toEqual('key3');

    wrapper.unmount();
  });

  it('uses resizable correctly when true', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase strings={strings} isResizable={true}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </ToolboxBase>
    );
    const resizer = wrapper.find(Resizer);
    expect(resizer.length).toEqual(1);
    wrapper.unmount();
  });

  it('uses resizable correctly when false', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase strings={strings} isResizable={false}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </ToolboxBase>
    );
    const resizer = wrapper.find(Resizer);
    // shouldn't render the resizer
    expect(resizer.length).toEqual(0);
    wrapper.unmount();
  });

  it('Links should be collapsed by default', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase strings={strings}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </ToolboxBase>
    );
    expect(getState(wrapper).linksAreExpanded).toEqual(false);

    wrapper.unmount();
  });

  it('expandLinksInitially', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase expandLinksInitially={true} strings={strings}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </ToolboxBase>
    );
    expect(getState(wrapper).linksAreExpanded).toEqual(true);

    wrapper.unmount();
  });

  it('expandLinks has priority over expandLinksInitially', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase expandLinksInitially={true} expandLinks={false} strings={strings}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </ToolboxBase>
    );
    expect(getState(wrapper).linksAreExpanded).toEqual(false);

    wrapper.unmount();
  });

  it('selectedKey', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase selectedKey={null} strings={strings}>
        <ToolboxItem headerText={'header1'} itemIcon="Product" itemKey="key1" />
        <ToolboxItem headerText={'header2'} itemIcon="Product" itemKey="key2" />
        <ToolboxItem headerText={'header3'} itemIcon="Product" itemKey="key3" />
      </ToolboxBase>
    );
    expect(getState(wrapper).selectedKey).toEqual(null);
    expect(getState(wrapper).drawerIsExpanded).toEqual(false);

    wrapper.setProps({ selectedKey: 'key1' });
    expect(getState(wrapper).selectedKey).toEqual('key1');
    expect(getState(wrapper).drawerIsExpanded).toEqual(true);

    wrapper.setProps({ selectedKey: 'key3' });
    expect(getState(wrapper).selectedKey).toEqual('key3');
    expect(getState(wrapper).drawerIsExpanded).toEqual(true);

    wrapper.setProps({ selectedKey: null });
    expect(getState(wrapper).selectedKey).toEqual(null);
    expect(getState(wrapper).drawerIsExpanded).toEqual(false);

    wrapper.unmount();
  });

  it('expandLinks', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase expandLinks={false} strings={strings}>
        <ToolboxItem headerText={'header1'} itemIcon="Product" itemKey="key1" />
        <ToolboxItem headerText={'header2'} itemIcon="Product" itemKey="key2" />
        <ToolboxItem headerText={'header3'} itemIcon="Product" itemKey="key3" />
      </ToolboxBase>
    );
    expect(getState(wrapper).linksAreExpanded).toEqual(false);

    wrapper.setProps({ expandLinks: true });
    expect(getState(wrapper).linksAreExpanded).toEqual(true);

    wrapper.setProps({ expandLinks: false });
    expect(getState(wrapper).linksAreExpanded).toEqual(false);

    wrapper.unmount();
  });

  it.skip('Focus should return to tool link after closing drawer via "X" button', () => {
    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase expandLinks={false} strings={strings} selectedKey="key2">
        <ToolboxItem headerText={'header1'} itemIcon="Product" itemKey="key1" />
        <ToolboxItem headerText={'header2'} itemIcon="Product" itemKey="key2" />
        <ToolboxItem headerText={'header3'} itemIcon="Product" itemKey="key3" />
      </ToolboxBase>
    );

    // find the close button inside the toolbox item
    let closeButton = wrapper
      .find<IBaseButtonProps>(CommandButton)
      .filterWhere(x => x.props().title === strings.closeTooltip);
    expect(closeButton).toHaveLength(1);

    closeButton.simulate('click');

    // Focus should move to the tab of the collapsed tool
    expect(document.activeElement.getAttribute('name').indexOf('header2')).toBeGreaterThanOrEqual(0);

    wrapper.setProps({ selectedKey: 'key3' });
    closeButton = wrapper
      .find<IBaseButtonProps>(CommandButton)
      .filterWhere(x => x.props().title === strings.closeTooltip);
    expect(closeButton).toHaveLength(1);

    closeButton.simulate('click');

    // Focus should move to the tab of the collapsed tool
    expect(document.activeElement.getAttribute('name').indexOf('header3')).toBeGreaterThanOrEqual(0);

    wrapper.unmount();
  });

  it('Conditional toolbox items should render work', () => {
    const toolTabSelector = `button.${ToolboxAutomationSelectors.toolTabClassName}`;
    const wrapper: ReactWrapper<IConditionalItemToolboxProps> = mount(
      <ConditionalItemToolbox
        selectedKey={'key1'}
        showSecondItem={false}
        showThirdItem={false}
        disableThirdItem={false}
      />
    );

    expect(wrapper.find(toolTabSelector).length).toEqual(1);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(1);

    // Show the second tab, but do not select it.
    wrapper.setProps({ showSecondItem: true });
    expect(wrapper.find(toolTabSelector).length).toEqual(2);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(1);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(0);

    // Select the second tab
    wrapper.setProps({ selectedKey: 'key2' });
    expect(wrapper.find(toolTabSelector).length).toEqual(2);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(1);

    // Show the third tab, as well, but do not select it
    wrapper.setProps({ showThirdItem: true });
    expect(wrapper.find(toolTabSelector).length).toEqual(3);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(1);
    expect(wrapper.find('.toolbox-item-3').length).toEqual(0);

    // Select the third tab
    wrapper.setProps({ selectedKey: 'key3' });
    expect(wrapper.find(toolTabSelector).length).toEqual(3);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-3').length).toEqual(1);

    // Hide the second tab again
    wrapper.setProps({ showSecondItem: false });
    expect(wrapper.find(toolTabSelector).length).toEqual(2);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-3').length).toEqual(1);

    // Disable the third tab
    wrapper.setProps({ showSecondItem: true, disableThirdItem: true });
    expect(wrapper.find(toolTabSelector).length).toEqual(3);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-3').length).toEqual(0);
    expect(wrapper.find(`${toolTabSelector}[disabled]`).length).toEqual(1);

    // Enable the third tab again
    wrapper.setProps({ disableThirdItem: false });
    expect(wrapper.find(toolTabSelector).length).toEqual(3);
    expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
    expect(wrapper.find('.toolbox-item-3').length).toEqual(1);
    expect(wrapper.find(`${toolTabSelector}[disabled]`).length).toEqual(0);

    wrapper.unmount();
  });

  it('renders the custom toolbox links container if provided', () => {
    const containerId = 'customContainer';

    const Container: React.FC<IFocusZoneProps> = props => {
      return <FocusZone {...props} id={containerId} />;
    };

    const wrapper: ToolboxWrapper = mount(
      <ToolboxBase strings={strings} isResizable={true} toolboxLinksContainerAs={Container}>
        <ToolboxItem headerText={'header'} itemIcon="Product" itemKey="key" />
      </ToolboxBase>
    );

    const foundContainer = wrapper.find(`#${containerId}`).hostNodes();
    expect(foundContainer.length).toEqual(1);
    wrapper.unmount();
  });
});

interface IConditionalItemToolboxProps {
  selectedKey: string;
  showSecondItem: boolean;
  showThirdItem: boolean;
  disableThirdItem: boolean;
}

class ConditionalItemToolbox extends React.Component<IConditionalItemToolboxProps> {
  public render() {
    const { selectedKey, showSecondItem, showThirdItem, disableThirdItem } = this.props;

    return (
      <Toolbox expandLinks={false} strings={strings} selectedKey={selectedKey}>
        <ToolboxItem headerText={'header1'} itemIcon="Product" itemKey="key1">
          <div className={'toolbox-item-1'}>{'Item 1'}</div>
        </ToolboxItem>
        {showSecondItem && (
          <ToolboxItem headerText={'header2'} itemIcon="Product" itemKey="key2">
            <div className={'toolbox-item-2'}>{'Item 2'}</div>
          </ToolboxItem>
        )}
        {showThirdItem && (
          <ToolboxItem headerText={'header3'} itemIcon="Product" itemKey="key3" disabled={disableThirdItem}>
            <div className={'toolbox-item-3'}>{'Item 3'}</div>
          </ToolboxItem>
        )}
      </Toolbox>
    );
  }
}
