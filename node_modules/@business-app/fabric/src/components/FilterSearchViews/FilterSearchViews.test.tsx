/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import { mount, ReactWrapper } from 'enzyme';
import * as React from 'react';

import { IconButton } from '@fluentui/react/lib/Button';

import { FilterSearchBox, IFilterItem } from '../FilterSearchBox';
import {
  defaultFilterIconNameFunction,
  FilterSearchViewsBase,
  IFilterSearchViews,
  IFilterSearchViewsProps,
  IFilterSearchViewsState,
  IItem
} from './index';

type FilterSearchViewsWrapper = ReactWrapper<IFilterSearchViewsProps, IFilterSearchViewsState>;

interface IDataItem extends IItem {
  value: number;
  children?: IDataItem[];
}

const flatItems: IDataItem[] = [{ value: 1 }, { value: 2 }];

const nestedItems: IDataItem[] = [
  { value: 1, children: [{ value: 11 }, { value: 12 }] },
  { value: 2, children: [{ value: 21 }, { value: 22 }] }
];

const strings = {
  searchBoxPlaceholder: '',
  allItemsFilterItemText: ''
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getInstance(wrapper: FilterSearchViewsWrapper): any {
  return wrapper.childAt(0).instance();
}

function getState(wrapper: FilterSearchViewsWrapper): IFilterSearchViewsState {
  return getInstance(wrapper).state;
}

describe('FilterSearchViews', () => {
  it('calls shouldFilterItem for every item', () => {
    let shouldFilterItemFn = jest.fn();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={shouldFilterItemFn}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
      />
    );

    expect(shouldFilterItemFn).toHaveBeenCalledTimes(flatItems.length);

    shouldFilterItemFn = jest.fn();
    wrapper.setProps({
      items: nestedItems,
      shouldFilterItem: shouldFilterItemFn
    });

    expect(shouldFilterItemFn).toHaveBeenCalledTimes(
      nestedItems.length + nestedItems[0].children.length + nestedItems[1].children.length
    );

    wrapper.unmount();
  });

  it('calls onRenderView for the selected view', () => {
    const view1RenderFn = jest.fn();
    const view2RenderFn = jest.fn();

    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={[
          { key: 'one', iconName: '', text: 'One', onRenderView: view1RenderFn },
          { key: 'two', iconName: '', text: 'Two', onRenderView: view2RenderFn }
        ]}
        strings={strings}
      />
    );

    expect(view1RenderFn).toHaveBeenCalledTimes(1);
    expect(view2RenderFn).toHaveBeenCalledTimes(0);

    const viewsButton = wrapper.find(IconButton);
    expect(viewsButton.length).toBe(1);
    viewsButton.props().onClick(null);

    expect(view1RenderFn).toHaveBeenCalledTimes(1);
    expect(view2RenderFn).toHaveBeenCalledTimes(1);

    wrapper.unmount();
  });

  it('calls onRenderView with correct information', () => {
    const filters: IFilterItem[] = [{ key: 'a', text: 'A' }];
    const viewRenderFn = jest.fn();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={[{ key: 'one', iconName: '', text: 'One', onRenderView: viewRenderFn }]}
        filters={filters}
        strings={strings}
      />
    );

    expect(viewRenderFn).toHaveBeenCalledTimes(1);
    expect(viewRenderFn).toHaveBeenLastCalledWith(flatItems, '', null);

    const searchBox = wrapper.find(FilterSearchBox);
    expect(searchBox.length).toBe(1);
    searchBox.prop('onSearchTextChange')(null, 'Some search');

    expect(viewRenderFn).toHaveBeenCalledTimes(2);
    expect(viewRenderFn).toHaveBeenLastCalledWith(flatItems, 'Some search', null);

    searchBox.prop('onFilterChange')('a');

    expect(viewRenderFn).toHaveBeenCalledTimes(3);
    expect(viewRenderFn).toHaveBeenLastCalledWith(flatItems, 'Some search', filters[0]);

    wrapper.unmount();
  });

  it('provides views picker IconButton correct props based on views count', () => {
    const views = [
      { key: 'one', iconName: '', text: 'One', onRenderView: () => null },
      { key: 'two', iconName: '', text: 'Two', onRenderView: () => null }
    ];
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        strings={strings}
      />
    );

    expect(getState(wrapper).selectedViewKey).toBe('one');

    let viewsButton = wrapper.find(IconButton);
    expect(viewsButton.length).toBe(1);
    expect(viewsButton.prop('onClick')).toBeTruthy();
    expect(viewsButton.prop('menuProps')).toBeUndefined();

    views.push({ key: 'three', iconName: '', text: 'Three', onRenderView: () => null });
    wrapper.setProps({ views });

    viewsButton = wrapper.find(IconButton);
    expect(viewsButton.length).toBe(1);
    expect(viewsButton.prop('onClick')).toBeUndefined();
    expect(viewsButton.prop('menuProps')).toBeTruthy();

    wrapper.unmount();
  });

  it('renders view picker correctly based on views count', () => {
    const views = [{ key: 'one', iconName: '', text: 'One', onRenderView: () => null }];
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        strings={strings}
      />
    );

    let viewsButton = wrapper.find(IconButton);
    expect(viewsButton.length).toBe(0);

    views.push({ key: 'two', iconName: '', text: 'Two', onRenderView: () => null });
    wrapper.setProps({ views });

    viewsButton = wrapper.find(IconButton);
    expect(viewsButton.length).toBe(1);

    wrapper.unmount();
  });

  it('updates selectedViewKey appropriately when views is removed', () => {
    const views = [
      { key: 'one', iconName: '', text: 'One', onRenderView: () => null },
      { key: 'two', iconName: '', text: 'Two', onRenderView: () => null }
    ];

    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        strings={strings}
      />
    );

    expect(getState(wrapper).selectedViewKey).toBe('one');

    const viewsButton = wrapper.find(IconButton);
    viewsButton.props().onClick(null);
    expect(getState(wrapper).selectedViewKey).toBe('two');

    views.splice(1, 1);
    wrapper.setProps({ views });

    expect(getState(wrapper).selectedViewKey).toBe('one');

    wrapper.unmount();
  });

  it('updates selectedViewKey to defaultValue when view is removed', () => {
    const views = [
      { key: 'one', iconName: '', text: 'One', onRenderView: () => null },
      { key: 'two', iconName: '', text: 'Two', onRenderView: () => null },
      { key: 'three', iconName: '', text: 'Three', onRenderView: () => null }
    ];

    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        strings={strings}
        defaultSelectedViewKey={'two'}
      />
    );

    expect(getState(wrapper).selectedViewKey).toBe('two');

    const viewsButton = wrapper.find(IconButton);
    viewsButton.prop('menuProps').onItemClick(null, views[2]);
    expect(getState(wrapper).selectedViewKey).toBe('three');

    // Remove three and ensure it goes back to two
    views.splice(2, 1);
    wrapper.setProps({ views });

    expect(getState(wrapper).selectedViewKey).toBe('two');

    wrapper.unmount();
  });

  it('updates selectedViewKey as appropriate', () => {
    const views = [
      { key: 'one', iconName: '', text: 'One', onRenderView: () => null },
      { key: 'two', iconName: '', text: 'Two', onRenderView: () => null }
    ];

    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        strings={strings}
      />
    );

    // With only two views, click the button and make sure it cycles
    expect(getState(wrapper).selectedViewKey).toBe('one');

    let viewsButton = wrapper.find(IconButton);
    viewsButton.props().onClick(null);
    expect(getState(wrapper).selectedViewKey).toBe('two');

    viewsButton.props().onClick(null);
    expect(getState(wrapper).selectedViewKey).toBe('one');

    // Add a view and try with three
    views.push({ key: 'three', iconName: '', text: 'Three', onRenderView: () => null });
    wrapper.setProps({ views });

    viewsButton = wrapper.find(IconButton);
    viewsButton.prop('menuProps').onItemClick(null, views[2]);
    expect(getState(wrapper).selectedViewKey).toBe('three');

    wrapper.unmount();
  });

  it('calls onRenderView with only the filtered items', () => {
    const renderViewFn = jest.fn();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={(item: IDataItem) => item.value !== 2}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: renderViewFn }]}
        strings={strings}
      />
    );

    expect(renderViewFn).toBeCalledWith(flatItems.slice(0, 1), '', null);

    wrapper.unmount();
  });

  it('calls onRenderView with only the filtered partial nested items', () => {
    const renderViewFn = jest.fn();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={nestedItems}
        shouldFilterItem={(item: IDataItem) => item.value !== 11}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: renderViewFn }]}
        strings={strings}
      />
    );

    const expectedItems = nestedItems.slice(0);
    expectedItems[0].children = expectedItems[0].children.slice(1, 2);
    expect(renderViewFn).toBeCalledWith(expectedItems, '', null);

    wrapper.unmount();
  });

  it('calls onRenderView with empty groups removed', () => {
    const renderViewFn = jest.fn();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={nestedItems}
        shouldFilterItem={(item: IDataItem) => {
          if (item.children) {
            return item.children.length > 0;
          }
          return item.value < 20;
        }}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: renderViewFn }]}
        strings={strings}
      />
    );

    expect(renderViewFn).toBeCalledWith(nestedItems.slice(0, 1), '', null);

    wrapper.unmount();
  });

  it('calls shouldFilterItem with correct search and filter information', () => {
    const shouldFilterItemFn = jest.fn();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={shouldFilterItemFn}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        filters={[{ key: 'a', text: 'A' }]}
        strings={strings}
      />
    );

    expect(shouldFilterItemFn).toHaveBeenLastCalledWith(flatItems[1], '', null);

    const filterSearchBox = wrapper.find(FilterSearchBox);
    filterSearchBox.prop('onSearchTextChange')(null, 'New Search Text');

    expect(shouldFilterItemFn).toHaveBeenLastCalledWith(flatItems[1], 'New Search Text', null);

    filterSearchBox.prop('onFilterChange')('a');

    expect(shouldFilterItemFn).toHaveBeenLastCalledWith(flatItems[1], 'New Search Text', {
      key: 'a',
      text: 'A'
    });

    wrapper.unmount();
  });

  it('updates all filter text correctly when strings allItemFilterText changes', () => {
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={{
          searchBoxPlaceholder: '',
          allItemsFilterItemText: 'All'
        }}
      />
    );

    let filterSearchBox = wrapper.find(FilterSearchBox);
    expect(filterSearchBox.length).toBe(1);
    expect(filterSearchBox.prop('filters')[0].text).toBe('All');

    wrapper.setProps({
      strings: {
        searchBoxPlaceholder: '',
        allItemsFilterItemText: 'All items'
      }
    });

    filterSearchBox = wrapper.find(FilterSearchBox);
    expect(filterSearchBox.length).toBe(1);
    expect(filterSearchBox.prop('filters')[0].text).toBe('All items');

    wrapper.unmount();
  });

  it('updates filters list when props change', () => {
    const aFilter: IFilterItem = { key: 'a', text: 'A' };
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        filters={[aFilter]}
        strings={{
          searchBoxPlaceholder: '',
          allItemsFilterItemText: 'All'
        }}
      />
    );

    let filterSearchBox = wrapper.find(FilterSearchBox);
    expect(filterSearchBox.length).toBe(1);
    expect(filterSearchBox.prop('filters')).toEqual([
      { key: 'filterSearchViewsAllFilterKey', text: 'All' },
      aFilter
    ]);

    const anotherFilter = { key: 'b', text: 'B' };
    wrapper.setProps({
      filters: [aFilter, anotherFilter]
    });

    filterSearchBox = wrapper.find(FilterSearchBox);
    expect(filterSearchBox.length).toBe(1);
    expect(filterSearchBox.prop('filters')).toEqual([
      { key: 'filterSearchViewsAllFilterKey', text: 'All' },
      aFilter,
      anotherFilter
    ]);

    wrapper.unmount();
  });

  it('focuses search box when focus is called on componentRef', () => {
    const ref = React.createRef<IFilterSearchViews>();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        componentRef={ref}
        items={flatItems}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
      />
    );

    const instance = getInstance(wrapper);
    const focusFn = jest.fn();
    instance._filterSearchBoxRef.current.focus = focusFn;

    expect(ref.current).toBeTruthy();
    expect(ref.current.focus).toBeDefined();
    ref.current.focus();
    expect(focusFn).toHaveBeenCalled();

    wrapper.unmount();
  });

  it('throws an error with cirular references in items', () => {
    const item1: IDataItem = { value: 1 };
    const item2: IDataItem = { value: 2, children: [item1] };
    item1.children = [item2];

    let caughtError: Error;

    class ErrorBoundary extends React.Component {
      public render() {
        return (
          <FilterSearchViewsBase
            items={[item1, item2]}
            shouldFilterItem={() => true}
            views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
            strings={strings}
          />
        );
      }

      public componentDidCatch(error: Error) {
        caughtError = error;
      }
    }

    // Disable the console.error while this component mounts. This will prevent a giant error message
    // from being printed and looking like a test failure.
    // eslint-disable-next-line no-console
    const originalError = console.error;
    // eslint-disable-next-line no-console
    console.error = jest.fn();

    const wrapper: FilterSearchViewsWrapper = mount(<ErrorBoundary />);

    // eslint-disable-next-line no-console
    console.error = originalError;

    expect(caughtError).toBeTruthy();
    expect(
      caughtError.message.indexOf(
        'FilterSearchViews: Invalid items property. This could be due to circular references in items. Error: '
      )
    ).toBeGreaterThan(-1);

    wrapper.unmount();
  });

  it('handles default state props as expected', () => {
    const defaultSearchText = 'Default Search';
    const defaultFilterKey = 'a';
    const defaultViewKey = 'two';

    const view1RenderFn = jest.fn();
    const view2RenderFn = jest.fn();

    const filters = [
      { key: 'a', text: 'A' },
      { key: 'b', text: 'B' }
    ];
    const views = [
      { key: 'one', iconName: '', text: 'One', onRenderView: view1RenderFn },
      { key: 'two', iconName: '', text: 'Two', onRenderView: view2RenderFn }
    ];

    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        strings={strings}
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        filters={filters}
        defaultSearchText={defaultSearchText}
        defaultSelectedFilterKey={defaultFilterKey}
        defaultSelectedViewKey={defaultViewKey}
      />
    );

    expect(getState(wrapper).searchText).toBe(defaultSearchText);
    expect(getState(wrapper).selectedFilterKey).toBe(defaultFilterKey);
    expect(getState(wrapper).selectedViewKey).toBe(defaultViewKey);

    const filterSearchBox = wrapper.find(FilterSearchBox);
    expect(filterSearchBox.prop('searchText')).toBe(defaultSearchText);
    expect(filterSearchBox.prop('selectedFilterKey')).toBe(defaultFilterKey);

    expect(view1RenderFn).toHaveBeenCalledTimes(0);
    expect(view2RenderFn).toHaveBeenCalledTimes(1);

    const instance = getInstance(wrapper);
    expect(instance._selectedFilter).toBe(filters[0]);
    expect(instance._selectedView).toBe(views[1]);

    wrapper.unmount();
  });

  it('calls onChange functions when values change', () => {
    const filters = [
      { key: 'a', text: 'A' },
      { key: 'b', text: 'B' }
    ];
    const views = [
      { key: 'one', iconName: '', text: 'One', onRenderView: () => null },
      { key: 'two', iconName: '', text: 'Two', onRenderView: () => null },
      { key: 'three', iconName: '', text: 'Three', onRenderView: () => null }
    ];
    const onChangeSearchText = jest.fn();
    const onChangeFilter = jest.fn();
    const onChangeView = jest.fn();

    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={views}
        filters={filters}
        strings={strings}
        onChangeSearchText={onChangeSearchText}
        onChangeFilter={onChangeFilter}
        onChangeView={onChangeView}
      />
    );

    const filterSearchBox = wrapper.find(FilterSearchBox);
    expect(filterSearchBox.length).toBe(1);
    const viewsButton = wrapper.find(IconButton);
    expect(viewsButton.length).toBe(1);

    // First validate the onChange functions are called when the value changes
    filterSearchBox.prop('onSearchTextChange')(null, 'Some text');
    expect(onChangeSearchText).toHaveBeenCalledTimes(1);
    expect(onChangeSearchText).toHaveBeenLastCalledWith('Some text');

    filterSearchBox.prop('onFilterChange')('a');
    expect(onChangeFilter).toHaveBeenCalledTimes(1);
    expect(onChangeFilter).toHaveBeenLastCalledWith('a');

    viewsButton.prop('menuProps').onItemClick(null, views[2]);
    expect(onChangeView).toHaveBeenCalledTimes(1);
    expect(onChangeView).toHaveBeenLastCalledWith('three');

    // Now validate they aren't called when change is triggered again with the same value.
    filterSearchBox.prop('onSearchTextChange')(null, 'Some text');
    expect(onChangeSearchText).toHaveBeenCalledTimes(1);

    filterSearchBox.prop('onFilterChange')('a');
    expect(onChangeFilter).toHaveBeenCalledTimes(1);

    viewsButton.prop('menuProps').onItemClick(null, views[2]);
    expect(onChangeView).toHaveBeenCalledTimes(1);

    wrapper.unmount();
  });

  it('sends filterButtonIconName prop correctly to FilterSearchBox', () => {
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
        filterButtonIconName={'Some icon name'}
      />
    );

    let searchBox = wrapper.find(FilterSearchBox);
    expect(searchBox.length).toBe(1);
    expect(searchBox.prop('filterButtonIconName')).toBe('Some icon name');

    wrapper.setProps({
      filterButtonIconName: () => 'Some icon name that is different'
    });

    searchBox = wrapper.find(FilterSearchBox);
    expect(searchBox.length).toBe(1);
    expect(searchBox.prop('filterButtonIconName')).toBe('Some icon name that is different');

    wrapper.unmount();
  });

  it('filterButtonIconName is called appropriately based on selected filter', () => {
    const filterButtonIconFn = jest.fn();

    const filters = [
      { key: 'a', text: 'A' },
      { key: 'b', text: 'B' }
    ];
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        filters={filters}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
        filterButtonIconName={filterButtonIconFn}
      />
    );

    // Initially it should have been called with null - since the All filter will be selected by default
    expect(filterButtonIconFn).toHaveBeenCalledTimes(1);
    expect(filterButtonIconFn).toHaveBeenLastCalledWith(null);

    getInstance(wrapper).setState({ selectedFilterKey: filters[1].key });
    wrapper.update();

    expect(filterButtonIconFn).toHaveBeenCalledTimes(2);
    expect(filterButtonIconFn).toHaveBeenLastCalledWith(filters[1].key);

    wrapper.unmount();
  });

  it('defaultFilterIconNameFunction functions correctly', () => {
    const filters = [
      { key: 'a', text: 'A' },
      { key: 'b', text: 'B' }
    ];
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        filters={filters}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
        filterButtonIconName={defaultFilterIconNameFunction}
      />
    );

    expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('Filter');

    getInstance(wrapper).setState({ selectedFilterKey: filters[0].key });
    wrapper.update();
    expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('FilterSolid');

    getInstance(wrapper).setState({ selectedFilterKey: filters[1].key });
    wrapper.update();
    expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('FilterSolid');

    getInstance(wrapper).setState({ selectedFilterKey: 'filterSearchViewsAllFilterKey' });
    wrapper.update();
    expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('Filter');
  });

  it('sends strings appropriately to FilterSearchBox', () => {
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        items={flatItems}
        shouldFilterItem={() => true}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={{
          ...strings,
          searchBoxPlaceholder: 'Search box placeholder',
          searchBoxClearButtonTitle: 'Clear search tooltip',
          filterButtonTooltipText: 'Filter button tooltip'
        }}
      />
    );

    const searchBox = wrapper.find(FilterSearchBox);
    expect(searchBox.length).toBe(1);
    expect(searchBox.prop('strings').searchBoxPlaceholder).toBe('Search box placeholder');
    expect(searchBox.prop('strings').searchBoxClearButtonTitle).toBe('Clear search tooltip');
    expect(searchBox.prop('strings').filterButtonTooltipText).toBe('Filter button tooltip');

    wrapper.unmount();
  });

  it('fills a componentRef', () => {
    const _filterSearchViewsRef = React.createRef<IFilterSearchViews>();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        componentRef={_filterSearchViewsRef}
        items={nestedItems}
        shouldFilterItem={(item: IDataItem) => {
          if (item.children) {
            return item.children.length > 0;
          }
          return item.value < 20;
        }}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
      />
    );

    expect(_filterSearchViewsRef.current).not.toBeNull();

    wrapper.unmount();
  });

  it('dissmisses menu on FilterSearchBox when dismissmenu is called on componentRef', () => {
    const _filterSearchViewsRef = React.createRef<IFilterSearchViews>();
    const wrapper: FilterSearchViewsWrapper = mount(
      <FilterSearchViewsBase
        componentRef={_filterSearchViewsRef}
        items={nestedItems}
        shouldFilterItem={(item: IDataItem) => {
          if (item.children) {
            return item.children.length > 0;
          }
          return item.value < 20;
        }}
        views={[{ key: 'test', iconName: '', text: 'Test', onRenderView: () => null }]}
        strings={strings}
      />
    );

    const instance = getInstance(wrapper);
    const dismissFn = jest.fn();
    instance._filterSearchBoxRef.current.dismissMenu = dismissFn;

    expect(_filterSearchViewsRef.current).toBeTruthy();
    expect(_filterSearchViewsRef.current.dismissMenu).toBeDefined();
    _filterSearchViewsRef.current.dismissMenu();
    expect(dismissFn).toHaveBeenCalled();

    wrapper.unmount();
  });
});
