/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */

import * as React from 'react';

import { IconButton } from '@fluentui/react/lib/Button';
import {
  DirectionalHint,
  IContextualMenuItem,
  IContextualMenuProps
} from '@fluentui/react/lib/ContextualMenu';
import { IProcessedStyleSet } from '@fluentui/react/lib/Styling';
import {
  BaseComponent,
  classNamesFunction,
  customizable,
  find,
  findIndex
} from '@fluentui/react/lib/Utilities';

import { FilterSearchBox, IFilterSearchBox } from '../FilterSearchBox';
import { IView } from './index';

import { IFilterItem } from '../FilterSearchBox';
import {
  IFilterSearchViewsProps,
  IFilterSearchViewsState,
  IFilterSearchViewsStyleProps,
  IFilterSearchViewsStyles,
  IItem,
  IRetrieveFilterButtonIconName
} from './FilterSearchViews.types';

const getClassNames = classNamesFunction<IFilterSearchViewsStyleProps, IFilterSearchViewsStyles>();

const allFilterItemDefaultKey = 'filterSearchViewsAllFilterKey';
const allFilterItemText = 'All';

export const defaultFilterIconNameFunction: IRetrieveFilterButtonIconName = (
  selectedFilterKey: string | null
): string => {
  return selectedFilterKey === null ? 'Filter' : 'FilterSolid';
};

@customizable('FilterSearchViews', ['theme', 'styles'])
export class FilterSearchViewsBase extends BaseComponent<IFilterSearchViewsProps, IFilterSearchViewsState> {
  public static defaultProps: Partial<IFilterSearchViewsProps> = {
    defaultSearchText: '',
    allFilterItemKey: allFilterItemDefaultKey
  };

  private _classNames: IProcessedStyleSet<IFilterSearchViewsStyles>;
  private _filterSearchBoxRef = React.createRef<IFilterSearchBox>();

  constructor(props: IFilterSearchViewsProps) {
    super(props);

    this.state = {
      searchText: this.props.defaultSearchText,
      selectedFilterKey: this.props.defaultSelectedFilterKey || this.props.allFilterItemKey,
      selectedViewKey: this._getInitialSelectedViewKey(props)
    };
  }

  public focus(): void {
    if (this._filterSearchBoxRef.current) {
      this._filterSearchBoxRef.current.focus();
    }
  }

  public dismissMenu(): void {
    if (this._filterSearchBoxRef.current) {
      this._filterSearchBoxRef.current.dismissMenu();
    }
  }

  public componentDidUpdate() {
    // Ensure the view is still available. If not, set back to default.
    const selectedView = find(this.props.views, view => view.key === this.state.selectedViewKey);
    if (!selectedView) {
      this.setState({
        selectedViewKey: this._getInitialSelectedViewKey(this.props)
      });
    }
  }

  public render() {
    this._classNames = this._getClassNames(this.props);

    return (
      <div className={this._classNames.root}>
        {this._renderSearchBoxAndViewToggle()}
        {this._renderView()}
      </div>
    );
  }

  private _renderView(): JSX.Element {
    const { searchText } = this.state;

    if (!this._selectedView) {
      return null;
    }

    const selectedFilter = this._selectedFilter;
    const filteredItems = this._getFilteredItems(this.props.items, searchText, selectedFilter);
    return this._selectedView.onRenderView(filteredItems, searchText, selectedFilter);
  }

  private get _selectedView(): IView | null {
    const { views } = this.props;
    const { selectedViewKey } = this.state;

    return find(views, view => view.key === selectedViewKey) || null;
  }

  private get _selectedFilter(): IFilterItem | null {
    const { filters } = this.props;
    const { selectedFilterKey } = this.state;

    if (filters) {
      return find(filters, filter => filter.key === selectedFilterKey) || null;
    }

    return null;
  }

  private _renderSearchBoxAndViewToggle(): JSX.Element {
    const { strings, filters, filterButtonIconName } = this.props;
    const { searchText, selectedFilterKey } = this.state;

    const filtersWithAll = [
      {
        key: this.props.allFilterItemKey,
        text: strings.allItemsFilterItemText || allFilterItemText
      }
    ];
    if (filters) {
      filtersWithAll.push(...filters);
    }

    let filterIconName: string;
    if (typeof filterButtonIconName === 'function') {
      // Use _selectedFilter, since it is the consumer facing selected filter.
      // This value excludes the 'All' filter that is added by this component.
      const selectedFilter = this._selectedFilter;
      filterIconName = filterButtonIconName(selectedFilter ? selectedFilter.key : null);
    } else {
      filterIconName = filterButtonIconName;
    }

    return (
      <>
        <div className={this._classNames.searchBoxViewPickerContainer}>
          <FilterSearchBox
            componentRef={this._filterSearchBoxRef}
            strings={{
              searchBoxPlaceholder: strings.searchBoxPlaceholder,
              searchBoxClearButtonTitle: strings.searchBoxClearButtonTitle,
              filterButtonTooltipText: strings.filterButtonTooltipText
            }}
            searchText={searchText}
            onSearchTextChange={this._onChangeSearchText}
            filters={filtersWithAll}
            selectedFilterKey={selectedFilterKey}
            onFilterChange={this._onChangeFilter}
            styles={{ root: this._classNames.filterSearchBox }}
            filterButtonIconName={filterIconName}
          />
          {this._renderViewPicker()}
          {this.props.refreshButtonProps}
        </div>
      </>
    );
  }

  private _renderViewPicker(): JSX.Element {
    const { views } = this.props;
    const selectedView = this._selectedView;

    // No need to render the view picker if only one or fewer views.
    if (views.length <= 1) {
      return null;
    }

    let menuProps: IContextualMenuProps;
    let onClick = this._onClickViewPickerIcon;
    if (views.length > 2) {
      onClick = undefined;
      menuProps = {
        items: views.map(v => ({ key: v.key, text: v.text, iconProps: { iconName: v.iconName } })),
        directionalHint: DirectionalHint.bottomRightEdge,
        onItemClick: this._onClickViewPickerIconFromMenu
      };
    }

    return (
      <IconButton
        styles={{ root: this._classNames.viewPickerButton }}
        iconProps={{ iconName: selectedView?.iconName }}
        onClick={onClick}
        menuProps={menuProps}
        ariaLabel={selectedView?.ariaLabel}
        title={selectedView?.ariaLabel}
      />
    );
  }

  private _onClickViewPickerIcon = () => {
    const { views } = this.props;

    // If we have 2 or more views, then clicking will not just toggle, so ignore this click.
    if (views.length > 2) {
      return;
    }

    this.setState(prev => {
      // Find the currently selected index
      const index = findIndex(views, view => view.key === prev.selectedViewKey);
      const newIndex = (index + 1) % this.props.views.length;
      return { selectedViewKey: views[newIndex] ? views[newIndex].key : null };
    });
  };

  private _onClickViewPickerIconFromMenu = (
    _: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>,
    menuItem: IContextualMenuItem
  ) => {
    const { onChangeView } = this.props;
    const { selectedViewKey } = this.state;

    if (menuItem.key === selectedViewKey) {
      return;
    }

    if (onChangeView) {
      onChangeView(menuItem.key);
    }

    this.setState({ selectedViewKey: menuItem.key });
  };

  private _onChangeSearchText = (event?: React.ChangeEvent<HTMLInputElement>, text?: string) => {
    const { onChangeSearchText } = this.props;
    const { searchText } = this.state;

    if (text === searchText) {
      return;
    }

    if (onChangeSearchText) {
      onChangeSearchText(text || '');
    }

    this.setState({ searchText: text || '' });
  };

  private _onChangeFilter = (filterKey: string) => {
    const { onChangeFilter } = this.props;
    const { selectedFilterKey } = this.state;

    if (filterKey === selectedFilterKey) {
      return;
    }

    if (onChangeFilter) {
      onChangeFilter(filterKey);
    }

    this.setState({ selectedFilterKey: filterKey });
  };

  private _getFilteredItems(items: IItem[], searchText: string, selectedFilter: IFilterItem): IItem[] {
    // Get a deep copy of the items so we do not modify the original data.
    let itemsCopy: IItem[];
    try {
      itemsCopy = JSON.parse(JSON.stringify(items));
    } catch (error) {
      // If this is not an Error, just rethrow, since we can't really improve the messaging.
      if (!(error instanceof Error)) {
        throw error;
      }

      // Improve the messaging of the error we throw.
      throw new Error(
        `FilterSearchViews: Invalid items property. This could be due to circular references in items. Error: ${error.message}`
      );
    }

    return this._filterItemRecursively(itemsCopy, searchText, selectedFilter);
  }

  private _filterItemRecursively(items: IItem[], searchText: string, selectedFilter: IFilterItem) {
    return items.filter(item => {
      if (item.children) {
        item.children = this._filterItemRecursively(item.children, searchText, selectedFilter);
      }

      return this.props.shouldFilterItem(item, searchText, selectedFilter);
    });
  }

  private _getClassNames(props: IFilterSearchViewsProps): IProcessedStyleSet<IFilterSearchViewsStyles> {
    const { theme } = props;

    return getClassNames(props.styles!, {
      theme: theme!
    });
  }

  private _getInitialSelectedViewKey(props: IFilterSearchViewsProps): string {
    let initialViewKey = props.defaultSelectedViewKey;
    if (!initialViewKey && props.views.length > 0) {
      initialViewKey = props.views[0].key;
    }

    return initialViewKey || null;
  }
}
