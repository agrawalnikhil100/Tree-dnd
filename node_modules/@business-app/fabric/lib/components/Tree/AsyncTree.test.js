/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __awaiter, __generator } from "tslib";
import { mount } from 'enzyme';
import { IconBase } from '@fluentui/react/lib/Icon';
import { Link } from '@fluentui/react/lib/Link';
import { Spinner } from '@fluentui/react/lib/Spinner';
import { setIconOptions } from '@fluentui/react/lib/Styling';
import * as React from 'react';
import { AsyncTree } from './AsyncTree';
import { ExpandIcon } from './ExpandIcon/ExpandIcon';
import { TreeNode } from './TreeNode/TreeNode';
var waitTime = 500;
var wait = function (ms) { return new Promise(function (r, j) { return setTimeout(r, ms); }); };
var onResolveItems = function (item) { return __awaiter(void 0, void 0, void 0, function () {
    var items, i, i;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, wait(waitTime)];
            case 1:
                _a.sent();
                items = [];
                if (item === null) {
                    for (i = 0; i < 10; i++) {
                        items.push({
                            key: i.toString(),
                            label: "Label-" + i.toString()
                        });
                    }
                }
                else {
                    for (i = 0; i < 10; i++) {
                        items.push({
                            key: item.key + '/' + i.toString(),
                            label: item.label + '/' + i.toString(),
                            isFolder: i % 2 === 0
                        });
                    }
                }
                return [2 /*return*/, [items, null]];
        }
    });
}); };
var onResolveItemsWithFailures = function () {
    var failedItems = [];
    return (function (item) { return __awaiter(void 0, void 0, void 0, function () {
        var items, i, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, wait(waitTime)];
                case 1:
                    _a.sent();
                    items = [];
                    if (item === null) {
                        for (i = 0; i < 10; i++) {
                            items.push({
                                key: i.toString(),
                                label: "Label-" + i.toString()
                            });
                        }
                    }
                    else if (failedItems.indexOf(item) >= 0) {
                        // Resolve items after failing initially.
                        for (i = 0; i < 10; i++) {
                            items.push({
                                key: item.key + '/' + i.toString(),
                                label: item.label + '/' + i.toString(),
                                isFolder: i % 2 === 0
                            });
                        }
                    }
                    else {
                        failedItems.push(item);
                        throw new Error();
                    }
                    return [2 /*return*/, [items, null]];
            }
        });
    }); });
};
var defaultStrings = {
    listAriaLabel: 'list aria label',
    moreCommandsAriaLabel: 'more commands aria label'
};
describe('AsyncTree', function () {
    beforeAll(function () {
        setIconOptions({ disableWarnings: true });
    });
    it('dynamically loads all the "root" items when mounted', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItems, strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    expect(wrapper.find(TreeNode).length).toBe(10);
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
    it('correctly renders dynamically loaded items', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItems, strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    wrapper.find(TreeNode).forEach(function (c, index) {
                        expect(c.text()).toBe('Label-' + index);
                    });
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
    it('shows a "Loading" sub-item with a spinner while dynamically expanding an item', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper, firstNode, loadingSubItem;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItems, strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    firstNode = wrapper.find(TreeNode).at(0);
                    // Expand the first node
                    firstNode.find(ExpandIcon).simulate('click');
                    expect(wrapper.find(TreeNode).length).toBe(11);
                    loadingSubItem = wrapper.find(TreeNode).at(1);
                    expect(loadingSubItem.find(Spinner).length).toBe(1);
                    expect(loadingSubItem.text()).toBe('Loading...');
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
    it('hides the "Loading" sub-item after dynamically expanding an item', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper, firstNode;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItems, strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    firstNode = wrapper.find(TreeNode).at(0);
                    // Expand the first node
                    firstNode.find(ExpandIcon).simulate('click');
                    expect(wrapper.find(TreeNode).length).toBe(11);
                    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(1);
                    // Wait for list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 2:
                    // Wait for list of items to load.
                    _a.sent();
                    wrapper.update();
                    expect(wrapper.find(TreeNode).length).toBe(20);
                    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(0);
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
    it('shows multiple "Loading" sub-items spinning concurrently while dynamically expanding multiple items', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper, _loop_1, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItems, strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(0);
                    wrapper.update();
                    _loop_1 = function (i) {
                        wrapper
                            .findWhere(function (x) { return x.key() === i.toString(); })
                            .find(ExpandIcon)
                            .simulate('click');
                    };
                    // Expand all nodes
                    for (i = 0; i < 10; i++) {
                        _loop_1(i);
                    }
                    wrapper.update();
                    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(10);
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
    it('shows an "Error" sub-item if an error occurs while dynamically expanding an item', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper, firstNode, errorSubItem;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItemsWithFailures(), strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    firstNode = wrapper.find(TreeNode).at(0);
                    // Expand the first node
                    firstNode.find(ExpandIcon).simulate('click');
                    // Wait for list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 2:
                    // Wait for list of items to load.
                    _a.sent();
                    wrapper.update();
                    expect(wrapper.find(TreeNode).length).toBe(11);
                    errorSubItem = wrapper.find(TreeNode).at(1);
                    expect(errorSubItem.text()).toBe('Error loading. Try again');
                    expect(errorSubItem.find(IconBase).length).toBe(1);
                    expect(errorSubItem.find(IconBase).at(0).props().iconName).toBe('ErrorBadge');
                    expect(errorSubItem.find(Link).at(0).text()).toBe('Try again');
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
    it('allows the user to retry loading items if an error occurs while dynamically expanding an item', function () { return __awaiter(void 0, void 0, void 0, function () {
        var wrapper, firstNode, errorSubItem, retryLink, loadingSubItem;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    wrapper = mount(React.createElement(AsyncTree, { onResolveItems: onResolveItemsWithFailures(), strings: defaultStrings }));
                    // Wait for initial list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 1:
                    // Wait for initial list of items to load.
                    _a.sent();
                    wrapper.update();
                    firstNode = wrapper.find(TreeNode).at(0);
                    // Expand the first node
                    firstNode.find(ExpandIcon).simulate('click');
                    // Wait for list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 2:
                    // Wait for list of items to load.
                    _a.sent();
                    wrapper.update();
                    expect(wrapper.find(TreeNode).length).toBe(11);
                    errorSubItem = wrapper.find(TreeNode).at(1);
                    expect(errorSubItem.find(Link).length).toBe(1);
                    retryLink = errorSubItem.find(Link).at(0);
                    retryLink.simulate('click');
                    // The "Error" sub-item is no longer present.
                    errorSubItem = wrapper.find(TreeNode).at(1);
                    expect(errorSubItem.text()).not.toBe('Error loading. Try again');
                    loadingSubItem = wrapper.find(TreeNode).at(1);
                    expect(loadingSubItem.find(Spinner).length).toBe(1);
                    expect(loadingSubItem.text()).toBe('Loading...');
                    // Wait for list of items to load.
                    return [4 /*yield*/, wait(waitTime + waitTime / 2)];
                case 3:
                    // Wait for list of items to load.
                    _a.sent();
                    wrapper.update();
                    expect(wrapper.find(TreeNode).length).toBe(20);
                    // Loading sub-item is no longer present.
                    loadingSubItem = wrapper.find(TreeNode).at(1);
                    expect(loadingSubItem.text()).not.toBe('Loading...');
                    expect(wrapper.find(TreeNode).find(Spinner).length).toBe(0);
                    wrapper.unmount();
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=AsyncTree.test.js.map