/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __assign, __extends, __spreadArrays } from "tslib";
import { ContextualMenuItemType, ContextualMenu as FabricContextualMenu } from '@fluentui/react/lib/ContextualMenu';
import { BaseComponent, elementContains, KeyCodes } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
var ContextualMenu = /** @class */ (function (_super) {
    __extends(ContextualMenu, _super);
    function ContextualMenu(props) {
        var _this = _super.call(this, props) || this;
        /**
         * Set this BaseComponent._skipComponentRefResolution to true, bypassing resolution of componentRef.
         */
        _this._skipComponentRefResolution = true;
        _this._activeElement = document.activeElement;
        _this._timers = [];
        _this._onDismiss = function (ev, dismissAll) {
            // If focus remains in the menu when it is dismissed we will set focus back to the
            // previously focused element.
            if (_this._activeElement && _this.contains(document.activeElement)) {
                _this._activeElement.focus();
            }
            _this.props.onDismiss(ev, dismissAll);
        };
        _this.state = ContextualMenu._getStateFromProps(props, {
            displayItems: _this.props.items ? ContextualMenu._arrangeItems(_this.props.items) : [],
            loadingTimeout: _this._setTimeout(function () {
                _this.setState({ loadingTimeout: undefined });
            }, 100)
        });
        return _this;
    }
    ContextualMenu._getStateFromProps = function (nextProps, prevState) {
        var newState = prevState;
        if (nextProps.isSubMenu) {
            var itemsChanged = prevState.displayItems.length !== nextProps.items.length;
            if (!itemsChanged) {
                // Check if same items exist
                itemsChanged = prevState.displayItems.some(function (value) {
                    return !nextProps.items.some(function (nextItem) { return nextItem.key === value.key; });
                });
            }
            if (itemsChanged) {
                newState.displayItems = nextProps.items ? ContextualMenu._arrangeItems(nextProps.items) : [];
            }
        }
        return newState;
    };
    ContextualMenu._arrangeItems = function (items) {
        var shouldSortMenuItems = items.some(function (x) { return x.rank >= 0; });
        items = __spreadArrays(items);
        if (shouldSortMenuItems) {
            ContextualMenu._sortItems(items);
        }
        ContextualMenu._removeConsecutiveSeparators(items);
        return items;
    };
    ContextualMenu._sortItems = function (items) {
        // This is not a stable sort. If we pass items with the same rank, we may not always get them back in the
        // same order.
        items.sort(function (a, b) {
            var aRank = a.rank || Number.MAX_VALUE;
            var bRank = b.rank || Number.MAX_VALUE;
            return aRank - bRank;
        });
    };
    ContextualMenu._removeConsecutiveSeparators = function (items) {
        var lastWasSeparator = true;
        for (var menuItemIndex = items.length - 1; menuItemIndex >= 0; menuItemIndex--) {
            var currentIsSeparator = items[menuItemIndex].itemType === ContextualMenuItemType.Divider || items[menuItemIndex].name === '-';
            if (currentIsSeparator && lastWasSeparator) {
                items.splice(menuItemIndex, 1);
            }
            lastWasSeparator = currentIsSeparator;
        }
    };
    ContextualMenu.getDerivedStateFromProps = function (nextProps, prevState) {
        if (!prevState) {
            return null;
        }
        return ContextualMenu._getStateFromProps(nextProps, prevState);
    };
    ContextualMenu.prototype.render = function () {
        if (this.state.loadingTimeout) {
            return null;
        }
        var _a = this.props, className = _a.className, directionalHint = _a.directionalHint, _b = _a.gapSpace, gapSpace = _b === void 0 ? 5 : _b, ariaLabel = _a.ariaLabel, _c = _a.items, items = _c === void 0 ? [] : _c;
        var displayItems = this.state.displayItems;
        var hasIcons = !!(items && items.some(function (item) { return !!item.icon || !!item.iconProps; }));
        items.forEach(function (menuItem) {
            menuItem.menuHasIcons = hasIcons;
            if (hasIcons && !menuItem.iconProps && !menuItem.icon) {
                menuItem.iconProps = { iconName: '' };
            }
        });
        return (React.createElement(FabricContextualMenu, __assign({ gapSpace: gapSpace, directionalHint: directionalHint }, this.props, { items: displayItems, ariaLabel: ariaLabel, className: className, onDismiss: this._onDismiss })));
    };
    ContextualMenu.prototype.componentDidMount = function () {
        var _this = this;
        // Ensure we only have a single root menu open, ignore global processing for sub-menus.
        if (!this.props.isSubMenu) {
            if (ContextualMenu._activeMenu) {
                ContextualMenu._activeMenu.dismiss(null, true);
            }
            ContextualMenu._activeMenu = this;
        }
        this._targetElement = this.props.target;
        this.setState({ loadingTimeout: undefined });
        if (this.props.mouseLeaveDelayMs) {
            // Tracks the mousemove on the document to close if the mouse is outside the menu for a period of time.
            this._events.on(document.body, 'mousemove', function (event) {
                if ((_this._targetElement && _this._targetElement.contains(event.target)) ||
                    _this.contains(event.target)) {
                    if (_this.closeTimeout) {
                        _this._clearTimeout(_this.closeTimeout);
                        delete _this.closeTimeout;
                    }
                }
                else {
                    if (!_this.closeTimeout) {
                        _this.closeTimeout = _this._setTimeout(function () {
                            delete _this.closeTimeout;
                            _this.dismiss(event, true);
                        }, _this.props.mouseLeaveDelayMs || 0);
                    }
                }
            });
        }
        this._events.on(document, 'keydown', function (event) {
            // If a keystroke was made and we are not focused we need to close the menu.
            // We need to look at shouldFocusOnMount, since it may be an empty menu and we dont want it closed.
            // Don't close the menu for control keys (shift, alt, ctrl)
            if (event.which !== KeyCodes.shift &&
                event.which !== KeyCodes.ctrl &&
                event.which !== KeyCodes.alt &&
                !_this.props.isSubMenu &&
                !_this.props.shouldFocusOnMount &&
                !_this.contains(document.activeElement)) {
                _this.dismiss(event, true);
            }
        });
    };
    ContextualMenu.prototype.componentWillUnmount = function () {
        _super.prototype.componentWillUnmount.call(this);
        if (this.state.loadingTimeout) {
            this._clearTimeout(this.state.loadingTimeout);
        }
        if (this._timers) {
            for (var _i = 0, _a = this._timers; _i < _a.length; _i++) {
                var timer = _a[_i];
                window.clearTimeout(timer);
            }
            this._timers = [];
        }
        // If we are the active root menu we can clear our state on closure.
        if (ContextualMenu._activeMenu === this) {
            delete ContextualMenu._activeMenu;
        }
    };
    ContextualMenu.prototype.contains = function (element) {
        return elementContains(ReactDOM.findDOMNode(this), element);
    };
    ContextualMenu.prototype.dismiss = function (reason, dismissAll) {
        if (this.props.onDismiss) {
            this.props.onDismiss(reason, true);
        }
    };
    ContextualMenu.prototype._clearTimeout = function (timeoutId) {
        if (this._timers) {
            var timerIndex = this._timers.indexOf(timeoutId);
            this._timers.splice(timerIndex, 1);
        }
        window.clearTimeout(timeoutId);
    };
    ContextualMenu.prototype._setTimeout = function (callback, milliseconds) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var timerId = window.setTimeout.apply(window, __spreadArrays([callback, milliseconds], args));
        if (!this._timers) {
            this._timers = [];
        }
        this._timers.push(timerId);
        return timerId;
    };
    return ContextualMenu;
}(BaseComponent));
export { ContextualMenu };
//# sourceMappingURL=ContextualMenu.js.map