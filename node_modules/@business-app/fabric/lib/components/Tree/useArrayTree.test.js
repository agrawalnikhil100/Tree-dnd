/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { act, renderHook } from '@testing-library/react-hooks';
import { useArrayTree } from './useArrayTree';
function createRandomItem(level) {
    var itemId = Math.floor(Math.random() * 1000);
    return {
        key: "item-" + itemId,
        label: "Item " + itemId,
        level: level
    };
}
function createRandomItems(itemCount, level) {
    if (itemCount <= 0) {
        throw new Error('itemCount');
    }
    var items = [];
    for (var i = 0; i < itemCount; i++) {
        items.push(createRandomItem(level));
    }
    return items;
}
describe('useArrayTree', function () {
    it('can be initialized with a collection of top level items', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var items = result.current.items;
        expect(items).toEqual(topLevelItems);
    });
    it('can be initialized with an empty collection of top level items', function () {
        var result = renderHook(function () { return useArrayTree([]); }).result;
        var items = result.current.items;
        expect(items).toEqual([]);
    });
    it('can be initialized without a collection of top level items', function () {
        var result = renderHook(function () { return useArrayTree(); }).result;
        var items = result.current.items;
        expect(items).toEqual([]);
    });
    it("throws if the 'level' property of any of the top level items is not equal to 0 during initialization", function () {
        var topLevelItems = createRandomItems(10, 0);
        topLevelItems[3].level = 1;
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var error = result.error;
        expect(error).not.toBeUndefined();
    });
    it('calling getChildrenOf with [null] argument returns the top level items', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var getChildrenOf = result.current.getChildrenOf;
        expect(getChildrenOf(null)).toEqual(topLevelItems);
    });
    it('calling getChildrenOf with a leaf item returns an empty array', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var getChildrenOf = result.current.getChildrenOf;
        expect(getChildrenOf(topLevelItems[0])).toEqual([]);
    });
    it('calling getChildrenOf returns only the direct children of an item', function () {
        var _a;
        var topLevelItems = createRandomItems(10, 0);
        var secondLevelItems = createRandomItems(10, 1);
        var firstSecondLevelItem = secondLevelItems[0];
        var thirdLevelItems = createRandomItems(10, 2);
        var firstTopLevelItem = topLevelItems[0];
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var _b = result.current, appendChildrenTo = _b.appendChildrenTo, getChildrenOf = _b.getChildrenOf;
        expect(getChildrenOf(firstTopLevelItem)).toEqual([]);
        act(function () {
            appendChildrenTo(firstTopLevelItem, secondLevelItems);
            appendChildrenTo(firstSecondLevelItem, thirdLevelItems);
        });
        var items = result.current.items;
        (_a = result.current, appendChildrenTo = _a.appendChildrenTo, getChildrenOf = _a.getChildrenOf);
        expect(items.length).toBe(topLevelItems.length + secondLevelItems.length + thirdLevelItems.length);
        expect(getChildrenOf(firstTopLevelItem)).toEqual(secondLevelItems);
    });
    it('calling getChildrenOf throws when called with an item that is not present in the tree', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var getChildrenOf = result.current.getChildrenOf;
        var item = createRandomItem(0);
        expect(function () { return getChildrenOf(item); }).toThrowError('item');
    });
    it('calling appendChildrenTo with a [null] item inserts a collection of items after the last top level element', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var appendChildrenTo = result.current.appendChildrenTo;
        var moreTopLevelElements = createRandomItems(10, 0);
        act(function () { return appendChildrenTo(null, moreTopLevelElements); });
        var items = result.current.items;
        expect(items).toEqual(topLevelItems.concat(moreTopLevelElements));
    });
    it('calling appendChildrenTo inserts a collection of items after the last child of an item', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var appendChildrenTo = result.current.appendChildrenTo;
        var children = createRandomItems(10, 1);
        act(function () { return appendChildrenTo(topLevelItems[0], children); });
        var getChildrenOf = result.current.getChildrenOf;
        expect(getChildrenOf(topLevelItems[0])).toEqual(children);
    });
    it('calling appendChildrenTo throws when called with a child that is not at a level below the item', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var appendChildrenTo = result.current.appendChildrenTo;
        var children = createRandomItems(10, 0);
        expect(function () { return appendChildrenTo(topLevelItems[0], children); }).toThrowError('children');
    });
    it('calling remove removes an item and all its children', function () {
        var topLevelItems = createRandomItems(10, 0);
        var secondLevelItems = createRandomItems(10, 1);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var _a = result.current, appendChildrenTo = _a.appendChildrenTo, remove = _a.remove;
        act(function () {
            appendChildrenTo(topLevelItems[0], secondLevelItems);
            remove(topLevelItems[0]);
        });
        var items = result.current.items;
        expect(items.indexOf(topLevelItems[0])).not.toBeGreaterThanOrEqual(0);
        expect(items.length).toEqual(topLevelItems.length - 1);
        expect(items).toEqual(topLevelItems.slice(1));
    });
    it('calling replace replaces an item but not its children', function () {
        var topLevelItems = createRandomItems(10, 0);
        var secondLevelItems = createRandomItems(10, 1);
        var replacementItem = createRandomItem(0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var _a = result.current, appendChildrenTo = _a.appendChildrenTo, replace = _a.replace;
        act(function () {
            appendChildrenTo(topLevelItems[0], secondLevelItems);
            replace(topLevelItems[0], replacementItem);
        });
        var _b = result.current, items = _b.items, getChildrenOf = _b.getChildrenOf;
        expect(items.indexOf(topLevelItems[0])).not.toBeGreaterThanOrEqual(0);
        expect(items.indexOf(replacementItem)).toBeGreaterThanOrEqual(0);
        expect(getChildrenOf(replacementItem)).toEqual(secondLevelItems);
    });
    it('calling replace throws when called with a replacement item that has a different level', function () {
        var topLevelItems = createRandomItems(10, 0);
        var secondLevelItem = createRandomItems(1, 1)[0];
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var replace = result.current.replace;
        expect(function () {
            replace(topLevelItems[0], secondLevelItem);
        }).toThrow('replacementItem');
    });
    it('calling refresh returns a different array with the same items', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var _a = result.current, itemsBefore = _a.items, refresh = _a.refresh;
        expect(itemsBefore).toEqual(topLevelItems);
        act(function () {
            refresh();
        });
        var itemsAfter = result.current.items;
        expect(itemsAfter).not.toBe(itemsBefore);
        expect(itemsAfter).toEqual(topLevelItems);
    });
    it('calling clear removes all items from the tree', function () {
        var topLevelItems = createRandomItems(10, 0);
        var result = renderHook(function () { return useArrayTree(topLevelItems); }).result;
        var clear = result.current.clear;
        act(function () {
            clear();
        });
        var items = result.current.items;
        expect(items.length).toBe(0);
    });
});
//# sourceMappingURL=useArrayTree.test.js.map