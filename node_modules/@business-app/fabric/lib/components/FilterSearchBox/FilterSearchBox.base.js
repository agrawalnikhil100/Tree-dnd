/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __decorate, __extends } from "tslib";
import * as React from 'react';
import { DefaultButton } from '@fluentui/react/lib/Button';
import { DirectionalHint } from '@fluentui/react/lib/Callout';
import { SearchBox } from '@fluentui/react/lib/SearchBox';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import { TooltipHost } from '@fluentui/react/lib/Tooltip';
import { BaseComponent, classNamesFunction, customizable } from '@fluentui/react/lib/Utilities';
var getClassNames = classNamesFunction();
var FilterSearchBoxBase = /** @class */ (function (_super) {
    __extends(FilterSearchBoxBase, _super);
    function FilterSearchBoxBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isHovering: false,
            isSearchBoxActive: false,
            isFilterMenuOpen: false
        };
        _this._containerRef = React.createRef();
        _this._searchBoxRef = React.createRef();
        _this._filterButtonRef = React.createRef();
        _this._onContainerMouseEnter = function () {
            _this.setState({ isHovering: true });
        };
        _this._onContainerMouseLeave = function () {
            _this.setState({ isHovering: false });
        };
        _this._onSearchBoxFocus = function () {
            _this.setState({ isSearchBoxActive: true });
        };
        _this._onSearchBoxBlur = function () {
            _this.setState({ isSearchBoxActive: false });
        };
        _this._onFilterMenuItemClick = function (_, menuItem) {
            var onFilterChange = _this.props.onFilterChange;
            if (onFilterChange) {
                onFilterChange(menuItem.key);
            }
        };
        _this._onFilterMenuOpened = function () {
            _this.setState({ isFilterMenuOpen: true });
        };
        _this._onFilterMenuDismissed = function () {
            _this.setState({ isFilterMenuOpen: false, isHovering: false });
        };
        return _this;
    }
    FilterSearchBoxBase.prototype.focus = function () {
        if (this._searchBoxRef.current) {
            this._searchBoxRef.current.focus();
        }
    };
    FilterSearchBoxBase.prototype.dismissMenu = function () {
        if (this._filterButtonRef.current) {
            this._filterButtonRef.current.dismissMenu();
        }
    };
    FilterSearchBoxBase.prototype.render = function () {
        this._classNames = this._getClassNames(this.props);
        var _a = this.state, isHovering = _a.isHovering, isSearchBoxActive = _a.isSearchBoxActive, isFilterMenuOpen = _a.isFilterMenuOpen;
        var isActive = isHovering || isSearchBoxActive || isFilterMenuOpen;
        return (React.createElement("div", { ref: this._containerRef, className: mergeStyles(this._classNames.root, isActive && this._classNames.active), onMouseEnter: this._onContainerMouseEnter, onMouseLeave: this._onContainerMouseLeave },
            this._renderSearchBox(),
            this._renderFilterSelection()));
    };
    FilterSearchBoxBase.prototype._renderSearchBox = function () {
        var _a = this.props, searchText = _a.searchText, onSearchTextChange = _a.onSearchTextChange, _b = _a.strings, searchBoxPlaceholder = _b.searchBoxPlaceholder, searchBoxClearButtonTitle = _b.searchBoxClearButtonTitle;
        return (React.createElement(SearchBox, { componentRef: this._searchBoxRef, placeholder: searchBoxPlaceholder, ariaLabel: searchBoxPlaceholder, styles: {
                root: this._classNames.searchBox,
                field: this._classNames.searchBoxField
            }, onFocus: this._onSearchBoxFocus, onBlur: this._onSearchBoxBlur, onChange: onSearchTextChange, clearButtonProps: { title: searchBoxClearButtonTitle }, value: searchText }));
    };
    FilterSearchBoxBase.prototype._renderFilterSelection = function () {
        var _a = this.props, _b = _a.filters, filters = _b === void 0 ? [] : _b, selectedFilterKey = _a.selectedFilterKey, filterButtonIconName = _a.filterButtonIconName, filterCalloutMatchComponentWidth = _a.filterCalloutMatchComponentWidth, filterButtonTooltipText = _a.strings.filterButtonTooltipText;
        // If less than two filters, do not render chooser
        if (filters.length < 2) {
            return null;
        }
        // Find selected filter text and map to IContextualMenuItem in a single loop.
        var menuItems = [];
        var selectedFilterText = '';
        filters.forEach(function (filter) {
            var item = {
                key: filter.key,
                text: filter.text,
                canCheck: true
            };
            if (filter.key === selectedFilterKey) {
                selectedFilterText = filter.text;
                item.checked = true;
            }
            menuItems.push(item);
        });
        // If filterButtonIconName is provided, do not render the text.
        var iconProps;
        var ariaLabel = selectedFilterText;
        if (!!filterButtonIconName) {
            selectedFilterText = '';
            iconProps = {
                iconName: filterButtonIconName
            };
        }
        var menuCalloutWidth;
        var calloutPropsStyles;
        if (this._containerRef.current) {
            menuCalloutWidth = this._containerRef.current.clientWidth;
            calloutPropsStyles = {
                root: {
                    maxWidth: menuCalloutWidth
                }
            };
        }
        var buttonRootStyle = filterButtonTooltipText
            ? this._classNames.filterButtonRootInTooltipHost
            : this._classNames.filterButtonRoot;
        var defaultButton = (React.createElement(DefaultButton, { componentRef: this._filterButtonRef, styles: {
                root: buttonRootStyle,
                label: selectedFilterText
                    ? this._classNames.filterButtonLabel
                    : this._classNames.filterButtonNoLabel,
                textContainer: this._classNames.filterButtonTextContainer
            }, text: selectedFilterText, iconProps: iconProps, ariaLabel: ariaLabel, menuProps: {
                items: menuItems,
                isBeakVisible: false,
                directionalHint: DirectionalHint.bottomRightEdge,
                onItemClick: this._onFilterMenuItemClick,
                onMenuOpened: this._onFilterMenuOpened,
                onMenuDismissed: this._onFilterMenuDismissed,
                gapSpace: 1,
                calloutProps: {
                    styles: calloutPropsStyles,
                    target: this._containerRef.current,
                    calloutWidth: filterCalloutMatchComponentWidth ? menuCalloutWidth : undefined
                }
            } }));
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: this._classNames.separator }),
            filterButtonTooltipText ? (React.createElement(TooltipHost, { content: filterButtonTooltipText, calloutProps: { gapSpace: 0 }, styles: {
                    root: this._classNames.tooltipHost
                } }, defaultButton)) : (
            // If there is no tooltipText, don't render tooltip component
            React.createElement(React.Fragment, null,
                " ",
                defaultButton,
                " "))));
    };
    FilterSearchBoxBase.prototype._getClassNames = function (props) {
        var theme = props.theme;
        return getClassNames(props.styles, {
            theme: theme
        });
    };
    FilterSearchBoxBase = __decorate([
        customizable('FilterSearchBox', ['theme', 'styles'])
    ], FilterSearchBoxBase);
    return FilterSearchBoxBase;
}(BaseComponent));
export { FilterSearchBoxBase };
//# sourceMappingURL=FilterSearchBox.base.js.map