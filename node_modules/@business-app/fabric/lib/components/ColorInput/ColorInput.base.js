/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __assign } from "tslib";
import { IconButton } from '@fluentui/react/lib/Button';
import { ColorPicker } from '@fluentui/react/lib/ColorPicker';
import { getColorFromString } from '@fluentui/react/lib/Color';
import { Label } from '@fluentui/react/lib/Label';
import { mergeStyles } from '@fluentui/react/lib/Styling';
import { TextField } from '@fluentui/react/lib/TextField';
import { TooltipHost } from '@fluentui/react/lib/Tooltip';
import { getId } from '@fluentui/react/lib/Utilities';
import { classNamesFunction } from '@fluentui/react/lib/Utilities';
import * as React from 'react';
import { useCallback, useEffect, useState } from 'react';
import { defaultColorPickerStyles, defaultTooltipIconProps, defaultTooltipIconStyles } from '.';
var getClassNames = classNamesFunction();
function getColorInputClassNames(props) {
    return getClassNames(props.styles, props);
}
export var ColorInputBase = function (props) {
    var _a, _b;
    var tooltipIconProps = props.tooltipIconProps, colorBoxProps = props.colorBoxProps, colorTextFieldProps = props.colorTextFieldProps, colorPickerProps = props.colorPickerProps, label = props.label, tooltipProps = props.tooltipProps, styles = props.styles, theme = props.theme, showColorPicker = props.showColorPicker, scrollToBottom = props.scrollToBottom;
    var onTextFieldChange = useCallback(function (ev, newValue) {
        setBoxColor(ev.target.value);
    }, []);
    var onTextFieldBlur = useCallback(function (ev) {
        var newValue = ev.target.value;
        setNewColorPickerProps(newValue);
    }, []);
    var onColorChange = useCallback(function (ev, selectedColor) {
        setBoxColor(selectedColor.str);
        setNewColorPickerProps(selectedColor.str);
    }, []);
    var onColorBoxClick = useCallback(function (event) {
        setColorPickerVisibility(function (value) { return !value; });
    }, []);
    var setNewColorPickerProps = function (newColor) {
        var newProps = __assign({}, pickerProps);
        newProps.color = newColor;
        setColorPickerColorProps(newProps);
    };
    var updatedColorBoxProps = __assign(__assign({}, colorBoxProps), { onClick: function (ev) {
            if (showColorPicker === undefined) {
                onColorBoxClick(ev);
            }
            if (colorBoxProps === null || colorBoxProps === void 0 ? void 0 : colorBoxProps.onClick) {
                colorBoxProps.onClick(ev);
            }
        } });
    var updatedColorTextFieldProps = __assign(__assign({}, colorTextFieldProps), { onChange: function (ev, newValue) {
            var _a;
            onTextFieldChange(ev);
            (_a = colorTextFieldProps === null || colorTextFieldProps === void 0 ? void 0 : colorTextFieldProps.onChange) === null || _a === void 0 ? void 0 : _a.call(colorTextFieldProps, ev, newValue);
        }, onBlur: function (ev) {
            var _a;
            onTextFieldBlur(ev);
            (_a = colorTextFieldProps === null || colorTextFieldProps === void 0 ? void 0 : colorTextFieldProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(colorTextFieldProps, ev);
        } });
    var mergedCpRootStyle;
    if (colorPickerProps.styles && colorPickerProps.styles.root) {
        mergedCpRootStyle = mergeStyles(defaultColorPickerStyles.root, colorPickerProps.styles.root);
    }
    else {
        mergedCpRootStyle = mergeStyles(defaultColorPickerStyles.root);
    }
    var updatedColorPickerProps = __assign(__assign({}, colorPickerProps), { onChange: function (ev, pickerColor) {
            onColorChange(ev, pickerColor);
            if (colorPickerProps.onChange) {
                colorPickerProps.onChange(ev, pickerColor);
            }
        }, styles: __assign(__assign({}, colorPickerProps.styles), { root: mergedCpRootStyle }) });
    var mergedTooltipIconRootStyle;
    if (((_a = tooltipIconProps === null || tooltipIconProps === void 0 ? void 0 : tooltipIconProps.iconProps) === null || _a === void 0 ? void 0 : _a.styles) &&
        tooltipIconProps.iconProps.styles.root) {
        mergedTooltipIconRootStyle = mergeStyles(defaultTooltipIconStyles.root, tooltipIconProps.iconProps.styles.root);
    }
    else {
        mergedTooltipIconRootStyle = mergeStyles(defaultTooltipIconStyles.root);
    }
    var updatedTooltipIconProps;
    if (tooltipIconProps) {
        if (tooltipIconProps.iconProps) {
            updatedTooltipIconProps = __assign({}, tooltipIconProps);
            updatedTooltipIconProps.iconProps = __assign(__assign({}, updatedTooltipIconProps.iconProps), { styles: __assign(__assign({}, updatedTooltipIconProps.iconProps.styles), { root: mergedTooltipIconRootStyle }), iconName: updatedTooltipIconProps.iconProps.iconName
                    ? updatedTooltipIconProps.iconProps.iconName
                    : defaultTooltipIconProps.iconProps.iconName });
        }
        else {
            updatedTooltipIconProps = __assign(__assign({}, defaultTooltipIconProps), tooltipIconProps);
        }
    }
    else {
        updatedTooltipIconProps = __assign({}, defaultTooltipIconProps);
    }
    var color = colorPickerProps.color;
    var classNames = getClassNames(styles, { theme: theme });
    var colorInputId = getId('colorInput');
    var tooltipId = getId('tooltip');
    var _c = useState(color), boxColor = _c[0], setBoxColor = _c[1];
    var _d = useState(updatedColorPickerProps), pickerProps = _d[0], setColorPickerColorProps = _d[1];
    var _e = useState(false), isColorPickerVisible = _e[0], setColorPickerVisibility = _e[1];
    var colorPickerDivRef = null;
    var executeScroll = function () { return scrollToRef(colorPickerDivRef); };
    useEffect(function () {
        if (isColorPickerVisible && scrollToBottom) {
            executeScroll();
        }
    }, [isColorPickerVisible]);
    useEffect(function () {
        if (showColorPicker !== undefined) {
            setColorPickerVisibility(showColorPicker);
        }
    }, [showColorPicker]);
    return (React.createElement("div", { className: classNames.root },
        React.createElement("div", { className: classNames.labelContainer },
            React.createElement(Label, { className: classNames.label, htmlFor: colorInputId }, label),
            React.createElement(TooltipHost, __assign({ id: tooltipId, calloutProps: { gapSpace: 5 } }, tooltipProps),
                React.createElement(IconButton, __assign({ "aria-describedby": tooltipId, className: classNames.iconTooltip }, updatedTooltipIconProps)))),
        React.createElement("div", { className: classNames.container },
            React.createElement(IconButton, __assign({ className: ((_b = props.colorBoxProps) === null || _b === void 0 ? void 0 : _b.disabled) ? classNames.colorBoxDisabled : classNames.colorBox, "aria-expanded": isColorPickerVisible, onRenderIcon: function () {
                    return onRenderIcon(boxColor, props);
                } }, updatedColorBoxProps)),
            React.createElement(TextField, __assign({ className: classNames.colorTextField, value: getColor(boxColor) }, updatedColorTextFieldProps))),
        isColorPickerVisible && (React.createElement(React.Fragment, null,
            React.createElement(ColorPicker, __assign({ className: classNames.colorPicker }, pickerProps)),
            React.createElement("div", { style: { float: 'left', clear: 'both' }, ref: function (el) {
                    colorPickerDivRef = el;
                } })))));
};
var getColor = function (color) {
    color = typeof color === 'string' ? color : color.str;
    var value = getColorFromString(color);
    return value ? (value.str.indexOf('#') === 0 ? value.str : '#' + value.hex) : color;
};
export function isValidColor(inputColor) {
    var color = typeof inputColor === 'string' ? inputColor : inputColor.str;
    var value = getColorFromString(color);
    return value ? value.str : undefined;
}
var scrollToRef = function (ref) {
    if (ref === null || ref === void 0 ? void 0 : ref.scrollIntoView) {
        ref.scrollIntoView({ behavior: 'smooth' });
    }
};
var onRenderIcon = function (boxColor, props) {
    var classNames = getColorInputClassNames(props);
    var iconColor = isValidColor(boxColor);
    if (iconColor) {
        return (React.createElement("svg", { className: classNames.colorBoxSvg, "aria-hidden": "true", viewBox: "0 0 20 20", fill: iconColor, xmlns: "http://www.w3.org/2000/svg" },
            React.createElement("rect", { width: "100%", height: "100%" })));
    }
    else {
        return getNoColorIcon(props);
    }
};
var getNoColorIcon = function (props) {
    var classNames = getColorInputClassNames(props);
    return (React.createElement("svg", { className: classNames.colorBoxSvg, "aria-hidden": "true", viewBox: "0 0 28 28", fill: "white", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("rect", { width: "100%", height: "100%" }),
        React.createElement("line", { x1: "1.41421", y1: "2", x2: "26", y2: "26.5858", stroke: "#A80000", "stroke-width": "2", "stroke-linecap": "round" })));
};
//# sourceMappingURL=ColorInput.base.js.map