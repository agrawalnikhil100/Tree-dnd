/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __assign, __extends } from "tslib";
import { mount } from 'enzyme';
import * as React from 'react';
import { IconButton } from '@fluentui/react/lib/Button';
import { FilterSearchBox } from '../FilterSearchBox';
import { defaultFilterIconNameFunction, FilterSearchViewsBase } from './index';
var flatItems = [{ value: 1 }, { value: 2 }];
var nestedItems = [
    { value: 1, children: [{ value: 11 }, { value: 12 }] },
    { value: 2, children: [{ value: 21 }, { value: 22 }] }
];
var strings = {
    searchBoxPlaceholder: '',
    allItemsFilterItemText: ''
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getInstance(wrapper) {
    return wrapper.childAt(0).instance();
}
function getState(wrapper) {
    return getInstance(wrapper).state;
}
describe('FilterSearchViews', function () {
    it('calls shouldFilterItem for every item', function () {
        var shouldFilterItemFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: shouldFilterItemFn, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings }));
        expect(shouldFilterItemFn).toHaveBeenCalledTimes(flatItems.length);
        shouldFilterItemFn = jest.fn();
        wrapper.setProps({
            items: nestedItems,
            shouldFilterItem: shouldFilterItemFn
        });
        expect(shouldFilterItemFn).toHaveBeenCalledTimes(nestedItems.length + nestedItems[0].children.length + nestedItems[1].children.length);
        wrapper.unmount();
    });
    it('calls onRenderView for the selected view', function () {
        var view1RenderFn = jest.fn();
        var view2RenderFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: [
                { key: 'one', iconName: '', text: 'One', onRenderView: view1RenderFn },
                { key: 'two', iconName: '', text: 'Two', onRenderView: view2RenderFn }
            ], strings: strings }));
        expect(view1RenderFn).toHaveBeenCalledTimes(1);
        expect(view2RenderFn).toHaveBeenCalledTimes(0);
        var viewsButton = wrapper.find(IconButton);
        expect(viewsButton.length).toBe(1);
        viewsButton.props().onClick(null);
        expect(view1RenderFn).toHaveBeenCalledTimes(1);
        expect(view2RenderFn).toHaveBeenCalledTimes(1);
        wrapper.unmount();
    });
    it('calls onRenderView with correct information', function () {
        var filters = [{ key: 'a', text: 'A' }];
        var viewRenderFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: [{ key: 'one', iconName: '', text: 'One', onRenderView: viewRenderFn }], filters: filters, strings: strings }));
        expect(viewRenderFn).toHaveBeenCalledTimes(1);
        expect(viewRenderFn).toHaveBeenLastCalledWith(flatItems, '', null);
        var searchBox = wrapper.find(FilterSearchBox);
        expect(searchBox.length).toBe(1);
        searchBox.prop('onSearchTextChange')(null, 'Some search');
        expect(viewRenderFn).toHaveBeenCalledTimes(2);
        expect(viewRenderFn).toHaveBeenLastCalledWith(flatItems, 'Some search', null);
        searchBox.prop('onFilterChange')('a');
        expect(viewRenderFn).toHaveBeenCalledTimes(3);
        expect(viewRenderFn).toHaveBeenLastCalledWith(flatItems, 'Some search', filters[0]);
        wrapper.unmount();
    });
    it('provides views picker IconButton correct props based on views count', function () {
        var views = [
            { key: 'one', iconName: '', text: 'One', onRenderView: function () { return null; } },
            { key: 'two', iconName: '', text: 'Two', onRenderView: function () { return null; } }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: views, strings: strings }));
        expect(getState(wrapper).selectedViewKey).toBe('one');
        var viewsButton = wrapper.find(IconButton);
        expect(viewsButton.length).toBe(1);
        expect(viewsButton.prop('onClick')).toBeTruthy();
        expect(viewsButton.prop('menuProps')).toBeUndefined();
        views.push({ key: 'three', iconName: '', text: 'Three', onRenderView: function () { return null; } });
        wrapper.setProps({ views: views });
        viewsButton = wrapper.find(IconButton);
        expect(viewsButton.length).toBe(1);
        expect(viewsButton.prop('onClick')).toBeUndefined();
        expect(viewsButton.prop('menuProps')).toBeTruthy();
        wrapper.unmount();
    });
    it('renders view picker correctly based on views count', function () {
        var views = [{ key: 'one', iconName: '', text: 'One', onRenderView: function () { return null; } }];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: views, strings: strings }));
        var viewsButton = wrapper.find(IconButton);
        expect(viewsButton.length).toBe(0);
        views.push({ key: 'two', iconName: '', text: 'Two', onRenderView: function () { return null; } });
        wrapper.setProps({ views: views });
        viewsButton = wrapper.find(IconButton);
        expect(viewsButton.length).toBe(1);
        wrapper.unmount();
    });
    it('updates selectedViewKey appropriately when views is removed', function () {
        var views = [
            { key: 'one', iconName: '', text: 'One', onRenderView: function () { return null; } },
            { key: 'two', iconName: '', text: 'Two', onRenderView: function () { return null; } }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: views, strings: strings }));
        expect(getState(wrapper).selectedViewKey).toBe('one');
        var viewsButton = wrapper.find(IconButton);
        viewsButton.props().onClick(null);
        expect(getState(wrapper).selectedViewKey).toBe('two');
        views.splice(1, 1);
        wrapper.setProps({ views: views });
        expect(getState(wrapper).selectedViewKey).toBe('one');
        wrapper.unmount();
    });
    it('updates selectedViewKey to defaultValue when view is removed', function () {
        var views = [
            { key: 'one', iconName: '', text: 'One', onRenderView: function () { return null; } },
            { key: 'two', iconName: '', text: 'Two', onRenderView: function () { return null; } },
            { key: 'three', iconName: '', text: 'Three', onRenderView: function () { return null; } }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: views, strings: strings, defaultSelectedViewKey: 'two' }));
        expect(getState(wrapper).selectedViewKey).toBe('two');
        var viewsButton = wrapper.find(IconButton);
        viewsButton.prop('menuProps').onItemClick(null, views[2]);
        expect(getState(wrapper).selectedViewKey).toBe('three');
        // Remove three and ensure it goes back to two
        views.splice(2, 1);
        wrapper.setProps({ views: views });
        expect(getState(wrapper).selectedViewKey).toBe('two');
        wrapper.unmount();
    });
    it('updates selectedViewKey as appropriate', function () {
        var views = [
            { key: 'one', iconName: '', text: 'One', onRenderView: function () { return null; } },
            { key: 'two', iconName: '', text: 'Two', onRenderView: function () { return null; } }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: views, strings: strings }));
        // With only two views, click the button and make sure it cycles
        expect(getState(wrapper).selectedViewKey).toBe('one');
        var viewsButton = wrapper.find(IconButton);
        viewsButton.props().onClick(null);
        expect(getState(wrapper).selectedViewKey).toBe('two');
        viewsButton.props().onClick(null);
        expect(getState(wrapper).selectedViewKey).toBe('one');
        // Add a view and try with three
        views.push({ key: 'three', iconName: '', text: 'Three', onRenderView: function () { return null; } });
        wrapper.setProps({ views: views });
        viewsButton = wrapper.find(IconButton);
        viewsButton.prop('menuProps').onItemClick(null, views[2]);
        expect(getState(wrapper).selectedViewKey).toBe('three');
        wrapper.unmount();
    });
    it('calls onRenderView with only the filtered items', function () {
        var renderViewFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function (item) { return item.value !== 2; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: renderViewFn }], strings: strings }));
        expect(renderViewFn).toBeCalledWith(flatItems.slice(0, 1), '', null);
        wrapper.unmount();
    });
    it('calls onRenderView with only the filtered partial nested items', function () {
        var renderViewFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: nestedItems, shouldFilterItem: function (item) { return item.value !== 11; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: renderViewFn }], strings: strings }));
        var expectedItems = nestedItems.slice(0);
        expectedItems[0].children = expectedItems[0].children.slice(1, 2);
        expect(renderViewFn).toBeCalledWith(expectedItems, '', null);
        wrapper.unmount();
    });
    it('calls onRenderView with empty groups removed', function () {
        var renderViewFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: nestedItems, shouldFilterItem: function (item) {
                if (item.children) {
                    return item.children.length > 0;
                }
                return item.value < 20;
            }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: renderViewFn }], strings: strings }));
        expect(renderViewFn).toBeCalledWith(nestedItems.slice(0, 1), '', null);
        wrapper.unmount();
    });
    it('calls shouldFilterItem with correct search and filter information', function () {
        var shouldFilterItemFn = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: shouldFilterItemFn, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], filters: [{ key: 'a', text: 'A' }], strings: strings }));
        expect(shouldFilterItemFn).toHaveBeenLastCalledWith(flatItems[1], '', null);
        var filterSearchBox = wrapper.find(FilterSearchBox);
        filterSearchBox.prop('onSearchTextChange')(null, 'New Search Text');
        expect(shouldFilterItemFn).toHaveBeenLastCalledWith(flatItems[1], 'New Search Text', null);
        filterSearchBox.prop('onFilterChange')('a');
        expect(shouldFilterItemFn).toHaveBeenLastCalledWith(flatItems[1], 'New Search Text', {
            key: 'a',
            text: 'A'
        });
        wrapper.unmount();
    });
    it('updates all filter text correctly when strings allItemFilterText changes', function () {
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: {
                searchBoxPlaceholder: '',
                allItemsFilterItemText: 'All'
            } }));
        var filterSearchBox = wrapper.find(FilterSearchBox);
        expect(filterSearchBox.length).toBe(1);
        expect(filterSearchBox.prop('filters')[0].text).toBe('All');
        wrapper.setProps({
            strings: {
                searchBoxPlaceholder: '',
                allItemsFilterItemText: 'All items'
            }
        });
        filterSearchBox = wrapper.find(FilterSearchBox);
        expect(filterSearchBox.length).toBe(1);
        expect(filterSearchBox.prop('filters')[0].text).toBe('All items');
        wrapper.unmount();
    });
    it('updates filters list when props change', function () {
        var aFilter = { key: 'a', text: 'A' };
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], filters: [aFilter], strings: {
                searchBoxPlaceholder: '',
                allItemsFilterItemText: 'All'
            } }));
        var filterSearchBox = wrapper.find(FilterSearchBox);
        expect(filterSearchBox.length).toBe(1);
        expect(filterSearchBox.prop('filters')).toEqual([
            { key: 'filterSearchViewsAllFilterKey', text: 'All' },
            aFilter
        ]);
        var anotherFilter = { key: 'b', text: 'B' };
        wrapper.setProps({
            filters: [aFilter, anotherFilter]
        });
        filterSearchBox = wrapper.find(FilterSearchBox);
        expect(filterSearchBox.length).toBe(1);
        expect(filterSearchBox.prop('filters')).toEqual([
            { key: 'filterSearchViewsAllFilterKey', text: 'All' },
            aFilter,
            anotherFilter
        ]);
        wrapper.unmount();
    });
    it('focuses search box when focus is called on componentRef', function () {
        var ref = React.createRef();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { componentRef: ref, items: flatItems, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings }));
        var instance = getInstance(wrapper);
        var focusFn = jest.fn();
        instance._filterSearchBoxRef.current.focus = focusFn;
        expect(ref.current).toBeTruthy();
        expect(ref.current.focus).toBeDefined();
        ref.current.focus();
        expect(focusFn).toHaveBeenCalled();
        wrapper.unmount();
    });
    it('throws an error with cirular references in items', function () {
        var item1 = { value: 1 };
        var item2 = { value: 2, children: [item1] };
        item1.children = [item2];
        var caughtError;
        var ErrorBoundary = /** @class */ (function (_super) {
            __extends(ErrorBoundary, _super);
            function ErrorBoundary() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ErrorBoundary.prototype.render = function () {
                return (React.createElement(FilterSearchViewsBase, { items: [item1, item2], shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings }));
            };
            ErrorBoundary.prototype.componentDidCatch = function (error) {
                caughtError = error;
            };
            return ErrorBoundary;
        }(React.Component));
        // Disable the console.error while this component mounts. This will prevent a giant error message
        // from being printed and looking like a test failure.
        // eslint-disable-next-line no-console
        var originalError = console.error;
        // eslint-disable-next-line no-console
        console.error = jest.fn();
        var wrapper = mount(React.createElement(ErrorBoundary, null));
        // eslint-disable-next-line no-console
        console.error = originalError;
        expect(caughtError).toBeTruthy();
        expect(caughtError.message.indexOf('FilterSearchViews: Invalid items property. This could be due to circular references in items. Error: ')).toBeGreaterThan(-1);
        wrapper.unmount();
    });
    it('handles default state props as expected', function () {
        var defaultSearchText = 'Default Search';
        var defaultFilterKey = 'a';
        var defaultViewKey = 'two';
        var view1RenderFn = jest.fn();
        var view2RenderFn = jest.fn();
        var filters = [
            { key: 'a', text: 'A' },
            { key: 'b', text: 'B' }
        ];
        var views = [
            { key: 'one', iconName: '', text: 'One', onRenderView: view1RenderFn },
            { key: 'two', iconName: '', text: 'Two', onRenderView: view2RenderFn }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { strings: strings, items: flatItems, shouldFilterItem: function () { return true; }, views: views, filters: filters, defaultSearchText: defaultSearchText, defaultSelectedFilterKey: defaultFilterKey, defaultSelectedViewKey: defaultViewKey }));
        expect(getState(wrapper).searchText).toBe(defaultSearchText);
        expect(getState(wrapper).selectedFilterKey).toBe(defaultFilterKey);
        expect(getState(wrapper).selectedViewKey).toBe(defaultViewKey);
        var filterSearchBox = wrapper.find(FilterSearchBox);
        expect(filterSearchBox.prop('searchText')).toBe(defaultSearchText);
        expect(filterSearchBox.prop('selectedFilterKey')).toBe(defaultFilterKey);
        expect(view1RenderFn).toHaveBeenCalledTimes(0);
        expect(view2RenderFn).toHaveBeenCalledTimes(1);
        var instance = getInstance(wrapper);
        expect(instance._selectedFilter).toBe(filters[0]);
        expect(instance._selectedView).toBe(views[1]);
        wrapper.unmount();
    });
    it('calls onChange functions when values change', function () {
        var filters = [
            { key: 'a', text: 'A' },
            { key: 'b', text: 'B' }
        ];
        var views = [
            { key: 'one', iconName: '', text: 'One', onRenderView: function () { return null; } },
            { key: 'two', iconName: '', text: 'Two', onRenderView: function () { return null; } },
            { key: 'three', iconName: '', text: 'Three', onRenderView: function () { return null; } }
        ];
        var onChangeSearchText = jest.fn();
        var onChangeFilter = jest.fn();
        var onChangeView = jest.fn();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: views, filters: filters, strings: strings, onChangeSearchText: onChangeSearchText, onChangeFilter: onChangeFilter, onChangeView: onChangeView }));
        var filterSearchBox = wrapper.find(FilterSearchBox);
        expect(filterSearchBox.length).toBe(1);
        var viewsButton = wrapper.find(IconButton);
        expect(viewsButton.length).toBe(1);
        // First validate the onChange functions are called when the value changes
        filterSearchBox.prop('onSearchTextChange')(null, 'Some text');
        expect(onChangeSearchText).toHaveBeenCalledTimes(1);
        expect(onChangeSearchText).toHaveBeenLastCalledWith('Some text');
        filterSearchBox.prop('onFilterChange')('a');
        expect(onChangeFilter).toHaveBeenCalledTimes(1);
        expect(onChangeFilter).toHaveBeenLastCalledWith('a');
        viewsButton.prop('menuProps').onItemClick(null, views[2]);
        expect(onChangeView).toHaveBeenCalledTimes(1);
        expect(onChangeView).toHaveBeenLastCalledWith('three');
        // Now validate they aren't called when change is triggered again with the same value.
        filterSearchBox.prop('onSearchTextChange')(null, 'Some text');
        expect(onChangeSearchText).toHaveBeenCalledTimes(1);
        filterSearchBox.prop('onFilterChange')('a');
        expect(onChangeFilter).toHaveBeenCalledTimes(1);
        viewsButton.prop('menuProps').onItemClick(null, views[2]);
        expect(onChangeView).toHaveBeenCalledTimes(1);
        wrapper.unmount();
    });
    it('sends filterButtonIconName prop correctly to FilterSearchBox', function () {
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings, filterButtonIconName: 'Some icon name' }));
        var searchBox = wrapper.find(FilterSearchBox);
        expect(searchBox.length).toBe(1);
        expect(searchBox.prop('filterButtonIconName')).toBe('Some icon name');
        wrapper.setProps({
            filterButtonIconName: function () { return 'Some icon name that is different'; }
        });
        searchBox = wrapper.find(FilterSearchBox);
        expect(searchBox.length).toBe(1);
        expect(searchBox.prop('filterButtonIconName')).toBe('Some icon name that is different');
        wrapper.unmount();
    });
    it('filterButtonIconName is called appropriately based on selected filter', function () {
        var filterButtonIconFn = jest.fn();
        var filters = [
            { key: 'a', text: 'A' },
            { key: 'b', text: 'B' }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, filters: filters, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings, filterButtonIconName: filterButtonIconFn }));
        // Initially it should have been called with null - since the All filter will be selected by default
        expect(filterButtonIconFn).toHaveBeenCalledTimes(1);
        expect(filterButtonIconFn).toHaveBeenLastCalledWith(null);
        getInstance(wrapper).setState({ selectedFilterKey: filters[1].key });
        wrapper.update();
        expect(filterButtonIconFn).toHaveBeenCalledTimes(2);
        expect(filterButtonIconFn).toHaveBeenLastCalledWith(filters[1].key);
        wrapper.unmount();
    });
    it('defaultFilterIconNameFunction functions correctly', function () {
        var filters = [
            { key: 'a', text: 'A' },
            { key: 'b', text: 'B' }
        ];
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, filters: filters, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings, filterButtonIconName: defaultFilterIconNameFunction }));
        expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('Filter');
        getInstance(wrapper).setState({ selectedFilterKey: filters[0].key });
        wrapper.update();
        expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('FilterSolid');
        getInstance(wrapper).setState({ selectedFilterKey: filters[1].key });
        wrapper.update();
        expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('FilterSolid');
        getInstance(wrapper).setState({ selectedFilterKey: 'filterSearchViewsAllFilterKey' });
        wrapper.update();
        expect(wrapper.find(FilterSearchBox).prop('filterButtonIconName')).toBe('Filter');
    });
    it('sends strings appropriately to FilterSearchBox', function () {
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { items: flatItems, shouldFilterItem: function () { return true; }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: __assign(__assign({}, strings), { searchBoxPlaceholder: 'Search box placeholder', searchBoxClearButtonTitle: 'Clear search tooltip', filterButtonTooltipText: 'Filter button tooltip' }) }));
        var searchBox = wrapper.find(FilterSearchBox);
        expect(searchBox.length).toBe(1);
        expect(searchBox.prop('strings').searchBoxPlaceholder).toBe('Search box placeholder');
        expect(searchBox.prop('strings').searchBoxClearButtonTitle).toBe('Clear search tooltip');
        expect(searchBox.prop('strings').filterButtonTooltipText).toBe('Filter button tooltip');
        wrapper.unmount();
    });
    it('fills a componentRef', function () {
        var _filterSearchViewsRef = React.createRef();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { componentRef: _filterSearchViewsRef, items: nestedItems, shouldFilterItem: function (item) {
                if (item.children) {
                    return item.children.length > 0;
                }
                return item.value < 20;
            }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings }));
        expect(_filterSearchViewsRef.current).not.toBeNull();
        wrapper.unmount();
    });
    it('dissmisses menu on FilterSearchBox when dismissmenu is called on componentRef', function () {
        var _filterSearchViewsRef = React.createRef();
        var wrapper = mount(React.createElement(FilterSearchViewsBase, { componentRef: _filterSearchViewsRef, items: nestedItems, shouldFilterItem: function (item) {
                if (item.children) {
                    return item.children.length > 0;
                }
                return item.value < 20;
            }, views: [{ key: 'test', iconName: '', text: 'Test', onRenderView: function () { return null; } }], strings: strings }));
        var instance = getInstance(wrapper);
        var dismissFn = jest.fn();
        instance._filterSearchBoxRef.current.dismissMenu = dismissFn;
        expect(_filterSearchViewsRef.current).toBeTruthy();
        expect(_filterSearchViewsRef.current.dismissMenu).toBeDefined();
        _filterSearchViewsRef.current.dismissMenu();
        expect(dismissFn).toHaveBeenCalled();
        wrapper.unmount();
    });
});
//# sourceMappingURL=FilterSearchViews.test.js.map