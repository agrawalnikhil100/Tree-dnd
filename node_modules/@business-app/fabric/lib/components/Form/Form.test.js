/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __assign, __extends } from "tslib";
import * as React from 'react';
import * as ReactTestUtils from 'react-dom/test-utils';
import * as Enzyme from 'enzyme';
import { TextFieldBase } from '@fluentui/react/lib/TextField';
import { Form } from './Form';
import { DEFAULT_DEBOUNCE } from './FormBaseInput';
import { FormTextInput } from './inputs/textInput/FormTextInput';
import * as Validators from './validators/Validators';
// Add an margin of time for the tests to call the function
export var DEFAULT_DEBOUNCE_TEST = DEFAULT_DEBOUNCE + 50;
describe('Form', function () {
    var formProps;
    var formTextInputProps;
    var formRequiredTestMessage = 'This field is required';
    var formTextBoxValidatorTestMessage = 'Error message for number field';
    var wrapper;
    describe('Form renders for different props', function () {
        beforeEach(function () {
            formProps = {
                onSubmit: function () {
                    /* stub */
                }
            };
            formTextInputProps = {
                inputKey: 'field',
                textFieldProps: { label: 'Field' }
            };
        });
        it('Null props', function () {
            formProps.onSubmit = null;
            ReactTestUtils.renderIntoDocument(React.createElement(Form, __assign({}, formProps)));
        });
        it('One form value', function () {
            wrapper = Enzyme.mount(React.createElement(Form, __assign({}, formProps),
                React.createElement(FormTextInput, __assign({}, formTextInputProps))));
            expect(wrapper.find(TextFieldBase)).toHaveLength(1);
        });
        it('Two form values', function () {
            wrapper = Enzyme.mount(React.createElement(Form, __assign({}, formProps),
                React.createElement(FormTextInput, __assign({}, formTextInputProps)),
                React.createElement(FormTextInput, __assign({}, formTextInputProps))));
            expect(wrapper.find(TextFieldBase)).toHaveLength(2);
        });
        it('Initial form value', function () {
            formTextInputProps.value = 'Value';
            wrapper = Enzyme.mount(React.createElement(Form, __assign({}, formProps),
                React.createElement(FormTextInput, __assign({}, formTextInputProps))));
            var textInput = wrapper.find('input').getDOMNode();
            expect(textInput.value).toEqual('Value');
        });
    });
    var ExtendsTextBox = /** @class */ (function (_super) {
        __extends(ExtendsTextBox, _super);
        function ExtendsTextBox() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ExtendsTextBox.prototype.setValue = function (value) {
            _super.prototype.setValue.call(this, value);
        };
        return ExtendsTextBox;
    }(FormTextInput));
    describe('Simple form validates and return values', function () {
        beforeEach(function () {
            jest.useFakeTimers();
            formTextInputProps = {
                inputKey: 'field',
                textFieldProps: { label: 'Field' }
            };
        });
        afterEach(function () {
            jest.clearAllTimers();
        });
        it('Valid values are returned correctly', function () {
            var result;
            wrapper = Enzyme.mount(React.createElement(Form, { onSubmit: function (value) {
                    result = value;
                } },
                React.createElement(FormTextInput, { inputKey: "field", value: "Value" }),
                React.createElement(FormTextInput, { inputKey: "fieldnumber", value: "2", validators: [Validators.isNumber('')] })));
            var form = wrapper.find('form');
            form.simulate('submit');
            expect(result.field).toEqual('Value');
            expect(result.fieldnumber).toEqual('2');
        });
        it('Invalid values are not returned', function () {
            wrapper = Enzyme.mount(React.createElement(Form, { onSubmit: function () {
                    /* stub */
                } },
                React.createElement(FormTextInput, { inputKey: "field", validators: [Validators.required(formRequiredTestMessage)], value: "" }),
                React.createElement(FormTextInput, { inputKey: "field2", value: "NAN", validators: [Validators.isNumber(formTextBoxValidatorTestMessage)] })));
            var form = wrapper.find('form');
            form.simulate('submit');
            expect(wrapper.find({ errorMessage: formRequiredTestMessage }).length).toBeTruthy();
            expect(wrapper.find({ errorMessage: formTextBoxValidatorTestMessage }).length).toBeTruthy();
        });
        it('Number fields with initial value of 0 are displayed properly', function () {
            wrapper = Enzyme.mount(React.createElement(Form, { onSubmit: function () {
                    /* stub */
                } },
                React.createElement(FormTextInput, { inputKey: "field", value: "0" })));
            var numberField = wrapper.find(TextFieldBase).getDOMNode();
            var input = numberField.getElementsByTagName('input')[0];
            expect(input.getAttribute('value')).toEqual('0');
        });
        // Disabled unstable test
        it.skip('OnUpdated callback is called without submitting form', function (done) {
            var updateCallback = jest.fn();
            var formRef = React.createRef();
            ReactTestUtils.renderIntoDocument(React.createElement(Form, { ref: formRef, onUpdated: updateCallback },
                React.createElement(ExtendsTextBox, { inputKey: "field", value: "0" })));
            var textBox = ReactTestUtils.findRenderedComponentWithType(formRef.current, ExtendsTextBox);
            textBox.setValue('1');
            jest.runAllTimers();
            expect(updateCallback).toHaveBeenCalledTimes(1);
            done();
        });
        it('Errors are hidden when pristine', function (done) {
            var formRef = React.createRef();
            ReactTestUtils.renderIntoDocument(React.createElement(Form, { ref: formRef },
                React.createElement(ExtendsTextBox, { inputKey: "field", validators: [Validators.required(formRequiredTestMessage)] })));
            // Error message is gated behind <DelayedRender>, tick the clock to make it show up
            jest.runAllTimers();
            var errors = ReactTestUtils.scryRenderedDOMComponentsWithClass(formRef.current, 'ms-TextField-errorMessage');
            expect(errors.length).toEqual(0);
            done();
        });
        it('Errors are shown when pristine and prop is set', function (done) {
            wrapper = Enzyme.mount(React.createElement(Form, { showErrorsWhenPristine: true },
                React.createElement(ExtendsTextBox, { inputKey: "field", validators: [Validators.required(formRequiredTestMessage)] })));
            // Error message is gated behind <DelayedRender>, tick the clock to make it show up
            jest.runAllTimers();
            var textBox = wrapper.find(TextFieldBase);
            expect(textBox.prop('errorMessage')).toBeTruthy();
            done();
        });
        it('Debounce interval can be changed', function (done) {
            jest.useRealTimers();
            var updateCallback = jest.fn();
            var formRef = React.createRef();
            ReactTestUtils.renderIntoDocument(React.createElement(Form, { ref: formRef, onUpdated: updateCallback },
                React.createElement(ExtendsTextBox, { inputKey: "field", value: "0", debounceInterval: 3000 })));
            var textBox = ReactTestUtils.findRenderedComponentWithType(formRef.current, ExtendsTextBox);
            textBox.setValue('1');
            setTimeout(function () {
                expect(updateCallback).not.toHaveBeenCalledTimes(1);
                setTimeout(function () {
                    expect(updateCallback).toHaveBeenCalledTimes(1);
                    done();
                }, 3000);
            }, DEFAULT_DEBOUNCE_TEST);
        });
    });
});
//# sourceMappingURL=Form.test.js.map