/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
import { __extends } from "tslib";
import * as PropTypes from 'prop-types';
// Components
import { BaseComponent } from '@fluentui/react/lib/Utilities';
export var DEFAULT_DEBOUNCE = 250;
/**
 * The base class that all simple form inputs should inherit from
 * The T generic should be the type of value this input accepts. For example, a TextBox would probably define T as string
 */
var FormBaseInput = /** @class */ (function (_super) {
    __extends(FormBaseInput, _super);
    /**
     * Constructor for any Simple Form input
     * @param props The props for this component
     * @param context The context for this component
     * @param leadingDebounce Sets the debounce setting for updates on this input.
     * If leading, the component will update immediately and then debounce.
     * Otherwise, the component will only update after the debounce interval. Defaults to true
     */
    function FormBaseInput(props, context, leadingDebounce) {
        var _this = _super.call(this, props, context) || this;
        _this.formContext = context;
        _this.debouncedSubmitValue = _this._async.debounce(_this.formContext.submitValue, _this.props.debounceInterval !== null && _this.props.debounceInterval !== undefined
            ? _this.props.debounceInterval
            : DEFAULT_DEBOUNCE, {
            leading: leadingDebounce === null || leadingDebounce === undefined ? true : leadingDebounce
        });
        FormBaseInput._validateProps(props);
        return _this;
    }
    /**
     * React Lifecycle Method - Because this method uses state when rendering, the state must be
     * updated when the prop's value updates
     * @param nextProps The props that the component is receiving
     * @param prevState The current state of the component
     */
    FormBaseInput.getDerivedStateFromProps = function (nextProps, prevState) {
        FormBaseInput._validateProps(nextProps);
        var value = prevState.prevPropValue;
        if (value !== nextProps.value && value === prevState.currentValue) {
            // If the props have changed and the previous props are equal to the current value, then we want to update the internal state value
            return {
                currentValue: nextProps.value
            };
        }
        return null;
    };
    FormBaseInput.prototype.componentDidMount = function () {
        this.formContext.mountInput(this);
    };
    FormBaseInput.prototype.componentWillUnmount = function () {
        this.debouncedSubmitValue.flush();
        this.formContext.unmountInput(this);
    };
    /**
     * Validate the input. By default, this function will run through all the validators and ensure they pass
     */
    FormBaseInput.prototype.doValidate = function () {
        var _a = this.props.validators, validators = _a === void 0 ? [] : _a;
        var validationResult = {
            isValid: true,
            component: this
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        for (var _i = 0, _b = validators; _i < _b.length; _i++) {
            var validator = _b[_i];
            var error = validator(this.state.currentValue);
            if (error) {
                validationResult.isValid = false;
                validationResult.errorMessage = error;
                return validationResult;
            }
        }
        return validationResult;
    };
    /**
     * Set the error state of this input
     */
    FormBaseInput.prototype.setError = function (errorMessage) {
        var _this = this;
        this.setState(function (prevState) {
            prevState.isValid = false;
            prevState.currentError = errorMessage;
            prevState.prevPropValue = _this.props.value;
            return prevState;
        });
    };
    /**
     * Clear any errors from this input
     */
    FormBaseInput.prototype.clearError = function () {
        var _this = this;
        this.setState(function (prevState) {
            prevState.isValid = true;
            prevState.currentError = undefined;
            prevState.prevPropValue = _this.props.value;
            return prevState;
        });
    };
    /**
     * Set the current value of this input and validate it
     */
    FormBaseInput.prototype.setValue = function (value) {
        var _this = this;
        this.setState(function (prevState) {
            prevState.currentValue = value;
            prevState.prevPropValue = _this.props.value;
            return prevState;
        }, function () {
            _this.debouncedSubmitValue(_this);
        });
    };
    /**
     * Validate incoming props
     * @param props Props to validate
     */
    FormBaseInput._validateProps = function (props) {
        if (!props.inputKey) {
            throw new Error('FormBaseInput: name must be defined on all form inputs');
        }
    };
    FormBaseInput.contextTypes = {
        isFormValid: PropTypes.func.isRequired,
        mountInput: PropTypes.func.isRequired,
        unmountInput: PropTypes.func.isRequired,
        submitValue: PropTypes.func.isRequired
    };
    return FormBaseInput;
}(BaseComponent));
export { FormBaseInput };
//# sourceMappingURL=FormBaseInput.js.map