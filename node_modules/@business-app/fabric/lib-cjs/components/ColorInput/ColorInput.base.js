"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidColor = exports.ColorInputBase = void 0;
var tslib_1 = require("tslib");
var Button_1 = require("@fluentui/react/lib/Button");
var ColorPicker_1 = require("@fluentui/react/lib/ColorPicker");
var Color_1 = require("@fluentui/react/lib/Color");
var Label_1 = require("@fluentui/react/lib/Label");
var Styling_1 = require("@fluentui/react/lib/Styling");
var TextField_1 = require("@fluentui/react/lib/TextField");
var Tooltip_1 = require("@fluentui/react/lib/Tooltip");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var Utilities_2 = require("@fluentui/react/lib/Utilities");
var React = require("react");
var react_1 = require("react");
var _1 = require(".");
var getClassNames = Utilities_2.classNamesFunction();
function getColorInputClassNames(props) {
    return getClassNames(props.styles, props);
}
var ColorInputBase = function (props) {
    var _a, _b;
    var tooltipIconProps = props.tooltipIconProps, colorBoxProps = props.colorBoxProps, colorTextFieldProps = props.colorTextFieldProps, colorPickerProps = props.colorPickerProps, label = props.label, tooltipProps = props.tooltipProps, styles = props.styles, theme = props.theme, showColorPicker = props.showColorPicker, scrollToBottom = props.scrollToBottom;
    var onTextFieldChange = react_1.useCallback(function (ev, newValue) {
        setBoxColor(ev.target.value);
    }, []);
    var onTextFieldBlur = react_1.useCallback(function (ev) {
        var newValue = ev.target.value;
        setNewColorPickerProps(newValue);
    }, []);
    var onColorChange = react_1.useCallback(function (ev, selectedColor) {
        setBoxColor(selectedColor.str);
        setNewColorPickerProps(selectedColor.str);
    }, []);
    var onColorBoxClick = react_1.useCallback(function (event) {
        setColorPickerVisibility(function (value) { return !value; });
    }, []);
    var setNewColorPickerProps = function (newColor) {
        var newProps = tslib_1.__assign({}, pickerProps);
        newProps.color = newColor;
        setColorPickerColorProps(newProps);
    };
    var updatedColorBoxProps = tslib_1.__assign(tslib_1.__assign({}, colorBoxProps), { onClick: function (ev) {
            if (showColorPicker === undefined) {
                onColorBoxClick(ev);
            }
            if (colorBoxProps === null || colorBoxProps === void 0 ? void 0 : colorBoxProps.onClick) {
                colorBoxProps.onClick(ev);
            }
        } });
    var updatedColorTextFieldProps = tslib_1.__assign(tslib_1.__assign({}, colorTextFieldProps), { onChange: function (ev, newValue) {
            var _a;
            onTextFieldChange(ev);
            (_a = colorTextFieldProps === null || colorTextFieldProps === void 0 ? void 0 : colorTextFieldProps.onChange) === null || _a === void 0 ? void 0 : _a.call(colorTextFieldProps, ev, newValue);
        }, onBlur: function (ev) {
            var _a;
            onTextFieldBlur(ev);
            (_a = colorTextFieldProps === null || colorTextFieldProps === void 0 ? void 0 : colorTextFieldProps.onBlur) === null || _a === void 0 ? void 0 : _a.call(colorTextFieldProps, ev);
        } });
    var mergedCpRootStyle;
    if (colorPickerProps.styles && colorPickerProps.styles.root) {
        mergedCpRootStyle = Styling_1.mergeStyles(_1.defaultColorPickerStyles.root, colorPickerProps.styles.root);
    }
    else {
        mergedCpRootStyle = Styling_1.mergeStyles(_1.defaultColorPickerStyles.root);
    }
    var updatedColorPickerProps = tslib_1.__assign(tslib_1.__assign({}, colorPickerProps), { onChange: function (ev, pickerColor) {
            onColorChange(ev, pickerColor);
            if (colorPickerProps.onChange) {
                colorPickerProps.onChange(ev, pickerColor);
            }
        }, styles: tslib_1.__assign(tslib_1.__assign({}, colorPickerProps.styles), { root: mergedCpRootStyle }) });
    var mergedTooltipIconRootStyle;
    if (((_a = tooltipIconProps === null || tooltipIconProps === void 0 ? void 0 : tooltipIconProps.iconProps) === null || _a === void 0 ? void 0 : _a.styles) &&
        tooltipIconProps.iconProps.styles.root) {
        mergedTooltipIconRootStyle = Styling_1.mergeStyles(_1.defaultTooltipIconStyles.root, tooltipIconProps.iconProps.styles.root);
    }
    else {
        mergedTooltipIconRootStyle = Styling_1.mergeStyles(_1.defaultTooltipIconStyles.root);
    }
    var updatedTooltipIconProps;
    if (tooltipIconProps) {
        if (tooltipIconProps.iconProps) {
            updatedTooltipIconProps = tslib_1.__assign({}, tooltipIconProps);
            updatedTooltipIconProps.iconProps = tslib_1.__assign(tslib_1.__assign({}, updatedTooltipIconProps.iconProps), { styles: tslib_1.__assign(tslib_1.__assign({}, updatedTooltipIconProps.iconProps.styles), { root: mergedTooltipIconRootStyle }), iconName: updatedTooltipIconProps.iconProps.iconName
                    ? updatedTooltipIconProps.iconProps.iconName
                    : _1.defaultTooltipIconProps.iconProps.iconName });
        }
        else {
            updatedTooltipIconProps = tslib_1.__assign(tslib_1.__assign({}, _1.defaultTooltipIconProps), tooltipIconProps);
        }
    }
    else {
        updatedTooltipIconProps = tslib_1.__assign({}, _1.defaultTooltipIconProps);
    }
    var color = colorPickerProps.color;
    var classNames = getClassNames(styles, { theme: theme });
    var colorInputId = Utilities_1.getId('colorInput');
    var tooltipId = Utilities_1.getId('tooltip');
    var _c = react_1.useState(color), boxColor = _c[0], setBoxColor = _c[1];
    var _d = react_1.useState(updatedColorPickerProps), pickerProps = _d[0], setColorPickerColorProps = _d[1];
    var _e = react_1.useState(false), isColorPickerVisible = _e[0], setColorPickerVisibility = _e[1];
    var colorPickerDivRef = null;
    var executeScroll = function () { return scrollToRef(colorPickerDivRef); };
    react_1.useEffect(function () {
        if (isColorPickerVisible && scrollToBottom) {
            executeScroll();
        }
    }, [isColorPickerVisible]);
    react_1.useEffect(function () {
        if (showColorPicker !== undefined) {
            setColorPickerVisibility(showColorPicker);
        }
    }, [showColorPicker]);
    return (React.createElement("div", { className: classNames.root },
        React.createElement("div", { className: classNames.labelContainer },
            React.createElement(Label_1.Label, { className: classNames.label, htmlFor: colorInputId }, label),
            React.createElement(Tooltip_1.TooltipHost, tslib_1.__assign({ id: tooltipId, calloutProps: { gapSpace: 5 } }, tooltipProps),
                React.createElement(Button_1.IconButton, tslib_1.__assign({ "aria-describedby": tooltipId, className: classNames.iconTooltip }, updatedTooltipIconProps)))),
        React.createElement("div", { className: classNames.container },
            React.createElement(Button_1.IconButton, tslib_1.__assign({ className: ((_b = props.colorBoxProps) === null || _b === void 0 ? void 0 : _b.disabled) ? classNames.colorBoxDisabled : classNames.colorBox, "aria-expanded": isColorPickerVisible, onRenderIcon: function () {
                    return onRenderIcon(boxColor, props);
                } }, updatedColorBoxProps)),
            React.createElement(TextField_1.TextField, tslib_1.__assign({ className: classNames.colorTextField, value: getColor(boxColor) }, updatedColorTextFieldProps))),
        isColorPickerVisible && (React.createElement(React.Fragment, null,
            React.createElement(ColorPicker_1.ColorPicker, tslib_1.__assign({ className: classNames.colorPicker }, pickerProps)),
            React.createElement("div", { style: { float: 'left', clear: 'both' }, ref: function (el) {
                    colorPickerDivRef = el;
                } })))));
};
exports.ColorInputBase = ColorInputBase;
var getColor = function (color) {
    color = typeof color === 'string' ? color : color.str;
    var value = Color_1.getColorFromString(color);
    return value ? (value.str.indexOf('#') === 0 ? value.str : '#' + value.hex) : color;
};
function isValidColor(inputColor) {
    var color = typeof inputColor === 'string' ? inputColor : inputColor.str;
    var value = Color_1.getColorFromString(color);
    return value ? value.str : undefined;
}
exports.isValidColor = isValidColor;
var scrollToRef = function (ref) {
    if (ref === null || ref === void 0 ? void 0 : ref.scrollIntoView) {
        ref.scrollIntoView({ behavior: 'smooth' });
    }
};
var onRenderIcon = function (boxColor, props) {
    var classNames = getColorInputClassNames(props);
    var iconColor = isValidColor(boxColor);
    if (iconColor) {
        return (React.createElement("svg", { className: classNames.colorBoxSvg, "aria-hidden": "true", viewBox: "0 0 20 20", fill: iconColor, xmlns: "http://www.w3.org/2000/svg" },
            React.createElement("rect", { width: "100%", height: "100%" })));
    }
    else {
        return getNoColorIcon(props);
    }
};
var getNoColorIcon = function (props) {
    var classNames = getColorInputClassNames(props);
    return (React.createElement("svg", { className: classNames.colorBoxSvg, "aria-hidden": "true", viewBox: "0 0 28 28", fill: "white", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("rect", { width: "100%", height: "100%" }),
        React.createElement("line", { x1: "1.41421", y1: "2", x2: "26", y2: "26.5858", stroke: "#A80000", "stroke-width": "2", "stroke-linecap": "round" })));
};
//# sourceMappingURL=ColorInput.base.js.map