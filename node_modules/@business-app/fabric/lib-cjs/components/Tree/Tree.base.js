"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeBase = exports.defaultNodeHeight = exports.defaultIconWidth = void 0;
var tslib_1 = require("tslib");
var FocusZone_1 = require("@fluentui/react/lib/FocusZone");
var List_1 = require("@fluentui/react/lib/List");
var Styling_1 = require("@fluentui/react/lib/Styling");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var React = require("react");
var Tree_types_1 = require("./Tree.types");
var TreeNode_1 = require("./TreeNode/TreeNode");
var getClassNames = Utilities_1.classNamesFunction();
exports.defaultIconWidth = 26;
exports.defaultNodeHeight = 32;
var defaultItemsPerPage = 10;
// Number.MAX_SAFE_INTEGER doesn't work in IE, so just use a large number.
var maxInt = 99999;
/**
 * A generic Tree component based on Fabric's List.
 */
var TreeBase = /** @class */ (function (_super) {
    tslib_1.__extends(TreeBase, _super);
    function TreeBase(props) {
        var _this = _super.call(this, props) || this;
        _this._focusZone = React.createRef();
        _this._classNames = {};
        _this._visibleIndexByItem = {};
        _this._hiddenStyle = { display: 'none' };
        _this._renderScrollViewAndList = function () {
            var scrollView = _this.props.scrollView;
            if (!!scrollView) {
                var ScrollView = scrollView;
                return React.createElement(ScrollView, { className: _this._classNames.scrollView }, _this._renderList());
            }
            return React.createElement("div", { className: _this._classNames.scrollView }, _this._renderList());
        };
        _this._renderList = function () {
            var _a = _this.props, items = _a.items, strings = _a.strings;
            return (React.createElement(List_1.List, { className: _this._classNames.list, ref: _this._saveListRef, items: _this._getVisibleItems(items), role: "tree", getKey: _this._getKey, getPageHeight: _this._getPageHeight, "aria-label": strings.listAriaLabel, "aria-multiselectable": true, onRenderCell: _this._onRenderTreeNode }));
        };
        _this._onRenderTreeNode = function (item, index, isScrolling) {
            var _a = _this.props, getItemIsCollapsible = _a.getItemIsCollapsible, getItemIsDisabled = _a.getItemIsDisabled, getItemCommands = _a.getItemCommands, getItemHasCommands = _a.getItemHasCommands, getItemStyle = _a.getItemStyle, onRenderItemContainer = _a.onRenderItemContainer, onRenderItemLabel = _a.onRenderItemLabel, onRenderItemLabelContent = _a.onRenderItemLabelContent, onRenderExpandIcon = _a.onRenderExpandIcon, onRenderContextualMenu = _a.onRenderContextualMenu, strings = _a.strings;
            var customItemContainerRender = onRenderItemContainer ? _this._onRenderItemContainer : undefined;
            var customItemLabelRender = onRenderItemLabel ? _this._onRenderItemLabel : undefined;
            var customItemLabelContentRender = onRenderItemLabelContent
                ? _this._onRenderItemLabelContent
                : undefined;
            var customExpandIconRender = onRenderExpandIcon ? _this._onRenderExpandIcon : undefined;
            var customContextualMenuRender = onRenderContextualMenu ? _this._onRenderContextualMenu : undefined;
            var customItemStyle = getItemStyle ? _this._getItemStyle(item) : undefined;
            var isSelected = _this.state.selectedItemKeys.has(item.key);
            var isSelectionDisabled = item.disableSelection;
            var isExpanded = _this.state.expandedItemKeys.has(item.key);
            var isCollapsible = !getItemIsCollapsible || getItemIsCollapsible(item);
            var itemStyle = _this._cachedStyles.item;
            if (!!isSelectionDisabled) {
                itemStyle = _this._cachedStyles.unselectableItem;
            }
            else if (isSelected) {
                itemStyle = _this._cachedStyles.selectedItem;
            }
            if (customItemStyle) {
                itemStyle = Styling_1.mergeStyles(itemStyle, customItemStyle);
            }
            return (React.createElement(TreeNode_1.TreeNode, { itemKey: item.key, label: item.label, isFolder: item.isFolder, level: item.level, iconProps: item.iconProps, ariaLabel: item.ariaLabel, setSize: item.setSize, indexInParent: item.indexInParent, isSelectionDisabled: isSelectionDisabled, isDisabled: getItemIsDisabled && getItemIsDisabled(item), isSelected: isSelected, isExpanded: isExpanded, isFocusable: !item.disableFocus, isCollapsible: isCollapsible, moreIcon: _this.state.moreIcon, collapsedArrowIcon: _this.state.collapsedArrowIcon, hasCommands: getItemCommands && (!getItemHasCommands || getItemHasCommands(item)), getCommands: _this._getItemCommands, onRenderItemContainer: customItemContainerRender, onRenderItemLabel: customItemLabelRender, onRenderItemLabelContent: customItemLabelContentRender, onRenderExpandIcon: customExpandIconRender, onRenderContextualMenu: customContextualMenuRender, onSelected: _this._onItemSelected, onExpandToggled: _this._onExpandToggled, onDoubleClicked: _this._onDoubleClicked, onItemKeyDown: _this._onItemKeyDown, moreCommandsAriaLabel: item.moreCommandsAriaLabel || strings.moreCommandsAriaLabel, itemStyle: itemStyle, itemLabelStyle: _this._classNames.itemLabel, indentSpacerStyle: _this._classNames.levelIndentSpacer, menuButtonStyle: _this._classNames.menuButton, menuButtonOpenStyle: isSelected
                    ? _this._classNames.menuButtonSelectedRowOpenMenu
                    : _this._classNames.menuButtonUnselectedRowOpenMenu, menuButtonClosedStyle: isSelected
                    ? _this._classNames.menuButtonSelectedRowClosedMenu
                    : _this._classNames.menuButtonUnselectedRowClosedMenu, menuButtonDisabledStyle: _this._classNames.menuButtonDisabled, expandIconButtonStyle: isCollapsible ? _this._cachedStyles.expandIconButton : _this._cachedStyles.expandIconButtonDisabled, expandIconStyle: isExpanded ? _this._cachedStyles.expandIconExpanded : _this._classNames.expandIcon, noExpandIconStyle: _this._classNames.noExpandIcon, itemIconContainerStyle: _this._classNames.itemIconContainer, itemIconStyle: _this._classNames.itemIcon, noItemIconStyle: _this._classNames.noItemIcon }));
        };
        _this._getItemStyle = function (item) {
            var getItemStyle = _this.props.getItemStyle;
            if (getItemStyle) {
                var _a = _this.state, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
                var index = keyToVisibleIndexMap.get(item.key);
                return getItemStyle(item, selectedItemKeys.has(item.key), expandedItemKeys.has(item.key), index);
            }
            return null;
        };
        _this._getItemCommands = function (itemKey) {
            var getItemCommands = _this.props.getItemCommands;
            var keyToItemMap = _this.state.keyToItemMap;
            if (getItemCommands) {
                var item = keyToItemMap.get(itemKey);
                return getItemCommands(item);
            }
            return [];
        };
        _this._onItemSelected = function (itemKey, type) {
            var onItemSelected = _this.props.onItemSelected;
            var _a = _this.state, keyToItemMap = _a.keyToItemMap, selectedItemKeys = _a.selectedItemKeys;
            var item = keyToItemMap.get(itemKey);
            if (item.disableSelection) {
                return;
            }
            if (onItemSelected) {
                var _b = _this.state, expandedItemKeys = _b.expandedItemKeys, keyToVisibleIndexMap = _b.keyToVisibleIndexMap;
                var index = keyToVisibleIndexMap.get(itemKey);
                onItemSelected(item, type, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index);
            }
            // Check if selection is being treated as uncontrolled
            if (!_this.props.selectedItemKeys) {
                var newSelectedItemKeys = void 0;
                if (type === Tree_types_1.SelectionType.Toggle) {
                    newSelectedItemKeys = _this._cloneSet(selectedItemKeys);
                    if (selectedItemKeys.has(itemKey)) {
                        newSelectedItemKeys.delete(itemKey);
                    }
                    else {
                        newSelectedItemKeys.add(itemKey);
                    }
                }
                else {
                    // TODO: add proper support for SelectionType.Block.
                    newSelectedItemKeys = new Set();
                    newSelectedItemKeys.add(itemKey);
                }
                _this.setState({ selectedItemKeys: newSelectedItemKeys });
            }
        };
        _this._onRenderItemContainer = function (itemKey, defaultRender) {
            var onRenderItemContainer = _this.props.onRenderItemContainer;
            var _a = _this.state, keyToItemMap = _a.keyToItemMap, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
            var item = keyToItemMap.get(itemKey);
            var index = keyToVisibleIndexMap.get(itemKey);
            return onRenderItemContainer(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, defaultRender);
        };
        _this._onRenderItemLabel = function (itemKey, defaultRender) {
            var onRenderItemLabel = _this.props.onRenderItemLabel;
            var _a = _this.state, keyToItemMap = _a.keyToItemMap, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
            var item = keyToItemMap.get(itemKey);
            var index = keyToVisibleIndexMap.get(itemKey);
            return onRenderItemLabel(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, defaultRender);
        };
        _this._onRenderItemLabelContent = function (itemKey, defaultRender) {
            var onRenderItemLabelContent = _this.props.onRenderItemLabelContent;
            var _a = _this.state, keyToItemMap = _a.keyToItemMap, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
            var item = keyToItemMap.get(itemKey);
            var index = keyToVisibleIndexMap.get(itemKey);
            return onRenderItemLabelContent(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, defaultRender);
        };
        _this._onRenderExpandIcon = function (itemKey, defaultRender) {
            var onRenderExpandIcon = _this.props.onRenderExpandIcon;
            var _a = _this.state, keyToItemMap = _a.keyToItemMap, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
            var item = keyToItemMap.get(itemKey);
            var index = keyToVisibleIndexMap.get(itemKey);
            return onRenderExpandIcon(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, defaultRender);
        };
        _this._onRenderContextualMenu = function (itemKey, menuProps) {
            var onRenderContextualMenu = _this.props.onRenderContextualMenu;
            var _a = _this.state, keyToItemMap = _a.keyToItemMap, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
            var item = keyToItemMap.get(itemKey);
            var index = keyToVisibleIndexMap.get(itemKey);
            return onRenderContextualMenu(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, menuProps);
        };
        _this._onItemKeyDown = function (itemKey, event) {
            var onItemKeyDown = _this.props.onItemKeyDown;
            var keyToItemMap = _this.state.keyToItemMap;
            var item = keyToItemMap.get(itemKey);
            if (onItemKeyDown) {
                var _a = _this.state, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
                var index = keyToVisibleIndexMap.get(itemKey);
                return onItemKeyDown(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index, event);
            }
        };
        _this._onExpandToggled = function (itemKey) {
            var _a = _this.props, onItemCollapse = _a.onItemCollapse, onItemExpand = _a.onItemExpand;
            var _b = _this.state, keyToItemMap = _b.keyToItemMap, keyToVisibleIndexMap = _b.keyToVisibleIndexMap, expandedItemKeys = _b.expandedItemKeys;
            var item = keyToItemMap.get(itemKey);
            var isExpanded = expandedItemKeys.has(itemKey);
            var index = keyToVisibleIndexMap.get(itemKey);
            var callbackToUse = isExpanded ? onItemCollapse : onItemExpand;
            if (callbackToUse) {
                callbackToUse(item, index);
            }
            // Check if expansion is being treated as uncontrolled
            if (!_this.props.expandedItemKeys) {
                var newExpandedItemKeys_1 = _this._cloneSet(expandedItemKeys);
                if (isExpanded) {
                    newExpandedItemKeys_1.delete(itemKey);
                }
                else {
                    newExpandedItemKeys_1.add(itemKey);
                }
                _this.setState(function (prevState) {
                    return TreeBase_1._getStateFromProps(_this.props, tslib_1.__assign(tslib_1.__assign({}, prevState), { expandedItemKeys: newExpandedItemKeys_1, areExpandedItemsDirty: true }));
                });
            }
        };
        _this._onDoubleClicked = function (itemKey) {
            var onItemDoubleClicked = _this.props.onItemDoubleClicked;
            var keyToItemMap = _this.state.keyToItemMap;
            var item = keyToItemMap.get(itemKey);
            if (onItemDoubleClicked) {
                var _a = _this.state, selectedItemKeys = _a.selectedItemKeys, expandedItemKeys = _a.expandedItemKeys, keyToVisibleIndexMap = _a.keyToVisibleIndexMap;
                var index = keyToVisibleIndexMap.get(itemKey);
                onItemDoubleClicked(item, selectedItemKeys.has(itemKey), expandedItemKeys.has(itemKey), index);
            }
        };
        _this._saveListRef = function (ref) {
            _this._list = ref;
            _this._applyPendingScroll();
        };
        _this._applyPendingScroll = function () {
            var index = _this._getSelectedIndex();
            if (_this._isPendingScrollToSelected && _this._list && index) {
                _this._list.scrollToIndex(index, function () { return _this._getNodeHeight(_this.props); });
                _this._isPendingScrollToSelected = false;
            }
        };
        /**
         * Gets the index of the first selected item
         */
        _this._getSelectedIndex = function () {
            var items = _this.props.items;
            return items && Utilities_1.findIndex(items, function (item) { return _this.state.selectedItemKeys.has(item.key); });
        };
        // This method is necessary for List.scrollToIndex to behave correctly while loading.
        _this._getPageHeight = function () {
            return defaultItemsPerPage * _this._getNodeHeight(_this.props);
        };
        _this._getVisibleItems = function (items) {
            _this._visibleIndexByItem = {};
            var visibleIndex = 0;
            var visibleItems = [];
            var lastCollapsedLevel = maxInt;
            items.forEach(function (item, index) {
                if (item.level <= lastCollapsedLevel) {
                    if (_this.state.expandedItemKeys.has(item.key)) {
                        lastCollapsedLevel = maxInt;
                    }
                    else {
                        lastCollapsedLevel = item.level;
                    }
                    visibleItems.push(item);
                    _this._visibleIndexByItem[item.key] = visibleIndex++;
                }
            });
            return visibleItems;
        };
        var initialSelectedItemKeys = new Set();
        if (props.initialSelectedItemKeys) {
            props.initialSelectedItemKeys.forEach(function (key) { return initialSelectedItemKeys.add(key); });
        }
        var initialExpandedItemKeys = new Set();
        if (props.initialExpandedItemKeys) {
            props.initialExpandedItemKeys.forEach(function (key) { return initialExpandedItemKeys.add(key); });
        }
        _this.state = TreeBase_1._getStateFromProps(props, {
            items: [],
            visibleItems: [],
            visibleItemKeys: new Set(),
            cachedItemKeys: new Set(),
            keyToItemMap: new Map(),
            keyToVisibleIndexMap: new Map(),
            selectedItemKeys: initialSelectedItemKeys,
            expandedItemKeys: initialExpandedItemKeys,
            areExpandedItemsDirty: true,
            moreIcon: 'More',
            collapsedArrowIcon: 'ChevronRight'
        });
        return _this;
    }
    TreeBase_1 = TreeBase;
    TreeBase._getStateFromProps = function (nextProps, prevState) {
        var newState = prevState;
        var iconsProp = nextProps.icons;
        var itemsHaveChanged = nextProps.items !== prevState.items;
        var expandedItemKeysHaveChanged = prevState.areExpandedItemsDirty ||
            (nextProps.expandedItemKeys && nextProps.expandedItemKeys !== prevState.expandedItemKeys);
        newState.items = nextProps.items;
        newState.areExpandedItemsDirty = false;
        if (nextProps.selectedItemKeys) {
            newState.selectedItemKeys = nextProps.selectedItemKeys;
        }
        if (nextProps.expandedItemKeys) {
            newState.expandedItemKeys = nextProps.expandedItemKeys;
        }
        if (iconsProp) {
            if (iconsProp.more && iconsProp.more !== prevState.moreIcon) {
                newState.moreIcon = iconsProp.more;
            }
            if (iconsProp.collapsedArrow && iconsProp.collapsedArrow !== prevState.collapsedArrowIcon) {
                newState.collapsedArrowIcon = iconsProp.collapsedArrow;
            }
        }
        if (itemsHaveChanged || expandedItemKeysHaveChanged) {
            var keyToVisibleIndexMap_1 = new Map();
            var visibleItemKeys_1 = new Set();
            var visibleItems_1 = [];
            var keyToItemMap_1 = itemsHaveChanged ? new Map() : null;
            var cachedItemKeys_1 = itemsHaveChanged ? new Set() : newState.cachedItemKeys;
            var lastCollapsedLevel_1 = maxInt;
            var visibleIndex_1 = 0;
            nextProps.items.forEach(function (item, index) {
                if (keyToItemMap_1) {
                    keyToItemMap_1.set(item.key, item);
                }
                if (item.level <= lastCollapsedLevel_1) {
                    if (newState.expandedItemKeys.has(item.key)) {
                        lastCollapsedLevel_1 = maxInt;
                    }
                    else {
                        lastCollapsedLevel_1 = item.level;
                    }
                    if (visibleItems_1) {
                        visibleItems_1.push(item);
                    }
                    else {
                        cachedItemKeys_1.add(item.key);
                    }
                    visibleItemKeys_1.add(item.key);
                    keyToVisibleIndexMap_1.set(item.key, visibleIndex_1++);
                }
            });
            newState.keyToVisibleIndexMap = keyToVisibleIndexMap_1;
            newState.visibleItemKeys = visibleItemKeys_1;
            if (visibleItems_1) {
                newState.visibleItems = visibleItems_1;
            }
            if (keyToItemMap_1) {
                newState.keyToItemMap = keyToItemMap_1;
            }
            if (cachedItemKeys_1) {
                newState.cachedItemKeys = cachedItemKeys_1;
            }
        }
        return newState;
    };
    TreeBase.getDerivedStateFromProps = function (nextProps, prevState) {
        if (!prevState) {
            return null;
        }
        return TreeBase_1._getStateFromProps(nextProps, prevState);
    };
    TreeBase.prototype.componentDidUpdate = function () {
        this._applyPendingScroll();
    };
    TreeBase.prototype.render = function () {
        this._classNames = this._getClassNames(this.props);
        return (React.createElement("div", { className: Styling_1.mergeStyles(this._classNames.root) },
            React.createElement("div", { className: Styling_1.mergeStyles(this._classNames.innerRoot) },
                React.createElement(FocusZone_1.FocusZone, { componentRef: this._focusZone, direction: FocusZone_1.FocusZoneDirection.vertical, className: this._classNames.focusZone }, this._renderScrollViewAndList()))));
    };
    /**
     * Sets focus to the first tree node.
     */
    TreeBase.prototype.focus = function () {
        if (this._focusZone.current) {
            this._focusZone.current.focus();
        }
    };
    TreeBase.prototype._getKey = function (item) {
        return item.key;
    };
    TreeBase.prototype._cloneSet = function (set) {
        var newSet = new Set();
        set.forEach(function (key) { return newSet.add(key); });
        return newSet;
    };
    TreeBase.prototype._getNodeHeight = function (props) {
        var nodeHeight = props.nodeHeight;
        return nodeHeight === undefined || nodeHeight === null ? exports.defaultNodeHeight : nodeHeight;
    };
    TreeBase.prototype._getIconWidth = function (props) {
        var iconWidth = props.iconWidth;
        return iconWidth === undefined || iconWidth === null ? exports.defaultIconWidth : iconWidth;
    };
    TreeBase.prototype._getClassNames = function (props) {
        var className = props.className, theme = props.theme;
        var classNames = getClassNames(props.styles, {
            className: className,
            theme: theme,
            nodeHeight: this._getNodeHeight(props),
            iconWidth: this._getIconWidth(props)
        });
        var unselectableItem = Styling_1.mergeStyles(classNames.item, classNames.itemIsNotSelected, classNames.itemIsNotSelectable);
        var item = Styling_1.mergeStyles(classNames.item, classNames.itemIsSelectable, classNames.itemIsNotSelected);
        var selectedItem = Styling_1.mergeStyles(classNames.item, classNames.itemIsSelectable, classNames.itemIsSelected);
        var expandIconExpanded = Styling_1.mergeStyles(classNames.expandIcon, classNames.expandIconExpanded);
        var expandIconButton = Styling_1.mergeStyles(classNames.expandIconButton, classNames.expandIconButtonEnabled);
        var expandIconButtonDisabled = Styling_1.mergeStyles(classNames.expandIconButton, classNames.expandIconButtonDisabled);
        this._cachedStyles = {
            unselectableItem: unselectableItem,
            item: item,
            selectedItem: selectedItem,
            expandIconExpanded: expandIconExpanded,
            expandIconButton: expandIconButton,
            expandIconButtonDisabled: expandIconButtonDisabled
        };
        return classNames;
    };
    var TreeBase_1;
    TreeBase = TreeBase_1 = tslib_1.__decorate([
        Utilities_1.customizable('Tree', ['theme', 'styles'])
    ], TreeBase);
    return TreeBase;
}(Utilities_1.BaseComponent));
exports.TreeBase = TreeBase;
//# sourceMappingURL=Tree.base.js.map