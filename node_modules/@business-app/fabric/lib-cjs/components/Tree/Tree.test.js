"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomScrollView = void 0;
var tslib_1 = require("tslib");
var enzyme_1 = require("enzyme");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var React = require("react");
var ContextualMenuButton_1 = require("./ContextualMenuButton/ContextualMenuButton");
var Tree_1 = require("./Tree");
var Tree_selectors_1 = require("./Tree.selectors");
var Tree_types_1 = require("./Tree.types");
var TreeNode_1 = require("./TreeNode/TreeNode");
function getStateOf(wrapper) {
    var instance = wrapper.childAt(0).childAt(0).instance();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return instance.state;
}
function getDefaultProps(overrides) {
    return tslib_1.__assign({ items: getMockItems([{}, {}]), strings: {
            listAriaLabel: 'list aria label',
            moreCommandsAriaLabel: 'more commands aria label'
        } }, overrides);
}
function getMockItems(items, treeItems, level, parentIndex) {
    if (treeItems === void 0) { treeItems = []; }
    if (level === void 0) { level = 0; }
    if (parentIndex === void 0) { parentIndex = -1; }
    items.forEach(function (item, indexInParent) {
        var children = item.children, restItem = tslib_1.__rest(item, ["children"]);
        var itemId = level + " " + parentIndex + " " + indexInParent;
        // Add the item
        treeItems.push(tslib_1.__assign({ label: itemId, key: itemId, isFolder: !!children, level: level, setSize: items.length, indexInParent: indexInParent, testPropertyA: level * 100 + indexInParent, testPropertyB: itemId }, restItem));
        // If the item is a category and has children, add the children
        if (item.children) {
            getMockItems(item.children, treeItems, level + 1, indexInParent);
        }
    });
    return treeItems;
}
describe('Tree', function () {
    describe('Collapse/Expand', function () {
        it('initialExpandedItemKeys', function () {
            var props = getDefaultProps({
                items: getMockItems([
                    {
                        key: 'one',
                        children: [{ key: 'two' }]
                    },
                    {
                        key: 'three',
                        children: [{ key: 'four' }]
                    }
                ]),
                initialExpandedItemKeys: new Set(['three'])
            });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            expect(getStateOf(wrapper).expandedItemKeys.has('three')).toBeTruthy();
            expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
            wrapper.unmount();
        });
        it('expandedItemKeys has higher precedence than initialExpandedItemKeys', function () {
            var props = getDefaultProps({
                items: getMockItems([
                    {
                        key: 'one',
                        children: [
                            {
                                key: 'two',
                                children: [{ key: 'three' }]
                            }
                        ]
                    },
                    {
                        key: 'four',
                        children: [{ key: 'five' }]
                    }
                ]),
                initialExpandedItemKeys: new Set(['four']),
                expandedItemKeys: new Set(['two'])
            });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            expect(getStateOf(wrapper).expandedItemKeys.has('one')).toBeFalsy();
            expect(getStateOf(wrapper).expandedItemKeys.has('two')).toBeTruthy();
            expect(getStateOf(wrapper).expandedItemKeys.has('four')).toBeFalsy();
            wrapper.unmount();
        });
        it('TreeNodes should only be rendered if parents are expanded', function () {
            var items = getMockItems([
                {
                    key: 'one',
                    children: [
                        {
                            key: 'two',
                            children: [{ key: 'three' }]
                        },
                        { key: 'four' },
                        { key: 'five' }
                    ]
                },
                {
                    key: 'six',
                    children: [{ key: 'seven' }]
                },
                { key: 'eight' }
            ]);
            var props = getDefaultProps({ items: items, expandedItemKeys: new Set() });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            // Child node should be hidden since parent is collapsed by default.
            expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(3);
            wrapper.setProps({ expandedItemKeys: new Set(['one']) });
            // Child node should exist now that parent is expanded.
            expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(6);
            wrapper.setProps({ expandedItemKeys: new Set(['one', 'two']) });
            // Expand inner folder, too.
            expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(7);
            wrapper.setProps({ expandedItemKeys: new Set(['two']) });
            // Collapse out (inner expanded, but not shown because outer).
            expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(3);
            wrapper.setProps({ expandedItemKeys: new Set(['one', 'two']) });
            // Expand outer again, inner still expanded.
            expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(7);
            wrapper.unmount();
        });
    });
    describe('Selection', function () {
        it('initialSelectedItemKeys', function () {
            var props = getDefaultProps({
                items: getMockItems([
                    { key: 'one' },
                    { key: 'two' },
                    { key: 'three' },
                    { key: 'four' },
                    { key: 'five' },
                    { key: 'six' }
                ]),
                initialSelectedItemKeys: new Set(['two', 'four'])
            });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            expect(getStateOf(wrapper).selectedItemKeys.has('two')).toBeTruthy();
            expect(getStateOf(wrapper).selectedItemKeys.has('four')).toBeTruthy();
            expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(2);
            wrapper.unmount();
        });
        it('selectedItemKeys has higher precedence than initialSelectedItemKeys', function () {
            var props = getDefaultProps({
                items: getMockItems([
                    { key: 'one' },
                    { key: 'two' },
                    { key: 'three' },
                    { key: 'four' },
                    { key: 'five' },
                    { key: 'six' }
                ]),
                initialSelectedItemKeys: new Set(['two', 'four']),
                selectedItemKeys: new Set(['three', 'five'])
            });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            expect(getStateOf(wrapper).selectedItemKeys.has('one')).toBeFalsy();
            expect(getStateOf(wrapper).selectedItemKeys.has('two')).toBeFalsy();
            expect(getStateOf(wrapper).selectedItemKeys.has('three')).toBeTruthy();
            expect(getStateOf(wrapper).selectedItemKeys.has('four')).toBeFalsy();
            expect(getStateOf(wrapper).selectedItemKeys.has('five')).toBeTruthy();
            expect(getStateOf(wrapper).selectedItemKeys.has('six')).toBeFalsy();
            wrapper.unmount();
        });
        it('selectedItemKeys', function () {
            var props = getDefaultProps({
                items: getMockItems([
                    { key: 'one' },
                    { key: 'two' },
                    { key: 'three' },
                    { key: 'four' },
                    { key: 'five' },
                    { key: 'six' }
                ]),
                selectedItemKeys: new Set()
            });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
            expect(wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode().getAttribute('aria-selected')).toEqual('false');
            wrapper.setProps({ selectedItemKeys: new Set(['two']) });
            expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
            expect(getStateOf(wrapper).selectedItemKeys.has('two')).toBeTruthy();
            expect(wrapper.find(TreeNode_1.TreeNode).at(1).getDOMNode().getAttribute('aria-selected')).toEqual('true');
            wrapper.setProps({ selectedItemKeys: new Set(['three']) });
            expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
            expect(getStateOf(wrapper).selectedItemKeys.has('three')).toBeTruthy();
            expect(wrapper.find(TreeNode_1.TreeNode).at(2).getDOMNode().getAttribute('aria-selected')).toEqual('true');
            wrapper.setProps({ selectedItemKeys: new Set(['three', 'five']) });
            expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(2);
            expect(getStateOf(wrapper).selectedItemKeys.has('three')).toBeTruthy();
            expect(getStateOf(wrapper).selectedItemKeys.has('five')).toBeTruthy();
            expect(wrapper.find(TreeNode_1.TreeNode).at(2).getDOMNode().getAttribute('aria-selected')).toEqual('true');
            expect(wrapper.find(TreeNode_1.TreeNode).at(4).getDOMNode().getAttribute('aria-selected')).toEqual('true');
            wrapper.setProps({ selectedItemKeys: new Set() });
            expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
            expect(wrapper.find(TreeNode_1.TreeNode).at(2).getDOMNode().getAttribute('aria-selected')).toEqual('false');
            expect(wrapper.find(TreeNode_1.TreeNode).at(4).getDOMNode().getAttribute('aria-selected')).toEqual('false');
            wrapper.unmount();
        });
        it('Selection changes should result in node re-renders when necessary', function () {
            var onRenderItemLabel = jest.fn();
            var props = getDefaultProps({
                items: getMockItems([{ key: 'one' }, { key: 'two' }]),
                selectedItemKeys: new Set(),
                onRenderItemLabel: onRenderItemLabel
            });
            var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
            var isNodeSelected = function (index) { return wrapper.find(TreeNode_1.TreeNode).at(index).props().isSelected; };
            expect(isNodeSelected(0)).toEqual(false);
            expect(isNodeSelected(1)).toEqual(false);
            expect(onRenderItemLabel).toBeCalledTimes(2);
            onRenderItemLabel.mockReset();
            wrapper.setProps({ selectedItemKeys: new Set(['two']) });
            expect(isNodeSelected(0)).toEqual(false);
            expect(isNodeSelected(1)).toEqual(true);
            expect(onRenderItemLabel).toHaveBeenCalled();
        });
    });
    it('onRenderItemContainer/onRenderItemLabel/getItemStyle callback arguments', function () {
        var onRenderItemContainer = jest.fn(function (item, isSelected, isExpanded, index, defaultItemRender) {
            return defaultItemRender();
        });
        var onRenderItemLabel = jest.fn();
        var getItemStyle = jest.fn();
        var assertFunction = function (expectedItem, expectSelected, expectExpanded, expectedIndex) {
            expect(onRenderItemContainer.mock.calls[expectedIndex][0]).toEqual(expectedItem);
            expect(onRenderItemContainer.mock.calls[expectedIndex][1]).toEqual(expectSelected);
            expect(onRenderItemContainer.mock.calls[expectedIndex][2]).toEqual(expectExpanded);
            expect(onRenderItemContainer.mock.calls[expectedIndex][3]).toEqual(expectedIndex);
            expect(onRenderItemContainer.mock.calls[expectedIndex][4]).toBeDefined();
            expect(onRenderItemLabel.mock.calls[expectedIndex][0]).toEqual(expectedItem);
            expect(onRenderItemLabel.mock.calls[expectedIndex][1]).toEqual(expectSelected);
            expect(onRenderItemLabel.mock.calls[expectedIndex][2]).toEqual(expectExpanded);
            expect(onRenderItemLabel.mock.calls[expectedIndex][3]).toEqual(expectedIndex);
            expect(getItemStyle.mock.calls[expectedIndex][0]).toEqual(expectedItem);
            expect(getItemStyle.mock.calls[expectedIndex][1]).toEqual(expectSelected);
            expect(getItemStyle.mock.calls[expectedIndex][2]).toEqual(expectExpanded);
            expect(getItemStyle.mock.calls[expectedIndex][3]).toEqual(expectedIndex);
        };
        var items = getMockItems([
            { key: 'one' },
            { key: 'two' },
            {
                key: 'three',
                children: [{ key: 'four' }]
            },
            {
                key: 'five',
                children: [{ key: 'six' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            selectedItemKeys: new Set(['two', 'five']),
            expandedItemKeys: new Set(['three', 'five']),
            onRenderItemContainer: onRenderItemContainer,
            onRenderItemLabel: onRenderItemLabel,
            getItemStyle: getItemStyle
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        assertFunction(items[0], false, false, 0);
        assertFunction(items[1], true, false, 1);
        assertFunction(items[2], false, true, 2);
        assertFunction(items[3], false, false, 3);
        assertFunction(items[4], true, true, 4);
        assertFunction(items[5], false, false, 5);
        expect(onRenderItemContainer).toHaveBeenCalledTimes(6);
        expect(onRenderItemLabel).toHaveBeenCalledTimes(6);
        wrapper.unmount();
    });
    it('Should render labels when no onRenderItemLabel is provided', function () {
        var items = getMockItems([{ label: 'one' }, { label: 'two' }]);
        var props = getDefaultProps({ items: items });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode().innerHTML.indexOf('one')).toBeGreaterThan(-1);
        expect(wrapper.find(TreeNode_1.TreeNode).at(1).getDOMNode().innerHTML.indexOf('two')).toBeGreaterThan(-1);
        wrapper.unmount();
    });
    it('onRenderItemContainer should work', function () {
        var wrappingClassName = 'new-class-for-test';
        var wrappingClassNameSelector = "." + wrappingClassName;
        var onRenderItemContainer = function (item, isSelected, isExpanded, index, defaultItemRender) {
            return React.createElement("div", { className: wrappingClassName }, defaultItemRender());
        };
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, { items: [
                {
                    label: 'label',
                    key: 'key',
                    level: 0,
                    setSize: 1,
                    indexInParent: 0,
                    customProperty: 'pizza'
                }
            ], strings: {
                listAriaLabel: 'list',
                moreCommandsAriaLabel: 'more commands'
            }, onRenderItemContainer: onRenderItemContainer }));
        var numberOfNodes = wrapper.find(TreeNode_1.TreeNode).length;
        expect(numberOfNodes).toBeGreaterThan(0);
        expect(wrapper.find(wrappingClassNameSelector).length).toEqual(numberOfNodes);
        wrapper.setProps({ onRenderItemContainer: undefined });
        expect(wrapper.find(wrappingClassNameSelector).length).toEqual(0);
        expect(wrapper.find(TreeNode_1.TreeNode).length).toBeGreaterThan(0);
        wrapper.unmount();
    });
    it('onRenderItemLabel should work and allow access to custom item properties', function () {
        var onRenderItemLabel = function (item) {
            return React.createElement("span", null, item.customProperty);
        };
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, { items: [
                {
                    label: 'label',
                    key: 'key',
                    level: 0,
                    setSize: 1,
                    indexInParent: 0,
                    customProperty: 'pizza'
                }
            ], strings: {
                listAriaLabel: 'list',
                moreCommandsAriaLabel: 'more commands'
            }, onRenderItemLabel: onRenderItemLabel }));
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode().innerHTML.indexOf('pizza')).toBeGreaterThan(-1);
        wrapper.unmount();
    });
    it('onRenderItemLabelContent should work and allow access to custom item properties', function () {
        var onRenderItemLabelContent = function (item) {
            return React.createElement("span", null, item.customProperty);
        };
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, { items: [
                {
                    label: 'label',
                    key: 'key',
                    level: 0,
                    setSize: 1,
                    indexInParent: 0,
                    customProperty: 'pizza'
                }
            ], strings: {
                listAriaLabel: 'list',
                moreCommandsAriaLabel: 'more commands'
            }, onRenderItemLabelContent: onRenderItemLabelContent }));
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode().innerHTML.indexOf('pizza')).toBeGreaterThan(-1);
        wrapper.unmount();
    });
    it('onRenderExpandIcon should work and allow access to custom item properties', function () {
        var onRenderExpandIcon = function (item) {
            return React.createElement("span", null, item.customProperty);
        };
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, { items: [
                {
                    label: 'label',
                    key: 'key',
                    level: 0,
                    setSize: 1,
                    indexInParent: 0,
                    customProperty: 'pizza'
                }
            ], strings: {
                listAriaLabel: 'list',
                moreCommandsAriaLabel: 'more commands'
            }, onRenderExpandIcon: onRenderExpandIcon }));
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode().innerHTML.indexOf('pizza')).toBeGreaterThan(-1);
        wrapper.unmount();
    });
    it('Uncontrolled onItemExpand/onItemCollapse', function () {
        var onItemExpand = jest.fn();
        var onItemCollapse = jest.fn();
        var collapseExpandSelector = "." + Tree_selectors_1.TreeAutomationSelectors.collapseExpandClassName;
        var items = getMockItems([
            {
                key: 'one',
                children: [
                    {
                        key: 'two',
                        children: [{ key: 'three' }]
                    }
                ]
            },
            {
                key: 'four',
                children: [{ key: 'five' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            initialExpandedItemKeys: new Set(['four']),
            onItemExpand: onItemExpand,
            onItemCollapse: onItemCollapse
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('four')).toEqual(true);
        // Expand the first node
        wrapper.find(collapseExpandSelector).at(0).simulate('click');
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(2);
        expect(getStateOf(wrapper).expandedItemKeys.has('one')).toEqual(true);
        expect(onItemExpand).toHaveBeenCalledTimes(1);
        expect(onItemExpand).toHaveBeenLastCalledWith(items[0], 0);
        // Expand the first node's child node
        wrapper.find(collapseExpandSelector).at(1).simulate('click');
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(3);
        expect(getStateOf(wrapper).expandedItemKeys.has('one')).toEqual(true);
        expect(getStateOf(wrapper).expandedItemKeys.has('two')).toEqual(true);
        expect(onItemExpand).toHaveBeenCalledTimes(2);
        expect(onItemExpand).toHaveBeenLastCalledWith(items[1], 1);
        // Collapse the first node
        wrapper.find(collapseExpandSelector).at(0).simulate('click');
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(2);
        expect(getStateOf(wrapper).expandedItemKeys.has('one')).toEqual(false);
        expect(getStateOf(wrapper).expandedItemKeys.has('two')).toEqual(true);
        expect(getStateOf(wrapper).expandedItemKeys.has('four')).toEqual(true);
        expect(onItemCollapse).toHaveBeenCalledTimes(1);
        expect(onItemCollapse).toHaveBeenLastCalledWith(items[0], 0);
        wrapper.find(collapseExpandSelector).at(1).simulate('click');
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('two')).toEqual(true);
        expect(getStateOf(wrapper).expandedItemKeys.has('four')).toEqual(false);
        expect(onItemCollapse).toHaveBeenCalledTimes(2);
        expect(onItemCollapse).toHaveBeenLastCalledWith(items[3], 1);
        wrapper.unmount();
    });
    it('Controlled onItemExpand/onItemCollapse', function () {
        var onItemExpand = jest.fn();
        var onItemCollapse = jest.fn();
        var collapseExpandSelector = "." + Tree_selectors_1.TreeAutomationSelectors.collapseExpandClassName;
        var items = getMockItems([
            {
                key: 'one',
                children: [
                    {
                        key: 'two',
                        children: [{ key: 'three' }]
                    }
                ]
            },
            {
                key: 'four',
                children: [{ key: 'five' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            expandedItemKeys: new Set(['four']),
            onItemExpand: onItemExpand,
            onItemCollapse: onItemCollapse
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('four')).toEqual(true);
        // Expand the first node (but it won't actually expand because it's controlled)
        wrapper.find(collapseExpandSelector).at(0).simulate('click');
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('four')).toEqual(true);
        expect(onItemExpand).toHaveBeenCalledTimes(1);
        expect(onItemExpand).toHaveBeenLastCalledWith(items[0], 0);
        // Collapse the fourth node (but it won't actually collapse because it's controlled)
        wrapper.find(collapseExpandSelector).at(1).simulate('click');
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('four')).toEqual(true);
        expect(onItemCollapse).toHaveBeenCalledTimes(1);
        expect(onItemCollapse).toHaveBeenLastCalledWith(items[3], 1);
        wrapper.unmount();
    });
    it('onItemDoubleClicked', function () {
        var onItemDoubleClicked = jest.fn();
        var onItemSelected = jest.fn();
        var collapseExpandSelector = "." + Tree_selectors_1.TreeAutomationSelectors.collapseExpandClassName;
        var items = getMockItems([
            {
                key: 'one',
                children: [{ key: 'two' }]
            },
            { key: 'three' },
            {
                key: 'four',
                children: [{ key: 'five' }]
            },
            {
                key: 'six',
                children: [{ key: 'seven' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            expandedItemKeys: new Set(['four', 'six']),
            selectedItemKeys: new Set(['three', 'six']),
            onItemDoubleClicked: onItemDoubleClicked,
            onItemSelected: onItemSelected,
            onRenderItemLabel: function () { return null; },
            onItemExpand: function () { return undefined; },
            onItemCollapse: function () { return undefined; },
            getItemCommands: function () { return []; }
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        // Double click a not selected and not expanded node.
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('doubleclick');
        expect(onItemDoubleClicked).toHaveBeenCalledTimes(1);
        expect(onItemDoubleClicked).toHaveBeenLastCalledWith(items[0], false, false, 0);
        // Double clicking should also trigger onItemSelected
        expect(onItemSelected).toHaveBeenCalledTimes(0);
        // Double click a selected but not expanded node.
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('doubleclick');
        expect(onItemDoubleClicked).toHaveBeenCalledTimes(2);
        expect(onItemDoubleClicked).toHaveBeenLastCalledWith(items[2], true, false, 1);
        expect(onItemSelected).toHaveBeenCalledTimes(0);
        // Double click an expanded but not selected node.
        wrapper.find(TreeNode_1.TreeNode).at(2).simulate('doubleclick');
        expect(onItemDoubleClicked).toHaveBeenCalledTimes(3);
        expect(onItemDoubleClicked).toHaveBeenLastCalledWith(items[3], false, true, 2);
        expect(onItemSelected).toHaveBeenCalledTimes(0);
        // Double click a node that is both selected and expanded.
        wrapper.find(TreeNode_1.TreeNode).at(4).simulate('doubleclick');
        expect(onItemDoubleClicked).toHaveBeenCalledTimes(4);
        expect(onItemDoubleClicked).toHaveBeenLastCalledWith(items[5], true, true, 4);
        expect(onItemSelected).toHaveBeenCalledTimes(0);
        onItemDoubleClicked.mockReset();
        onItemSelected.mockReset();
        // Double clicking the expand/collapse icon should not trigger the onItemDoubleClicked
        wrapper.find(collapseExpandSelector).at(0).simulate('doubleclick');
        expect(onItemDoubleClicked).toHaveBeenCalledTimes(0);
        expect(onItemSelected).toHaveBeenCalledTimes(0);
        // Double clicking the contextual menu button should not trigger the onItemDoubleClicked
        wrapper.find(ContextualMenuButton_1.ContextualMenuButton).at(0).simulate('doubleclick');
        expect(onItemDoubleClicked).toHaveBeenCalledTimes(0);
        expect(onItemSelected).toHaveBeenCalledTimes(0);
        wrapper.unmount();
    });
    it('moreCommandsAriaLabel', function () {
        var items = getMockItems([
            {
                key: 'one',
                children: [{ key: 'two' }],
                moreCommandsAriaLabel: 'commands one'
            },
            { key: 'three' },
            {
                key: 'four',
                children: [{ key: 'five' }],
                moreCommandsAriaLabel: 'commands four'
            },
            {
                key: 'six',
                children: [{ key: 'seven' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            expandedItemKeys: new Set(['four', 'six']),
            selectedItemKeys: new Set(['three', 'six']),
            getItemCommands: function () { return []; },
            strings: {
                listAriaLabel: 'list',
                moreCommandsAriaLabel: 'default commands'
            }
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        // It should use the moreCommandsAriaLabel for the item, if provided, and the global one otherwise.
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).props().moreCommandsAriaLabel).toEqual('commands one');
        expect(wrapper.find(TreeNode_1.TreeNode).at(1).props().moreCommandsAriaLabel).toEqual('default commands');
        expect(wrapper.find(TreeNode_1.TreeNode).at(2).props().moreCommandsAriaLabel).toEqual('commands four');
        expect(wrapper.find(TreeNode_1.TreeNode).at(3).props().moreCommandsAriaLabel).toEqual('default commands');
        wrapper.unmount();
    });
    it('Uncontrolled onItemSelected', function () {
        var onItemSelected = jest.fn();
        var items = getMockItems([
            { key: 'one' },
            { key: 'two' },
            { key: 'three' },
            { key: 'four' },
            { key: 'five', disableSelection: true }
        ]);
        var props = getDefaultProps({
            items: items,
            onItemSelected: onItemSelected
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
        // Unselectable nodes should not be selectable
        wrapper.find(TreeNode_1.TreeNode).at(4).simulate('click');
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click');
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('one')).toEqual(true);
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('click');
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click', { ctrlKey: true });
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(2);
        expect(getStateOf(wrapper).selectedItemKeys.has('one')).toEqual(true);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click', { ctrlKey: true });
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        wrapper.unmount();
    });
    it('Controlled onItemSelected and arguments', function () {
        var onItemSelected = jest.fn();
        var items = getMockItems([{ key: 'one' }, { key: 'two' }]);
        var props = getDefaultProps({
            items: items,
            onItemSelected: onItemSelected,
            selectedItemKeys: new Set(['two'])
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click');
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        expect(onItemSelected).toHaveBeenLastCalledWith(items[0], Tree_types_1.SelectionType.Single, false, false, 0);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click', { ctrlKey: true });
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        expect(onItemSelected).toHaveBeenLastCalledWith(items[0], Tree_types_1.SelectionType.Toggle, false, false, 0);
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('click');
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        expect(onItemSelected).toHaveBeenLastCalledWith(items[1], Tree_types_1.SelectionType.Single, true, false, 1);
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('click', { ctrlKey: true });
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).selectedItemKeys.has('two')).toEqual(true);
        expect(onItemSelected).toHaveBeenLastCalledWith(items[1], Tree_types_1.SelectionType.Toggle, true, false, 1);
        items = getMockItems([
            {
                key: 'one',
                children: [{ key: 'two' }]
            }
        ]);
        wrapper.setProps({
            items: items,
            selectedItemKeys: new Set(),
            expandedItemKeys: new Set(['one'])
        });
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click');
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
        expect(onItemSelected).toHaveBeenLastCalledWith(items[0], Tree_types_1.SelectionType.Single, false, true, 0);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('click', { ctrlKey: true });
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(0);
        expect(onItemSelected).toHaveBeenLastCalledWith(items[0], Tree_types_1.SelectionType.Toggle, false, true, 0);
        wrapper.unmount();
    });
    it('onItemKeyDown arguments', function () {
        var onItemKeyDown = jest.fn();
        var items = getMockItems([
            { key: 'one' },
            { key: 'two' },
            {
                key: 'three',
                children: [{ key: 'four' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            onItemKeyDown: onItemKeyDown,
            selectedItemKeys: new Set(['two']),
            expandedItemKeys: new Set(['three'])
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(getStateOf(wrapper).selectedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('keyDown', { key: 'q' });
        var event = onItemKeyDown.mock.calls[0][4];
        expect(onItemKeyDown).toHaveBeenLastCalledWith(items[0], false, false, 0, event);
        expect(event.key).toEqual('q');
        expect(event.ctrlKey).toEqual(undefined);
        onItemKeyDown.mockReset();
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('keyDown', { key: 'p', ctrlKey: true });
        event = onItemKeyDown.mock.calls[0][4];
        expect(onItemKeyDown).toHaveBeenLastCalledWith(items[1], true, false, 1, event);
        expect(event.key).toEqual('p');
        expect(event.ctrlKey).toEqual(true);
        onItemKeyDown.mockReset();
        wrapper.find(TreeNode_1.TreeNode).at(2).simulate('keyDown', { key: 'a', altKey: true });
        event = onItemKeyDown.mock.calls[0][4];
        expect(onItemKeyDown).toHaveBeenLastCalledWith(items[2], false, true, 2, event);
        expect(event.key).toEqual('a');
        expect(event.altKey).toEqual(true);
        wrapper.unmount();
    });
    it('onRenderContextualMenu arguments', function () {
        var onRenderContextualMenu = jest.fn();
        var items = getMockItems([
            { key: 'one' },
            { key: 'two' },
            {
                key: 'three',
                children: [{ key: 'four' }]
            }
        ]);
        var props = getDefaultProps({
            items: items,
            getItemCommands: function () { return [
                {
                    key: 'New',
                    text: 'New',
                    iconProps: { iconName: 'Add' }
                },
                {
                    key: 'Mail',
                    text: 'Mail',
                    iconProps: { iconName: 'Mail' }
                }
            ]; },
            onRenderContextualMenu: onRenderContextualMenu,
            selectedItemKeys: new Set(['two']),
            expandedItemKeys: new Set(['three'])
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(onRenderContextualMenu).toHaveBeenCalledTimes(0);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('contextmenu');
        var menuProps = onRenderContextualMenu.mock.calls[0][4];
        expect(onRenderContextualMenu).toHaveBeenCalledTimes(1);
        expect(onRenderContextualMenu).toHaveBeenLastCalledWith(items[0], false, false, 0, menuProps);
        expect(menuProps.items.length).toEqual(2);
        onRenderContextualMenu.mockReset();
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('keydown', { keyCode: Utilities_1.KeyCodes.f10, shiftKey: true });
        menuProps = onRenderContextualMenu.mock.calls[0][4];
        expect(onRenderContextualMenu).toHaveBeenCalledTimes(1);
        expect(onRenderContextualMenu).toHaveBeenLastCalledWith(items[1], true, false, 1, menuProps);
        expect(menuProps.items.length).toEqual(2);
        onRenderContextualMenu.mockReset();
        wrapper.find(TreeNode_1.TreeNode).at(2).find(ContextualMenuButton_1.ContextualMenuButton).simulate('click');
        menuProps = onRenderContextualMenu.mock.calls[0][4];
        expect(onRenderContextualMenu).toHaveBeenCalledTimes(1);
        expect(onRenderContextualMenu).toHaveBeenLastCalledWith(items[2], false, true, 2, menuProps);
        expect(menuProps.items.length).toEqual(2);
        wrapper.unmount();
    });
    it('Uncontrolled: Should be able to collapse/expand nodes via keyboard', function () {
        var items = getMockItems([
            {
                key: 'one',
                children: [
                    {
                        key: 'two',
                        children: [{ key: 'three' }]
                    }
                ]
            }
        ]);
        var props = getDefaultProps({
            items: items
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(0);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('keyDown', { keyCode: Utilities_1.KeyCodes.right });
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('one')).toEqual(true);
        wrapper.find(TreeNode_1.TreeNode).at(1).simulate('keyDown', { keyCode: Utilities_1.KeyCodes.right });
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(2);
        expect(getStateOf(wrapper).expandedItemKeys.has('one')).toEqual(true);
        expect(getStateOf(wrapper).expandedItemKeys.has('two')).toEqual(true);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('keyDown', { keyCode: Utilities_1.KeyCodes.left });
        expect(getStateOf(wrapper).expandedItemKeys.size).toEqual(1);
        expect(getStateOf(wrapper).expandedItemKeys.has('two')).toEqual(true);
        wrapper.unmount();
    });
    it('Shift+F10 should open the contextual menu', function () {
        var menuOpenSelector = "." + Tree_selectors_1.TreeAutomationSelectors.openMenuClassName;
        var items = getMockItems([{ key: 'one' }, { key: 'two' }]);
        var props = getDefaultProps({
            items: items,
            getItemCommands: function () { return [
                {
                    key: 'New',
                    text: 'New',
                    iconProps: { iconName: 'Add' }
                },
                {
                    key: 'Mail',
                    text: 'Mail',
                    iconProps: { iconName: 'Mail' }
                }
            ]; }
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).find(menuOpenSelector).length).toEqual(0);
        expect(wrapper.find(TreeNode_1.TreeNode).at(1).find(menuOpenSelector).length).toEqual(0);
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('keydown', { keyCode: Utilities_1.KeyCodes.f10, shiftKey: true });
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).find(menuOpenSelector).length).toBeGreaterThan(0);
        expect(wrapper.find(TreeNode_1.TreeNode).at(1).find(menuOpenSelector).length).toEqual(0);
        wrapper.unmount();
    });
    it('Shift+F10 should not open the contextual menu when disabled', function () {
        var menuOpenSelector = "." + Tree_selectors_1.TreeAutomationSelectors.openMenuClassName;
        var items = getMockItems([{ key: 'one' }, { key: 'two' }]);
        var props = getDefaultProps({
            items: items,
            getItemCommands: function () { return [
                {
                    key: 'New',
                    text: 'New',
                    iconProps: { iconName: 'Add' }
                },
                {
                    key: 'Mail',
                    text: 'Mail',
                    iconProps: { iconName: 'Mail' }
                }
            ]; },
            getItemIsDisabled: function () { return true; }
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        wrapper.find(TreeNode_1.TreeNode).at(0).simulate('keydown', { keyCode: Utilities_1.KeyCodes.f10, shiftKey: true });
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).find(menuOpenSelector).length).toEqual(0);
        wrapper.unmount();
    });
    it('TreeNodes should render in the correct order', function () {
        var items = getMockItems([
            {
                label: 'one',
                key: 'one',
                children: [
                    {
                        label: 'two',
                        key: 'two',
                        children: [{ label: 'three', key: 'three' }]
                    },
                    { label: 'four', key: 'four' }
                ]
            },
            { label: 'five', key: 'five' }
        ]);
        var props = getDefaultProps({ items: items, expandedItemKeys: new Set(['one', 'two']) });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(5);
        expect(wrapper.find(TreeNode_1.TreeNode).at(0).props().label).toEqual('one');
        expect(wrapper.find(TreeNode_1.TreeNode).at(1).props().label).toEqual('two');
        expect(wrapper.find(TreeNode_1.TreeNode).at(2).props().label).toEqual('three');
        expect(wrapper.find(TreeNode_1.TreeNode).at(3).props().label).toEqual('four');
        expect(wrapper.find(TreeNode_1.TreeNode).at(4).props().label).toEqual('five');
        wrapper.unmount();
    });
    it('focus', function () {
        var props = getDefaultProps();
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var instance = wrapper.childAt(0).childAt(0).instance();
        expect(instance.focus).toBeDefined();
        var focusZoneFn = jest.fn();
        instance._focusZone.current.focus = focusZoneFn;
        instance.focus();
        expect(focusZoneFn).toHaveBeenCalled();
        wrapper.unmount();
    });
    it('itemIsSelected style should have higher precedence than itemIsSelectable', function () {
        var props = getDefaultProps();
        var selectableColor = 'rgb(170, 0, 0)';
        var selectedColor = 'rgb(0, 170, 170)';
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props, { styles: {
                itemIsSelectable: {
                    backgroundColor: selectableColor
                },
                itemIsSelected: {
                    backgroundColor: selectedColor
                }
            }, selectedItemKeys: new Set() })));
        var firstNode = wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode();
        expect(window.getComputedStyle(firstNode).backgroundColor).toEqual(selectableColor);
        wrapper.setProps({ selectedItemKeys: new Set([props.items[0].key]) });
        firstNode = wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode();
        expect(window.getComputedStyle(firstNode).backgroundColor).toEqual(selectedColor);
    });
    it('itemIsSelected style should have higher precedence than itemIsNotSelected', function () {
        var props = getDefaultProps();
        var selectableColor = 'rgb(170, 0, 0)';
        var notSelectedColor = 'rgb(0, 170, 170)';
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props, { styles: {
                itemIsSelectable: {
                    backgroundColor: selectableColor
                },
                itemIsNotSelected: {
                    backgroundColor: notSelectedColor
                }
            }, selectedItemKeys: new Set() })));
        var firstNode = wrapper.find(TreeNode_1.TreeNode).at(0).getDOMNode();
        expect(window.getComputedStyle(firstNode).backgroundColor).toEqual(notSelectedColor);
        wrapper.unmount();
    });
    it('Custom ScrollView', function () {
        var customScrollViewSelector = "." + customScrollViewClassName;
        var items = getMockItems([{ key: 'one' }, { key: 'two' }]);
        var props = getDefaultProps({
            items: items,
            scrollView: CustomScrollView
        });
        var wrapper = enzyme_1.mount(React.createElement(Tree_1.Tree, tslib_1.__assign({}, props)));
        expect(wrapper.find(customScrollViewSelector).length).toEqual(1);
        expect(wrapper.find(TreeNode_1.TreeNode).length).toEqual(2);
        wrapper.unmount();
    });
});
var customScrollViewClassName = 'custom-scroll-view';
var CustomScrollView = /** @class */ (function (_super) {
    tslib_1.__extends(CustomScrollView, _super);
    function CustomScrollView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CustomScrollView.prototype.render = function () {
        var children = this.props.children;
        return React.createElement("div", { className: customScrollViewClassName }, children);
    };
    return CustomScrollView;
}(React.Component));
exports.CustomScrollView = CustomScrollView;
//# sourceMappingURL=Tree.test.js.map