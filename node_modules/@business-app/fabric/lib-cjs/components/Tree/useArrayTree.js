"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.useArrayTree = void 0;
var tslib_1 = require("tslib");
var React = require("react");
function useArrayTree(topLevelItems) {
    if (topLevelItems === void 0) { topLevelItems = []; }
    if (topLevelItems.some(function (x) { return x.level !== 0; })) {
        throw new Error('topLevelItems');
    }
    var _a = React.useState(tslib_1.__spreadArrays(topLevelItems)), treeItems = _a[0], setTreeItems = _a[1];
    var getChildrenOf = React.useCallback(function (item) {
        var startIndex;
        var itemLevel;
        if (item !== null) {
            var itemIndex = treeItems.indexOf(item);
            if (itemIndex < 0) {
                throw new Error('item');
            }
            startIndex = itemIndex;
            itemLevel = item.level;
        }
        else {
            startIndex = -1;
            itemLevel = -1;
        }
        var children = [];
        var index = startIndex;
        while (index + 1 < treeItems.length && treeItems[index + 1].level > itemLevel) {
            if (treeItems[index + 1].level === itemLevel + 1) {
                children.push(treeItems[index + 1]);
            }
            index++;
        }
        return children;
    }, [treeItems]);
    var appendChildrenTo = React.useCallback(function (item, children) {
        var itemLevel;
        if (item !== null) {
            itemLevel = item.level;
        }
        else {
            itemLevel = -1;
        }
        if (children.some(function (x) { return x.level !== itemLevel + 1; })) {
            throw new Error('children');
        }
        setTreeItems(function (items) {
            var startIndex;
            if (item !== null) {
                var itemIndex = items.indexOf(item);
                if (itemIndex < 0) {
                    throw new Error('item');
                }
                startIndex = itemIndex;
            }
            else {
                startIndex = -1;
            }
            var index = startIndex;
            while (index + 1 < items.length && items[index + 1].level > itemLevel) {
                index++;
            }
            var indexOfLastDescendantOrSelf = index;
            items = items.slice();
            items.splice.apply(items, tslib_1.__spreadArrays([indexOfLastDescendantOrSelf + 1, 0], children));
            return items;
        });
    }, [setTreeItems]);
    var replace = React.useCallback(function (item, replacementItem) {
        if (item.level !== replacementItem.level) {
            throw new Error('replacementItem');
        }
        if (item.setSize !== replacementItem.setSize) {
            throw new Error('replacementItem');
        }
        setTreeItems(function (items) {
            var itemIndex = items.indexOf(item);
            if (itemIndex < 0) {
                return items;
            }
            items = items.slice();
            items.splice(itemIndex, 1, replacementItem);
            return items;
        });
    }, [setTreeItems]);
    var remove = React.useCallback(function (item) {
        setTreeItems(function (items) {
            var itemIndex = items.indexOf(item);
            if (itemIndex < 0) {
                throw new Error('item');
            }
            var startIndex = itemIndex;
            var endIndex = itemIndex;
            var itemLevel = item.level;
            while (endIndex + 1 < items.length && items[endIndex + 1].level > itemLevel) {
                endIndex++;
            }
            items = items.slice();
            items.splice(startIndex, endIndex - startIndex + 1);
            return items;
        });
    }, [setTreeItems]);
    var clear = React.useCallback(function () {
        setTreeItems([]);
    }, [setTreeItems]);
    var refresh = React.useCallback(function () {
        setTreeItems(function (items) { return items.slice(); });
    }, [setTreeItems]);
    return {
        items: treeItems,
        getChildrenOf: getChildrenOf,
        appendChildrenTo: appendChildrenTo,
        replace: replace,
        remove: remove,
        clear: clear,
        refresh: refresh
    };
}
exports.useArrayTree = useArrayTree;
//# sourceMappingURL=useArrayTree.js.map