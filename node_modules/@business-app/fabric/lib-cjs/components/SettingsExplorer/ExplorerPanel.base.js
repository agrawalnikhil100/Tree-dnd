"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExplorerPanelBase = void 0;
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var Button_1 = require("@fluentui/react/lib/Button");
var FocusZone_1 = require("@fluentui/react/lib/FocusZone");
var React = require("react");
var ExplorerPanel_styles_1 = require("./ExplorerPanel.styles");
var getClassNames = Utilities_1.classNamesFunction();
var ExplorerPanelBase = function (props) {
    var disableCollapsing = props.disableCollapsing, parentRef = props.parentRef, selectedKey = props.selectedKey, handleClick = props.handleClick, pageList = props.pageList, header = props.header, styles = props.styles, theme = props.theme;
    var _a = React.useState(false), isCollapsed = _a[0], setIsCollapsed = _a[1];
    var ref = React.useRef();
    var boundaryWidthRef = React.useRef(0);
    var classNames = getClassNames(styles, { theme: theme, isCollapsed: isCollapsed });
    React.useEffect(function () {
        if (disableCollapsing) {
            return undefined;
        }
        var handleResize = function () {
            if (!ref.current || !parentRef.current) {
                return;
            }
            var parentWidth = parentRef.current.getBoundingClientRect().width;
            var boundaryWidth = boundaryWidthRef.current;
            if (boundaryWidth === 0) {
                // First time through, use panel width to decide whether to collapse
                var width = ref.current.getBoundingClientRect().width;
                if (width < ExplorerPanel_styles_1.minWidth) {
                    setIsCollapsed(true);
                    boundaryWidthRef.current = parentWidth;
                }
            }
            else {
                // After the first collapse, use parent width to decide
                setIsCollapsed(parentWidth <= boundaryWidthRef.current);
            }
        };
        handleResize();
        window.addEventListener('resize', handleResize);
        return function () { return window.removeEventListener('resize', handleResize); };
    }, [disableCollapsing]);
    return (React.createElement(FocusZone_1.FocusZone, { className: classNames.root, direction: 0, allowFocusRoot: true },
        React.createElement("div", { role: "menu", ref: ref },
            !isCollapsed && React.createElement("h3", { className: classNames.header }, header),
            pageList.map(function (item, index) {
                var selected = selectedKey.toString() === item.id;
                return (React.createElement(Button_1.DefaultButton, { styles: classNames.subComponentStyles.buttonStyles({}), title: isCollapsed ? item.name : undefined, onClick: function () { return handleClick(index); }, className: selected ? classNames.selectedButton : classNames.notSelectedButton, key: item.id, text: item.name, disabled: item.disabled, "aria-current": selected ? 'true' : undefined, role: "menuitem" }));
            }))));
};
exports.ExplorerPanelBase = ExplorerPanelBase;
//# sourceMappingURL=ExplorerPanel.base.js.map