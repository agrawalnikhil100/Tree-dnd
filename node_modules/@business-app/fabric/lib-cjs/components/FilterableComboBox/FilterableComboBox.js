"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterableComboBox = exports.filterableComboBox = void 0;
var tslib_1 = require("tslib");
var ComboBox_1 = require("@fluentui/react/lib/ComboBox");
var React = require("react");
var onFilterOptions_1 = require("./onFilterOptions");
function filterableComboBox(ComboBoxComponent) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(FilterableComboBoxBase, _super);
        function FilterableComboBoxBase() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {
                filter: _this.props.text,
                isMenuOpen: false,
                userHasInputFilter: false
            };
            _this.comboBoxRef = React.createRef();
            _this.filterOptions = function (userHasInputFilter, onFilterOptions, filter, options) {
                return userHasInputFilter ? onFilterOptions(filter, options, onFilterOptions) : options;
            };
            _this.onSetFocus = function () {
                if (_this.comboBoxRef.current) {
                    _this.comboBoxRef.current.focus(true, true);
                }
            };
            _this.setFilter = function (filter) { return _this.setState({ filter: filter }); };
            _this.onPendingValueChanged = function (option, index, value) {
                if (value !== undefined) {
                    // if this is not undefined, then the user has typed in a value that doesn't directly match an option
                    // the user can get into a state where they've closed the menu but are still able to type
                    // re-open it please if this is so
                    _this.tryOpenComboBoxMenu();
                    _this.setFilter(value);
                    _this.setState({
                        userHasInputFilter: true
                    });
                }
                else if (option !== undefined) {
                    var _a = _this.props.disableInputPrediction, disableInputPrediction = _a === void 0 ? false : _a;
                    // here is an interesting case
                    // if the user types in an option verbatim
                    // this callback is provided the option, but NOT the value string
                    // however, this is the same as the user mousing over an option in the list,
                    // which we don't want affecting the search query
                    // naive heuristic instead is to see if we were just one character away from the option that was given
                    // then just assume that the user typed it in
                    if (!disableInputPrediction &&
                        _this.state.filter &&
                        option.text.toLowerCase().indexOf(_this.state.filter.toLowerCase()) >= 0 &&
                        _this.state.filter.length + 1 === option.text.length) {
                        _this.setFilter(option.text);
                        _this.setState({
                            userHasInputFilter: true
                        });
                    }
                }
                if (_this.props.onPendingValueChanged) {
                    _this.props.onPendingValueChanged(option, index, value);
                }
            };
            _this.onChange = function (event, option, index, value) {
                if (option) {
                    // yay it worked, give us an option!
                    _this.setFilter(option.text);
                }
                else {
                    _this.revertIfNeeded();
                }
                if (_this.props.onChange) {
                    _this.props.onChange(event, option, index, value, {
                        userHasInputFilter: _this.state.userHasInputFilter
                    });
                }
                _this.onMenuDismissed();
            };
            _this.onAutofillFocus = function (evt) {
                if (_this.props.autofill && _this.props.autofill.onFocus) {
                    _this.props.autofill.onFocus(evt);
                }
            };
            _this.onMenuOpen = function () {
                if (!_this.state.isMenuOpen) {
                    _this.setState({
                        isMenuOpen: true
                    });
                }
                if (_this.props.onMenuOpen) {
                    _this.props.onMenuOpen();
                }
            };
            _this.onMenuDismissed = function () {
                if (_this.state.isMenuOpen) {
                    _this.setState({
                        isMenuOpen: false,
                        userHasInputFilter: false
                    });
                }
                if (_this.props.onMenuDismissed) {
                    _this.props.onMenuDismissed();
                }
            };
            /**
             * If the user has left an invalid filter in the combobox when exiting the control,
             * (and the control consumer has not disabled this behavior), reset the
             * filter value to the last valid selected option.
             */
            _this.revertIfNeeded = function () {
                var _a = _this.props, options = _a.options, _b = _a.revertToLastValidOptionOnInvalidFilter, revertToLastValidOptionOnInvalidFilter = _b === void 0 ? true : _b;
                var filter = _this.state.filter;
                if (!revertToLastValidOptionOnInvalidFilter) {
                    return;
                }
                var optionMatchingFilter = options.filter(function (option) { return option.text.toLowerCase() === filter; })[0];
                if (optionMatchingFilter) {
                    // it's ok!
                    return;
                }
                // it was bad, time to revert
                if (!_this.props.selectedKey) {
                    return _this.setFilter('');
                }
                var lastValidOption = _this.props.options.filter(function (option) { return option.key === _this.props.selectedKey; })[0];
                if (!lastValidOption) {
                    return _this.setFilter('');
                }
                return _this.setFilter(lastValidOption.text);
            };
            _this.onAutofillBlur = function (evt) {
                if (window && window.setTimeout) {
                    // Not fantastic
                    // We are essentially waiting a short amount of time in order for the combobox menu to fully dismiss
                    // before changing the filter, otherwise we see the menu flicker as it animates out
                    window.setTimeout(_this.revertIfNeeded, 100);
                }
                if (_this.props.autofill && _this.props.autofill.onBlur) {
                    _this.props.autofill.onBlur(evt);
                }
            };
            return _this;
        }
        FilterableComboBoxBase.prototype.render = function () {
            var _a = this.props, _b = _a.onFilterOptions, onFilterOptions = _b === void 0 ? onFilterOptions_1.default : _b, options = _a.options, noResultsMessage = _a.noResultsMessage, rawProps = tslib_1.__rest(_a, ["onFilterOptions", "options", "noResultsMessage"]);
            var _c = this.state, filter = _c.filter, userHasInputFilter = _c.userHasInputFilter;
            var filteredOptions = this.filterOptions(userHasInputFilter, onFilterOptions, filter, options);
            var onRenderLowerContent = function () {
                return (filteredOptions === null || filteredOptions === void 0 ? void 0 : filteredOptions.length) <= 0
                    ? typeof noResultsMessage === 'function'
                        ? noResultsMessage(filter)
                        : noResultsMessage
                    : null;
            };
            return (React.createElement(React.Fragment, null,
                React.createElement(ComboBoxComponent, tslib_1.__assign({}, rawProps, { allowFreeform: true, autoComplete: "off", autofill: tslib_1.__assign(tslib_1.__assign({}, rawProps.autofill), { onFocus: this.onAutofillFocus, onBlur: this.onAutofillBlur }), componentRef: this.comboBoxRef, options: filteredOptions, text: this.props.allowFreeform
                        ? this.props.selectedKey
                        : this.props.selectedKey
                            ? filter
                            : undefined, onChange: this.onChange, onMenuDismissed: this.onMenuDismissed, onMenuOpen: this.onMenuOpen, onPendingValueChanged: this.onPendingValueChanged, onRenderLowerContent: onRenderLowerContent, onFocus: this.props.openOnClick ? this.onSetFocus : undefined })),
                React.createElement("div", { "aria-live": "assertive", "aria-atomic": "true", style: { overflow: 'hidden', position: 'absolute', top: -1000, left: -1000, width: 0, height: 0 } }, onRenderLowerContent === null || onRenderLowerContent === void 0 ? void 0 : onRenderLowerContent())));
        };
        FilterableComboBoxBase.prototype.tryOpenComboBoxMenu = function () {
            if (this.comboBoxRef.current && !this.state.isMenuOpen && !this.props.disabled) {
                this.comboBoxRef.current.focus(true);
                this.setState({
                    isMenuOpen: true
                });
            }
        };
        return FilterableComboBoxBase;
    }(React.Component));
}
exports.filterableComboBox = filterableComboBox;
exports.FilterableComboBox = filterableComboBox(ComboBox_1.ComboBox);
//# sourceMappingURL=FilterableComboBox.js.map