"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Enzyme = require("enzyme");
require("jest");
var SelectableOption_1 = require("@fluentui/react/lib/SelectableOption");
var React = require("react");
var FilterableComboBox_1 = require("./FilterableComboBox");
var onFilterOptions_1 = require("./onFilterOptions");
function option(text) {
    return {
        key: text,
        text: text
    };
}
function header(text) {
    return {
        key: text,
        text: text,
        itemType: SelectableOption_1.SelectableOptionMenuItemType.Header
    };
}
function divider(text) {
    if (text === void 0) { text = 'Divider'; }
    return {
        key: 'div_' + ('' + Math.random()).substr(0, 10),
        text: text,
        itemType: SelectableOption_1.SelectableOptionMenuItemType.Divider
    };
}
describe('FilterableComboBox', function () {
    it('should render', function () {
        var options = [option('Red'), option('Blue'), option('Green')];
        var fcb = Enzyme.shallow(React.createElement(FilterableComboBox_1.FilterableComboBox, { options: options }));
        expect(fcb.exists()).toBeTruthy();
    });
    it('should allow default comboBox behavior when allow.', function () {
        var options = [option('Red'), option('Blue'), option('Green')];
        var onChange = jest.fn();
        var wrapper = Enzyme.mount(React.createElement(FilterableComboBox_1.FilterableComboBox, { options: options, onChange: onChange, allowFreeform: true }));
        wrapper.find('.ms-Icon').simulate('click');
        var numberOfOptions = wrapper.find('button[role="option"]').length;
        expect(numberOfOptions).toBe(3);
        expect(wrapper.find('button[title="Red"]').length).toBe(1);
        wrapper.find('button[title="Red"]').simulate('click');
        expect(onChange).toBeCalledTimes(1);
        wrapper.unmount();
    });
    it('should allow free form when the appropriate option is set to true', function () {
        var options = [option('Red'), option('Blue'), option('Green')];
        var wrapper = Enzyme.mount(React.createElement(FilterableComboBox_1.FilterableComboBox, { options: options, allowFreeform: true, selectedKey: '' }));
        var allowFreeform = wrapper.prop('allowFreeform');
        expect(allowFreeform).toBe(true);
        expect(wrapper.find('input').get(0).props.value).toBe('');
        wrapper.setProps({ selectedKey: 'Text' });
        wrapper.update();
        expect(wrapper.find('input').get(0).props.value).toBe('Text');
        wrapper.unmount();
    });
    describe('filterOptions', function () {
        it('should return the list of options given if not provided a filter', function () {
            var options = [];
            expect(onFilterOptions_1.default(undefined, options)).toBe(options);
        });
        it("should only include options where the filter is a case-insensitive substring of the option's text value", function () {
            var options = [
                option('Foo Bar'),
                option('Bar Foo'),
                option('Baz Boo'),
                option('Qux Cadr'),
                option('RebAR')
            ];
            expect(onFilterOptions_1.default('bar', options).map(function (op) { return op.text; })).toEqual(['Foo Bar', 'Bar Foo', 'RebAR']);
        });
        it("should include all options underneath a matching header even if the options themselves don't match", function () {
            var options = [
                header('Blues'),
                option('Dark Blue'),
                option('Azure'),
                option('Cerulean')
            ];
            expect(onFilterOptions_1.default('blue', options).map(function (op) { return op.text; })).toEqual([
                'Blues',
                'Dark Blue',
                'Azure',
                'Cerulean'
            ]);
        });
        it('should include the header of a group with at least one match even if the header does not match', function () {
            var options = [
                header('Blues'),
                option('Dark Blue'),
                option('Azure'),
                option('Cerulean')
            ];
            expect(onFilterOptions_1.default('ceru', options).map(function (op) { return op.text; })).toEqual(['Blues', 'Cerulean']);
        });
        it('should strip any trailing divider if actually filtering', function () {
            var options = [
                header('Blues'),
                option('Dark Blue'),
                option('Azure'),
                option('Cerulean'),
                divider()
            ];
            expect(onFilterOptions_1.default('blue', options).filter(function (op) { return op.itemType === SelectableOption_1.SelectableOptionMenuItemType.Divider; })
                .length).toBe(0);
        });
    });
});
//# sourceMappingURL=FilterableComboBox.test.js.map