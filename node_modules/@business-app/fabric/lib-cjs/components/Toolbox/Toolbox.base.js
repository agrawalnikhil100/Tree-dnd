"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolboxBase = void 0;
var tslib_1 = require("tslib");
var Button_1 = require("@fluentui/react/lib/Button");
var FocusZone_1 = require("@fluentui/react/lib/FocusZone");
var Icon_1 = require("@fluentui/react/lib/Icon");
var Styling_1 = require("@fluentui/react/lib/Styling");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var React = require("react");
var Toolbox_selectors_1 = require("./Toolbox.selectors");
var ToolboxItem_1 = require("./ToolboxItem");
var Resizer_1 = require("./../Resizer");
var getClassNames = Utilities_1.classNamesFunction();
var DefaultWidth = 280;
/**
 * Determines if the provided item is a ToolboxItem
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isToolBoxItem(item) {
    return !!item && typeof item === 'object' && item.type === ToolboxItemType;
}
var ToolboxItemType = React.createElement(ToolboxItem_1.ToolboxItem).type;
var ToolboxBase = /** @class */ (function (_super) {
    tslib_1.__extends(ToolboxBase, _super);
    function ToolboxBase(props) {
        var _this = _super.call(this, props) || this;
        _this._focusZone = React.createRef();
        _this._classNames = {};
        /**
         * Renders the set of links to route between drawers
         */
        _this._renderToolboxLinks = function () {
            var _a;
            var items = _this.state.links.map(_this._renderToolboxLink);
            var linksAreExpanded = _this.state.linksAreExpanded;
            var strings = _this.props.strings;
            var collapseButtonTitle = (_a = strings.expandCollapseTooltip) !== null && _a !== void 0 ? _a : (linksAreExpanded ? strings.collapseTooltip : strings.expandTooltip);
            var ToolboxLinksContainer = _this._toolboxLinksContainer();
            return (React.createElement(ToolboxLinksContainer, { componentRef: _this._focusZone, direction: FocusZone_1.FocusZoneDirection.vertical, className: _this._classNames.focusZone },
                React.createElement("ul", { className: _this._classNames.list, role: "tablist" },
                    React.createElement(Button_1.CommandButton, { className: Styling_1.mergeStyles(Toolbox_selectors_1.ToolboxAutomationSelectors.expandCollapseLinksClassName, _this._classNames.item), onClick: _this._onCollapseButtonClick, onKeyPress: _this._onCollapseButtonKeyPress, "aria-expanded": linksAreExpanded, name: collapseButtonTitle, title: collapseButtonTitle, ariaLabel: collapseButtonTitle }, _this._renderLinkContent({ itemIcon: 'GlobalNavButton', itemKey: 'collapseButton' })),
                    items)));
        };
        _this._toolboxLinksContainer = function () {
            var Container = FocusZone_1.FocusZone;
            if (_this.props.toolboxLinksContainerAs) {
                Container = _this.props.toolboxLinksContainerAs;
            }
            return Container;
        };
        _this._renderToolboxLink = function (link) {
            var itemKey = link.itemKey, headerButtonProps = link.headerButtonProps;
            var tabId = _this.state.keyToTabIds[itemKey];
            var onRenderItemLink = link.onRenderItemLink;
            var linkContent;
            var isSelected = _this.state.selectedKey === itemKey && _this.state.drawerIsExpanded && !link.disabled;
            if (onRenderItemLink) {
                linkContent = onRenderItemLink(link, _this._renderLinkContent);
            }
            else {
                linkContent = _this._renderLinkContent(link);
            }
            var linkStyles = Styling_1.mergeStyles(Toolbox_selectors_1.ToolboxAutomationSelectors.toolTabClassName, isSelected ? _this._classNames.itemIsSelected : _this._classNames.item, link.className);
            return (React.createElement(Button_1.CommandButton, tslib_1.__assign({}, headerButtonProps, { componentRef: _this.state.keyToRef[itemKey] || undefined, id: tabId, key: itemKey, className: linkStyles, onClick: !link.disabled && _this._onLinkClick.bind(_this, itemKey), onKeyPress: !link.disabled && _this._onKeyPress.bind(_this, itemKey), ariaLabel: link.ariaLabel, role: "tab", "aria-selected": _this.state.selectedKey === itemKey, name: link.headerText, title: link.headerText, keytipProps: link.keytipProps, disabled: link.disabled }),
                isSelected && _this._renderSelectionIndicator(),
                linkContent));
        };
        _this._renderLinkContent = function (link) {
            if (!link) {
                return React.createElement(React.Fragment, null);
            }
            var itemIcon = link.itemIcon, headerText = link.headerText;
            var linksAreExpanded = _this.state.linksAreExpanded;
            return (React.createElement("span", { className: _this._classNames.itemContent, "aria-hidden": true },
                itemIcon !== undefined && (React.createElement("span", { className: _this._classNames.iconContainer },
                    React.createElement(Icon_1.Icon, { iconName: itemIcon, className: _this._classNames.icon }))),
                headerText !== undefined && !!linksAreExpanded && (React.createElement("span", { className: _this._classNames.text },
                    " ",
                    headerText))));
        };
        _this._renderSelectionIndicator = function () {
            return React.createElement("div", { role: "presentation", className: _this._classNames.selectionIndicator });
        };
        _this._onCollapseButtonClick = function (ev) {
            ev.preventDefault();
            _this._toggleCollapsed();
        };
        _this._onCollapseButtonKeyPress = function (ev) {
            if (ev.which === Utilities_1.KeyCodes.enter) {
                ev.preventDefault();
                _this._toggleCollapsed();
            }
        };
        _this._onToggleExpandLinks = function (expand) {
            var _a, _b;
            (_b = (_a = _this.props).onToggleExpandLinks) === null || _b === void 0 ? void 0 : _b.call(_a, expand);
        };
        /**
         * Renders the current Toolbox Item
         */
        _this._renderToolboxDrawer = function () {
            var _a = _this.state, selectedKey = _a.selectedKey, links = _a.links;
            var index = _this.state.keyToIndexMapping[selectedKey];
            var selectedLink = links[index];
            if (selectedLink && selectedLink.disabled) {
                return React.createElement(React.Fragment, null);
            }
            var selectedTabId = _this.state.keyToTabIds[selectedKey];
            var selectedChild = React.Children.toArray(_this.props.children)[index];
            var closeTitle = _this.props.strings.closeTooltip;
            return (React.createElement("div", { role: "tabpanel", "aria-labelledby": selectedTabId, className: _this._classNames.drawer, style: { width: _this.state.width } },
                React.createElement(React.Fragment, null,
                    React.createElement("div", { className: _this._classNames.drawerHeaderRegion },
                        React.createElement("h2", { className: _this._classNames.drawerHeader }, selectedLink ? selectedLink.headerText : null),
                        React.createElement(Button_1.CommandButton, { className: Styling_1.mergeStyles(Toolbox_selectors_1.ToolboxAutomationSelectors.closeDrawerClassName, _this._classNames.drawerClose), onClick: _this._dismissDrawer, title: closeTitle },
                            React.createElement(Icon_1.Icon, { className: _this._classNames.drawerCloseIcon, iconName: "Cancel" }))),
                    selectedChild),
                _this.props.isResizable && (React.createElement(Resizer_1.Resizer, { size: _this.state.width, onSizeChanged: function (newSize) { return _this.setState({ width: newSize }); }, location: Resizer_1.ResizerLocation.Right }))));
        };
        _this._dismissDrawer = function () {
            _this._focusCurrentLink();
            _this._clearSelectedItem(true);
        };
        /** Focus the tab button for the currently selected link. */
        _this._focusCurrentLink = function () {
            var _a;
            var selectedKey = _this.state.selectedKey;
            if (selectedKey !== null && selectedKey !== undefined) {
                var currentTabRef = _this.state.keyToRef[selectedKey];
                (_a = currentTabRef === null || currentTabRef === void 0 ? void 0 : currentTabRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }
        };
        _this._clearSelectedItem = function (clearedViaDismissButton) {
            if (clearedViaDismissButton === void 0) { clearedViaDismissButton = false; }
            // Only manage selected key state when the component is being used as an uncontrolled component
            if (_this.props.selectedKey === undefined) {
                _this.setState({
                    selectedKey: null,
                    drawerIsExpanded: false
                });
            }
            var onSelectedItemChanged = _this.props.onSelectedItemChanged;
            onSelectedItemChanged === null || onSelectedItemChanged === void 0 ? void 0 : onSelectedItemChanged(null, clearedViaDismissButton);
        };
        var initialKeyPropProvided = props.initialSelectedKey !== undefined;
        _this.state = ToolboxBase_1._getStateFromProps(props, {
            links: [],
            selectedKey: initialKeyPropProvided ? props.initialSelectedKey : null,
            linksAreExpanded: !!props.expandLinksInitially,
            drawerIsExpanded: initialKeyPropProvided,
            keyToIndexMapping: {},
            keyToTabIds: {},
            keyToRef: {},
            pivotId: Utilities_1.getId('Toolbox'),
            width: DefaultWidth
        });
        return _this;
    }
    ToolboxBase_1 = ToolboxBase;
    ToolboxBase._getStateFromProps = function (nextProps, prevState) {
        var newState = prevState;
        newState.links = ToolboxBase_1._getToolboxLinks(nextProps, newState);
        if (nextProps.selectedKey !== undefined &&
            nextProps.selectedKey !== null &&
            ToolboxBase_1._isKeyValid(nextProps.selectedKey, newState)) {
            // Use the selectedKey prop if it is provided/valid.
            newState.selectedKey = nextProps.selectedKey;
            newState.drawerIsExpanded = true;
        }
        else if (nextProps.selectedKey === null || !ToolboxBase_1._isKeyValid(newState.selectedKey, newState)) {
            // Close the drawer if requested or if the previous state is no longer valid.
            newState.selectedKey = null;
            newState.drawerIsExpanded = false;
        }
        if (nextProps.expandLinks !== undefined && nextProps.expandLinks !== null) {
            newState.linksAreExpanded = nextProps.expandLinks;
        }
        return newState;
    };
    /**
     * Gets the set of ToolboxLinks as array of ToolboxItemProps
     * The set of Links is determined by child components of type ToolboxItem
     */
    ToolboxBase._getToolboxLinks = function (props, state) {
        var _this = this;
        var links = [];
        // Reset the mappings
        state.keyToIndexMapping = {};
        state.keyToTabIds = {};
        state.keyToRef = {};
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        React.Children.map(props.children, function (child) {
            if (isToolBoxItem(child)) {
                var newItemIndex = links.length;
                var pivotItem = child;
                var itemKey = pivotItem.props.itemKey || newItemIndex.toString();
                links.push({
                    className: pivotItem.props.className,
                    headerText: pivotItem.props.headerText,
                    headerButtonProps: pivotItem.props.headerButtonProps,
                    ariaLabel: pivotItem.props.ariaLabel,
                    itemKey: itemKey,
                    itemIcon: pivotItem.props.itemIcon,
                    onRenderItemLink: pivotItem.props.onRenderItemLink,
                    keytipProps: pivotItem.props.keytipProps,
                    disabled: pivotItem.props.disabled
                });
                state.keyToIndexMapping[itemKey] = newItemIndex;
                state.keyToTabIds[itemKey] = _this._getTabId(newItemIndex, state);
                state.keyToRef[itemKey] = React.createRef();
            }
        });
        return links;
    };
    /**
     * Generates the Id for the tab button.
     */
    ToolboxBase._getTabId = function (index, state) {
        return state.pivotId + ("-Tab" + index);
    };
    /**
     * whether the key exists in the pivot items.
     */
    ToolboxBase._isKeyValid = function (itemKey, state) {
        return itemKey !== undefined && state.keyToIndexMapping[itemKey] !== undefined;
    };
    ToolboxBase.getDerivedStateFromProps = function (nextProps, prevState) {
        if (!prevState) {
            return null;
        }
        return ToolboxBase_1._getStateFromProps(nextProps, prevState);
    };
    ToolboxBase.prototype.render = function () {
        var divProps = Utilities_1.getNativeProps(this.props, Utilities_1.divProperties);
        this._classNames = this._getClassNames(this.props);
        return (React.createElement("div", tslib_1.__assign({ className: this._classNames.root }, divProps),
            this._renderToolboxLinks(),
            this._renderToolboxDrawer()));
    };
    /**
     * Sets focus to the first pivot tab.
     */
    ToolboxBase.prototype.focus = function () {
        var _a;
        (_a = this._focusZone.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    ToolboxBase.prototype._toggleCollapsed = function () {
        var _this = this;
        // Only manage link expansion state when the component is being used as an uncontrolled component
        if (this.props.expandLinks === undefined) {
            this.setState(function (state) {
                var expandLinks = !state.linksAreExpanded;
                // When we are managing the expansion state, we need to call this callback
                // from within setState to ensure it has the correct state value when called.
                _this._onToggleExpandLinks(expandLinks);
                return { linksAreExpanded: expandLinks };
            });
        }
        else {
            this._onToggleExpandLinks(!this.state.linksAreExpanded);
        }
    };
    /**
     * Handles the onClick event on ToolboxLinks
     */
    ToolboxBase.prototype._onLinkClick = function (itemKey, ev) {
        ev.preventDefault();
        this._updateSelectedItem(itemKey);
    };
    /**
     * Handle the onKeyPress event on the ToolboxLinks
     */
    ToolboxBase.prototype._onKeyPress = function (itemKey, ev) {
        if (ev.which === Utilities_1.KeyCodes.enter) {
            ev.preventDefault();
            this._updateSelectedItem(itemKey);
        }
    };
    /**
     * Updates the state with the new selected index
     */
    ToolboxBase.prototype._updateSelectedItem = function (itemKey) {
        var _a, _b;
        var _c = this.state, selectedKey = _c.selectedKey, drawerIsExpanded = _c.drawerIsExpanded;
        if (selectedKey === itemKey && drawerIsExpanded) {
            this._clearSelectedItem();
        }
        else {
            // Only manage selected key state when the component is being used as an uncontrolled component
            if (this.props.selectedKey === undefined) {
                this.setState({
                    selectedKey: itemKey,
                    drawerIsExpanded: true
                });
            }
            if (ToolboxBase_1._isKeyValid(itemKey, this.state)) {
                (_b = (_a = this.props).onSelectedItemChanged) === null || _b === void 0 ? void 0 : _b.call(_a, itemKey, false);
            }
        }
    };
    ToolboxBase.prototype._getClassNames = function (props) {
        var theme = props.theme;
        var _a = this.state, linksAreExpanded = _a.linksAreExpanded, drawerIsExpanded = _a.drawerIsExpanded;
        return getClassNames(props.styles, {
            theme: theme,
            linksAreExpanded: linksAreExpanded,
            drawerIsExpanded: drawerIsExpanded
        });
    };
    var ToolboxBase_1;
    ToolboxBase = ToolboxBase_1 = tslib_1.__decorate([
        Utilities_1.customizable('Toolbox', ['theme', 'styles'])
    ], ToolboxBase);
    return ToolboxBase;
}(Utilities_1.BaseComponent));
exports.ToolboxBase = ToolboxBase;
//# sourceMappingURL=Toolbox.base.js.map