"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var enzyme_1 = require("enzyme");
var Button_1 = require("@fluentui/react/lib/Button");
var FocusZone_1 = require("@fluentui/react/lib/FocusZone");
var Styling_1 = require("@fluentui/react/lib/Styling");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var React = require("react");
var Toolbox_1 = require("./Toolbox");
var Toolbox_base_1 = require("./Toolbox.base");
var Toolbox_selectors_1 = require("./Toolbox.selectors");
var ToolboxItem_1 = require("./ToolboxItem");
var Resizer_1 = require("./../Resizer");
// Suppress icon warnings. https://github.com/OfficeDev/office-ui-fabric-react/wiki/Using-icons
Styling_1.setIconOptions({ disableWarnings: true });
var strings = {
    closeTooltip: 'close',
    expandCollapseTooltip: 'show or hide menu items'
};
function getState(wrapper) {
    return wrapper.childAt(0).instance().state;
}
describe('Toolbox', function () {
    it('onSelectedItemChanged called with null on clicking the close icon', function () {
        var onSelectedItemChanged = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { onSelectedItemChanged: onSelectedItemChanged, selectedKey: "key", strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        // find the close button
        var closeButton = wrapper
            .find(Button_1.CommandButton)
            .filterWhere(function (x) { return x.props().title === strings.closeTooltip; });
        expect(closeButton.props().onClick).toBeDefined();
        closeButton.props().onClick({});
        expect(onSelectedItemChanged).toBeCalledWith(null, true);
        wrapper.unmount();
    });
    it('onSelectedItemChanged called with correct parameters on clicking Toolbox Item (controlled)', function () {
        var myKey = 'mykey';
        var disabledTabKey = 'disabledTabKey';
        var testHeader = 'testHeader';
        var disabledTabHeader = 'disabledHeader';
        var onSelectedItemChanged = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { onSelectedItemChanged: onSelectedItemChanged, selectedKey: null, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "anotherKey" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: testHeader, itemIcon: "Product", itemKey: myKey }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: disabledTabHeader, itemIcon: "Edit", itemKey: disabledTabKey, disabled: true })));
        // find the command button inside the toolbox item
        var commandButtons = wrapper.find(Button_1.CommandButton);
        var linkButton = commandButtons.filterWhere(function (x) { return x.props().name === testHeader; });
        expect(linkButton.props().onClick).toBeDefined();
        var preventDefaultFunction = jest.fn();
        // Click on the toolbox item will call onSelectedItemChange with correct value
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(myKey, false);
        // Clicking again should result in the same outcome, since the component is controlled and we didn't update the props.
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(myKey, false);
        // Clicking on a disabled tool should not change the selection
        var disabledButton = commandButtons.filterWhere(function (x) { return x.props().name === disabledTabHeader; });
        if (disabledButton.props().onClick) {
            disabledButton.props().onClick({ preventDefault: preventDefaultFunction });
        }
        expect(onSelectedItemChanged).not.toBeCalledWith(disabledTabKey, false);
        wrapper.unmount();
    });
    it('onSelectedItemChanged called with correct parameters on clicking Toolbox Item (uncontrolled)', function () {
        var myKey = 'mykey';
        var anotherKey = 'anotherKey';
        var testHeader = 'testHeader';
        var disabledTabKey = 'disabledTabKey';
        var disabledTabHeader = 'disabledHeader';
        var onSelectedItemChanged = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { onSelectedItemChanged: onSelectedItemChanged, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: anotherKey }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: testHeader, itemIcon: "Product", itemKey: myKey }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: disabledTabHeader, itemIcon: "Edit", itemKey: disabledTabKey, disabled: true })));
        // find the command button inside the toolbox item
        var commandButtons = wrapper.find(Button_1.CommandButton);
        var linkButton = commandButtons.filterWhere(function (x) { return x.props().name === testHeader; });
        expect(linkButton.props().onClick).toBeDefined();
        var preventDefaultFunction = jest.fn();
        // Click on the toolbox item will call onSelectedItemChange with correct value
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(myKey, false);
        // Clicking on the toolbox item again will unselect current item (call onSelectedItem change with empty string)
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(null, false);
        // Open the tool yet again
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(myKey, false);
        // Switch tools while a tool is open
        var otherLinkButton = commandButtons.filterWhere(function (x) { return x.props().name === 'item0header'; });
        otherLinkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(anotherKey, false);
        // Clicking on a disabled tool should not change the selection
        var disabledButton = commandButtons.filterWhere(function (x) { return x.props().name === disabledTabHeader; });
        if (disabledButton.props().onClick) {
            disabledButton.props().onClick({ preventDefault: preventDefaultFunction });
        }
        expect(onSelectedItemChanged).not.toBeCalledWith(disabledTabKey, false);
        wrapper.unmount();
    });
    it('onToggleExpandLinks called with correct parameters (controlled)', function () {
        var onToggleExpandLinks = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { onToggleExpandLinks: onToggleExpandLinks, expandLinks: false, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "anotherKey" })));
        // find the command button inside the toolbox item
        var linkButton = wrapper.find(Button_1.CommandButton).first();
        expect(linkButton.props().onClick).toBeDefined();
        var preventDefaultFunction = jest.fn();
        // Expand links
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onToggleExpandLinks).toBeCalledWith(true);
        // Clicking again should result in the same outcome, since the component is controlled and we didn't update the props.
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onToggleExpandLinks).toBeCalledWith(true);
        wrapper.unmount();
    });
    it('onToggleExpandLinks called with correct parameters (uncontrolled)', function () {
        var onToggleExpandLinks = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { onToggleExpandLinks: onToggleExpandLinks, expandLinksInitially: false, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "anotherKey" })));
        // find the command button inside the toolbox item
        var linkButton = wrapper.find(Button_1.CommandButton).first();
        expect(linkButton.props().onClick).toBeDefined();
        var preventDefaultFunction = jest.fn();
        // Expand links
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onToggleExpandLinks).toBeCalledWith(true);
        // Clicking again should collapse links
        linkButton.props().onClick({ preventDefault: preventDefaultFunction });
        expect(preventDefaultFunction).toBeCalled();
        expect(onToggleExpandLinks).toBeCalledWith(false);
        wrapper.unmount();
    });
    it('toolbox link corresponds to keypress', function () {
        var myKey = 'mykey';
        var disabledTabKey = 'disabledTabKey';
        var disabledTabHeader = 'disabledHeader';
        var onSelectedItemChanged = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { onSelectedItemChanged: onSelectedItemChanged, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "anotherKey" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'testHeader', itemIcon: "Product", itemKey: myKey }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: disabledTabHeader, itemIcon: "Edit", itemKey: disabledTabKey, disabled: true })));
        // find the command button inside the toolbox item
        var commandButtons = wrapper.find(Button_1.CommandButton);
        var linkButton = commandButtons.filterWhere(function (x) { return x.props().name === 'testHeader'; });
        expect(linkButton.props().onKeyPress).toBeDefined();
        var preventDefaultFunction = jest.fn();
        // keypress on the toolbox with enter key will call onSelectedItemChange with correct value
        linkButton.props().onKeyPress({
            preventDefault: preventDefaultFunction,
            which: Utilities_1.KeyCodes.enter
        });
        expect(preventDefaultFunction).toBeCalled();
        expect(onSelectedItemChanged).toBeCalledWith(myKey, false);
        // keypress with a different key than enter
        var preventDefaultFunction2 = jest.fn();
        linkButton.props().onKeyPress({ preventDefault: preventDefaultFunction2, which: Utilities_1.KeyCodes.a });
        expect(preventDefaultFunction2).not.toBeCalled();
        // Keypress enter on a disabled tool should not change the selection
        var disabledButton = commandButtons.filterWhere(function (x) { return x.props().name === disabledTabHeader; });
        if (disabledButton.props().onKeyPress) {
            disabledButton.props().onKeyPress({
                preventDefault: preventDefaultFunction,
                which: Utilities_1.KeyCodes.enter
            });
        }
        expect(onSelectedItemChanged).not.toBeCalledWith(disabledTabKey, false);
        wrapper.unmount();
    });
    describe('expand/collapse button', function () {
        describe('using expandCollapseTooltip', function () {
            var wrapper;
            beforeEach(function () {
                wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: {
                        expandCollapseTooltip: 'expand/collapse',
                        expandTooltip: 'expand',
                        collapseTooltip: 'collapse',
                        closeTooltip: 'close'
                    } },
                    React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "key0" })));
            });
            afterAll(function () { return wrapper.unmount(); });
            it('should start collapsed', function () {
                var expandCollapseButton = wrapper.find(Button_1.CommandButton).first();
                expect(expandCollapseButton.props().title).toBe('expand/collapse');
                expect(expandCollapseButton.props().ariaLabel).toBe('expand/collapse');
                expect(getState(wrapper).linksAreExpanded).toBe(false);
            });
            it('should switch to expanded when button is clicked', function () {
                wrapper.find(Button_1.CommandButton).first().props().onClick({
                    preventDefault: jest.fn()
                });
                wrapper.update();
                var expandCollapseButton = wrapper.find(Button_1.CommandButton).first();
                expect(expandCollapseButton.props().title).toBe('expand/collapse');
                expect(expandCollapseButton.props().ariaLabel).toBe('expand/collapse');
                expect(getState(wrapper).linksAreExpanded).toBe(true);
            });
        });
        describe('deprecated - using expandTooltip and collapseTooltip', function () {
            var wrapper;
            beforeEach(function () {
                wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: { expandTooltip: 'expand', collapseTooltip: 'collapse', closeTooltip: 'close' } },
                    React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "key0" })));
            });
            afterAll(function () { return wrapper.unmount(); });
            it('should start with expandTooltip', function () {
                var expandButton = wrapper.find(Button_1.CommandButton).first();
                expect(expandButton.props().title).toBe('expand');
                expect(getState(wrapper).linksAreExpanded).toBe(false);
            });
            it('should switch to collapseTooltip when clicked', function () {
                var expandButton = wrapper.find(Button_1.CommandButton).first();
                expandButton.props().onClick({ preventDefault: jest.fn() });
                wrapper.update();
                expect(wrapper.find(Button_1.CommandButton).first().props().ariaLabel).toBe('collapse');
                expect(getState(wrapper).linksAreExpanded).toBe(true);
            });
        });
    });
    it('onRenderItem link', function () {
        var onRenderLink = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_1.Toolbox, { strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "key0", onRenderItemLink: onRenderLink })));
        expect(onRenderLink).toBeCalled();
        wrapper.unmount();
    });
    it('focus', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'item0header', itemIcon: "Cake", itemKey: "key0" })));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var instance = wrapper.childAt(0).instance();
        expect(instance.focus).toBeDefined();
        var focusZoneFn = jest.fn();
        instance._focusZone.current.focus = focusZoneFn;
        instance.focus();
        expect(focusZoneFn).toHaveBeenCalled();
        wrapper.unmount();
    });
    it('initialSelectedKey', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { initialSelectedKey: "key2", strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header1', itemIcon: "Product", itemKey: "key1" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header2', itemIcon: "Product", itemKey: "key2" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header3', itemIcon: "Product", itemKey: "key3" })));
        expect(getState(wrapper).selectedKey).toEqual('key2');
        wrapper.unmount();
    });
    it('selectedKey has priority over initialSelectedKey', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { initialSelectedKey: "key2", selectedKey: 'key3', strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header1', itemIcon: "Product", itemKey: "key1" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header2', itemIcon: "Product", itemKey: "key2" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header3', itemIcon: "Product", itemKey: "key3" })));
        expect(getState(wrapper).selectedKey).toEqual('key3');
        wrapper.unmount();
    });
    it('uses resizable correctly when true', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: strings, isResizable: true },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        var resizer = wrapper.find(Resizer_1.Resizer);
        expect(resizer.length).toEqual(1);
        wrapper.unmount();
    });
    it('uses resizable correctly when false', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: strings, isResizable: false },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        var resizer = wrapper.find(Resizer_1.Resizer);
        // shouldn't render the resizer
        expect(resizer.length).toEqual(0);
        wrapper.unmount();
    });
    it('Links should be collapsed by default', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        expect(getState(wrapper).linksAreExpanded).toEqual(false);
        wrapper.unmount();
    });
    it('expandLinksInitially', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { expandLinksInitially: true, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        expect(getState(wrapper).linksAreExpanded).toEqual(true);
        wrapper.unmount();
    });
    it('expandLinks has priority over expandLinksInitially', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { expandLinksInitially: true, expandLinks: false, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        expect(getState(wrapper).linksAreExpanded).toEqual(false);
        wrapper.unmount();
    });
    it('selectedKey', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { selectedKey: null, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header1', itemIcon: "Product", itemKey: "key1" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header2', itemIcon: "Product", itemKey: "key2" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header3', itemIcon: "Product", itemKey: "key3" })));
        expect(getState(wrapper).selectedKey).toEqual(null);
        expect(getState(wrapper).drawerIsExpanded).toEqual(false);
        wrapper.setProps({ selectedKey: 'key1' });
        expect(getState(wrapper).selectedKey).toEqual('key1');
        expect(getState(wrapper).drawerIsExpanded).toEqual(true);
        wrapper.setProps({ selectedKey: 'key3' });
        expect(getState(wrapper).selectedKey).toEqual('key3');
        expect(getState(wrapper).drawerIsExpanded).toEqual(true);
        wrapper.setProps({ selectedKey: null });
        expect(getState(wrapper).selectedKey).toEqual(null);
        expect(getState(wrapper).drawerIsExpanded).toEqual(false);
        wrapper.unmount();
    });
    it('expandLinks', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { expandLinks: false, strings: strings },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header1', itemIcon: "Product", itemKey: "key1" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header2', itemIcon: "Product", itemKey: "key2" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header3', itemIcon: "Product", itemKey: "key3" })));
        expect(getState(wrapper).linksAreExpanded).toEqual(false);
        wrapper.setProps({ expandLinks: true });
        expect(getState(wrapper).linksAreExpanded).toEqual(true);
        wrapper.setProps({ expandLinks: false });
        expect(getState(wrapper).linksAreExpanded).toEqual(false);
        wrapper.unmount();
    });
    it.skip('Focus should return to tool link after closing drawer via "X" button', function () {
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { expandLinks: false, strings: strings, selectedKey: "key2" },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header1', itemIcon: "Product", itemKey: "key1" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header2', itemIcon: "Product", itemKey: "key2" }),
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header3', itemIcon: "Product", itemKey: "key3" })));
        // find the close button inside the toolbox item
        var closeButton = wrapper
            .find(Button_1.CommandButton)
            .filterWhere(function (x) { return x.props().title === strings.closeTooltip; });
        expect(closeButton).toHaveLength(1);
        closeButton.simulate('click');
        // Focus should move to the tab of the collapsed tool
        expect(document.activeElement.getAttribute('name').indexOf('header2')).toBeGreaterThanOrEqual(0);
        wrapper.setProps({ selectedKey: 'key3' });
        closeButton = wrapper
            .find(Button_1.CommandButton)
            .filterWhere(function (x) { return x.props().title === strings.closeTooltip; });
        expect(closeButton).toHaveLength(1);
        closeButton.simulate('click');
        // Focus should move to the tab of the collapsed tool
        expect(document.activeElement.getAttribute('name').indexOf('header3')).toBeGreaterThanOrEqual(0);
        wrapper.unmount();
    });
    it('Conditional toolbox items should render work', function () {
        var toolTabSelector = "button." + Toolbox_selectors_1.ToolboxAutomationSelectors.toolTabClassName;
        var wrapper = enzyme_1.mount(React.createElement(ConditionalItemToolbox, { selectedKey: 'key1', showSecondItem: false, showThirdItem: false, disableThirdItem: false }));
        expect(wrapper.find(toolTabSelector).length).toEqual(1);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(1);
        // Show the second tab, but do not select it.
        wrapper.setProps({ showSecondItem: true });
        expect(wrapper.find(toolTabSelector).length).toEqual(2);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(1);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
        // Select the second tab
        wrapper.setProps({ selectedKey: 'key2' });
        expect(wrapper.find(toolTabSelector).length).toEqual(2);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(1);
        // Show the third tab, as well, but do not select it
        wrapper.setProps({ showThirdItem: true });
        expect(wrapper.find(toolTabSelector).length).toEqual(3);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(1);
        expect(wrapper.find('.toolbox-item-3').length).toEqual(0);
        // Select the third tab
        wrapper.setProps({ selectedKey: 'key3' });
        expect(wrapper.find(toolTabSelector).length).toEqual(3);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-3').length).toEqual(1);
        // Hide the second tab again
        wrapper.setProps({ showSecondItem: false });
        expect(wrapper.find(toolTabSelector).length).toEqual(2);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-3').length).toEqual(1);
        // Disable the third tab
        wrapper.setProps({ showSecondItem: true, disableThirdItem: true });
        expect(wrapper.find(toolTabSelector).length).toEqual(3);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-3').length).toEqual(0);
        expect(wrapper.find(toolTabSelector + "[disabled]").length).toEqual(1);
        // Enable the third tab again
        wrapper.setProps({ disableThirdItem: false });
        expect(wrapper.find(toolTabSelector).length).toEqual(3);
        expect(wrapper.find('.toolbox-item-1').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-2').length).toEqual(0);
        expect(wrapper.find('.toolbox-item-3').length).toEqual(1);
        expect(wrapper.find(toolTabSelector + "[disabled]").length).toEqual(0);
        wrapper.unmount();
    });
    it('renders the custom toolbox links container if provided', function () {
        var containerId = 'customContainer';
        var Container = function (props) {
            return React.createElement(FocusZone_1.FocusZone, tslib_1.__assign({}, props, { id: containerId }));
        };
        var wrapper = enzyme_1.mount(React.createElement(Toolbox_base_1.ToolboxBase, { strings: strings, isResizable: true, toolboxLinksContainerAs: Container },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header', itemIcon: "Product", itemKey: "key" })));
        var foundContainer = wrapper.find("#" + containerId).hostNodes();
        expect(foundContainer.length).toEqual(1);
        wrapper.unmount();
    });
});
var ConditionalItemToolbox = /** @class */ (function (_super) {
    tslib_1.__extends(ConditionalItemToolbox, _super);
    function ConditionalItemToolbox() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ConditionalItemToolbox.prototype.render = function () {
        var _a = this.props, selectedKey = _a.selectedKey, showSecondItem = _a.showSecondItem, showThirdItem = _a.showThirdItem, disableThirdItem = _a.disableThirdItem;
        return (React.createElement(Toolbox_1.Toolbox, { expandLinks: false, strings: strings, selectedKey: selectedKey },
            React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header1', itemIcon: "Product", itemKey: "key1" },
                React.createElement("div", { className: 'toolbox-item-1' }, 'Item 1')),
            showSecondItem && (React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header2', itemIcon: "Product", itemKey: "key2" },
                React.createElement("div", { className: 'toolbox-item-2' }, 'Item 2'))),
            showThirdItem && (React.createElement(ToolboxItem_1.ToolboxItem, { headerText: 'header3', itemIcon: "Product", itemKey: "key3", disabled: disableThirdItem },
                React.createElement("div", { className: 'toolbox-item-3' }, 'Item 3')))));
    };
    return ConditionalItemToolbox;
}(React.Component));
//# sourceMappingURL=Toolbox.test.js.map