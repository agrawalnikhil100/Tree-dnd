"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighlightedTextBase = void 0;
var tslib_1 = require("tslib");
var style_utilities_1 = require("@fluentui/style-utilities");
var Utilities_1 = require("@fluentui/react/lib/Utilities");
var React = require("react");
var HighlightedText_styles_1 = require("./HighlightedText.styles");
var getClassNames = Utilities_1.classNamesFunction();
/** Component that allows for displaying text with portions of the text highlighted. */
var HighlightedTextBase = /** @class */ (function (_super) {
    tslib_1.__extends(HighlightedTextBase, _super);
    function HighlightedTextBase() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HighlightedTextBase.prototype, "classNames", {
        get: function () {
            var _a = this.props, styles = _a.styles, theme = _a.theme;
            return getClassNames(styles, { theme: theme });
        },
        enumerable: false,
        configurable: true
    });
    HighlightedTextBase.prototype.render = function () {
        return React.createElement(React.Fragment, null, this.mapTextToHighlights());
    };
    HighlightedTextBase.prototype.mapTextToHighlights = function () {
        var _a = this.props, text = _a.text, highlights = _a.highlights, labels = _a.labels;
        if (highlights.length === 0) {
            return React.createElement(React.Fragment, null, text);
        }
        var strings = this.toStrings(text, highlights);
        return React.createElement(React.Fragment, null, this.renderStrings(strings, labels));
    };
    HighlightedTextBase.prototype.renderStrings = function (strings, labels) {
        var highlightedClassName = style_utilities_1.mergeStyles(this.classNames.highlights, HighlightedText_styles_1.getAccessibilityHighlightStyles(labels));
        return strings.map(function (strObj) {
            if (strObj.isHighlighted) {
                return (React.createElement(React.Fragment, null,
                    React.createElement("span", { className: highlightedClassName }, strObj.str)));
            }
            else {
                return React.createElement(React.Fragment, null, strObj.str);
            }
        });
    };
    HighlightedTextBase.prototype.toStrings = function (text, highlights) {
        // start by sorting all highlights according to their effective start index, with length as tie-breaker
        var sortedHighlights = tslib_1.__spreadArrays(highlights).sort(function (a, b) {
            var aStart = Math.min(a.startIndex, a.startIndex + a.length);
            var bStart = Math.min(b.startIndex, b.startIndex + b.length);
            var indexDifference = aStart - bStart;
            if (indexDifference === 0) {
                return a.length - b.length;
            }
            return indexDifference;
        });
        // end result - will contain a series of highlighted and non-highlighted strings in sequence
        var strings = [];
        var justHighlighted;
        var currentHighlightIndex = 0;
        var currentHighlight = sortedHighlights[0];
        for (var i = 0; i < text.length; i++) {
            // handle negative indexing
            var effectiveStart = currentHighlight
                ? Math.min(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
                : undefined;
            var effectiveEnd = currentHighlight
                ? Math.max(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
                : undefined;
            // if the current highlight ends before the current character, find the next highlight that could apply
            while (currentHighlight && i >= effectiveEnd) {
                currentHighlightIndex++;
                currentHighlight = sortedHighlights[currentHighlightIndex];
                // handle negative indexing again
                effectiveStart = currentHighlight
                    ? Math.min(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
                    : undefined;
                effectiveEnd = currentHighlight
                    ? Math.max(currentHighlight.startIndex, currentHighlight.startIndex + currentHighlight.length)
                    : undefined;
            }
            var highlighted = false;
            if (currentHighlight) {
                // now that we have a highlight that could apply, check if our character is between start and start + length
                highlighted = i >= effectiveStart && i < effectiveEnd;
            }
            var currentCharacter = text[i];
            if (highlighted !== justHighlighted) {
                // add a new entry to the result if we have changed highlight parity
                strings.push({
                    str: currentCharacter,
                    isHighlighted: highlighted
                });
            }
            else {
                // otherwise, if the latest result entry is our same parity, simply append our character
                var recentStringObject = strings[strings.length - 1];
                strings[strings.length - 1] = {
                    str: recentStringObject.str + currentCharacter,
                    isHighlighted: recentStringObject.isHighlighted
                };
            }
            justHighlighted = highlighted;
        }
        return strings;
    };
    return HighlightedTextBase;
}(React.PureComponent));
exports.HighlightedTextBase = HighlightedTextBase;
//# sourceMappingURL=HighlightedText.base.js.map