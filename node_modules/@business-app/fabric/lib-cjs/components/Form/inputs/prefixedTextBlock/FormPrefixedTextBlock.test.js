"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
var React = require("react");
var ReactDom = require("react-dom");
var ReactTestUtils = require("react-dom/test-utils");
// Controls
var Enzyme = require("enzyme");
var TextField_1 = require("@fluentui/react/lib/TextField");
var Form_1 = require("../../Form");
var FormPrefixedTextBlock_1 = require("./FormPrefixedTextBlock");
var FormBaseInput_1 = require("../../FormBaseInput");
describe('FormTextInput Unit Tests', function () {
    describe('Renders for all combinations of props', function () {
        var formProps;
        var formPrefixedTextBlockProps;
        beforeEach(function () {
            formProps = {
                onSubmit: undefined
            };
            formPrefixedTextBlockProps = {
                inputKey: null,
                value: undefined
            };
        });
        it('Null name throws error', function () {
            var consoleMock = jest.spyOn(console, 'error');
            consoleMock.mockImplementation(function () { return undefined; });
            var errorFunction = function () {
                Enzyme.mount(React.createElement(Form_1.Form, tslib_1.__assign({}, formProps),
                    React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, tslib_1.__assign({}, formPrefixedTextBlockProps))));
            };
            expect(errorFunction).toThrow();
            expect(consoleMock.mock.calls[0][0]).toMatch('Uncaught [Error: FormBaseInput: name must be defined on all form inputs]');
            consoleMock.mockRestore();
        });
        it('Null props still render', function () {
            formPrefixedTextBlockProps.inputKey = 'name';
            var wrapper = Enzyme.mount(React.createElement(Form_1.Form, tslib_1.__assign({}, formProps),
                React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, tslib_1.__assign({}, formPrefixedTextBlockProps))));
            expect(wrapper.find(TextField_1.TextFieldBase).length).toBe(1);
        });
        it('With initial value', function () {
            formPrefixedTextBlockProps.inputKey = 'name';
            formPrefixedTextBlockProps.value = 'Value';
            var wrapper = Enzyme.mount(React.createElement(Form_1.Form, tslib_1.__assign({}, formProps),
                React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, tslib_1.__assign({}, formPrefixedTextBlockProps))));
            expect(wrapper.find(TextField_1.TextFieldBase).length).toBe(1);
        });
    });
    describe('Textbox update tests', function () {
        jest.useFakeTimers();
        beforeEach(function () {
            jest.useFakeTimers();
        });
        afterEach(function () {
            jest.clearAllTimers();
        });
        var ExtendsPrefixedTextBlock = /** @class */ (function (_super) {
            tslib_1.__extends(ExtendsPrefixedTextBlock, _super);
            function ExtendsPrefixedTextBlock() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ExtendsPrefixedTextBlock.prototype.setValue = function (value) {
                _super.prototype.setValue.call(this, value);
            };
            return ExtendsPrefixedTextBlock;
        }(FormPrefixedTextBlock_1.FormPrefixedTextBlock));
        // Disable unstable test.
        it.skip('PrefixedTextBlock is only trailing debounced', function (done) {
            var updateStub = jest.fn();
            var formRef = React.createRef();
            ReactTestUtils.renderIntoDocument(React.createElement(Form_1.Form, { ref: formRef, onUpdated: updateStub },
                React.createElement(ExtendsPrefixedTextBlock, { inputKey: "name", value: '' })));
            var textBlock = ReactTestUtils.findRenderedComponentWithType(formRef.current, ExtendsPrefixedTextBlock);
            textBlock.setValue('t');
            expect(updateStub).not.toHaveBeenCalled();
            textBlock.setValue('te');
            expect(updateStub).not.toHaveBeenCalled();
            jest.runAllTimers();
            expect(updateStub).toHaveBeenCalled();
            done();
        });
        it('TextInput state updates from props value change', function () {
            var updatedValue = 'updated';
            var formRef = React.createRef();
            var parent = document.createElement('div');
            ReactDom.render(React.createElement(Form_1.Form, { ref: formRef },
                React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, { inputKey: "name", key: "key", value: 'old value' })), parent);
            var textBlockElement = ReactTestUtils.findRenderedComponentWithType(formRef.current, FormPrefixedTextBlock_1.FormPrefixedTextBlock);
            var propsUpdateSpy = jest.spyOn(FormBaseInput_1.FormBaseInput, 'getDerivedStateFromProps');
            ReactDom.render(React.createElement(Form_1.Form, null,
                React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, { inputKey: "name", key: "key", value: updatedValue })), parent);
            expect(textBlockElement.state.currentValue).toEqual(updatedValue);
            expect(propsUpdateSpy).toHaveBeenCalledTimes(1);
        });
        it("TextInput state doesn't update with no new props value", function () {
            var oldValue = 'old value';
            var formRef = React.createRef();
            var parent = document.createElement('div');
            ReactDom.render(React.createElement(Form_1.Form, { ref: formRef },
                React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, { inputKey: "name", key: "key", value: oldValue })), parent);
            var textBlockElement = ReactTestUtils.findRenderedComponentWithType(formRef.current, FormPrefixedTextBlock_1.FormPrefixedTextBlock);
            var setStateSpy = jest.spyOn(textBlockElement, 'setState');
            ReactDom.render(React.createElement(Form_1.Form, null,
                React.createElement(FormPrefixedTextBlock_1.FormPrefixedTextBlock, { inputKey: "name", key: "key", value: oldValue })), parent);
            expect(setStateSpy).toHaveBeenCalledTimes(0);
        });
    });
});
//# sourceMappingURL=FormPrefixedTextBlock.test.js.map