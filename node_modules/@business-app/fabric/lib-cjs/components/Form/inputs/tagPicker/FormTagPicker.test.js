"use strict";
/*!
 * Copyright (C) Microsoft Corporation. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
var React = require("react");
var ReactTestUtils = require("react-dom/test-utils");
var Enzyme = require("enzyme");
var Form_1 = require("../../Form");
var FormTagPicker_1 = require("./FormTagPicker");
describe('FormTagPicker Unit Tests', function () {
    describe('Renders for all combinations of props', function () {
        var wrapper;
        it('Null name throws error', function () {
            var consoleMock = jest.spyOn(console, 'error');
            consoleMock.mockImplementation(function () { return undefined; });
            var errorFunction = function () {
                ReactTestUtils.renderIntoDocument(React.createElement(Form_1.Form, { onSubmit: undefined },
                    React.createElement(FormTagPicker_1.FormTagPicker, { inputKey: null, value: undefined, tagPickerProps: { onResolveSuggestions: function () { return []; } } })));
            };
            expect(errorFunction).toThrow();
            expect(consoleMock).toHaveBeenCalledTimes(2);
            expect(consoleMock.mock.calls[0][0]).toMatch('Uncaught [Error: FormBaseInput: name must be defined on all form inputs]');
            consoleMock.mockRestore();
        });
        it('Null props still render', function () {
            wrapper = Enzyme.mount(React.createElement(Form_1.Form, { onSubmit: undefined },
                React.createElement(FormTagPicker_1.FormTagPicker, { inputKey: "tag", value: undefined, tagPickerProps: { onResolveSuggestions: function () { return []; } } })));
            expect(wrapper.find('.ms-BasePicker')).toBeTruthy();
        });
        it('With initial value', function () {
            var result;
            var option1 = { key: '1', name: 'Tag 1' };
            var option2 = { key: '2', name: 'Tag 2' };
            wrapper = Enzyme.mount(React.createElement(Form_1.Form, { onSubmit: function (value) {
                    result = value;
                } },
                React.createElement(FormTagPicker_1.FormTagPicker, { inputKey: "tag", tagPickerProps: { onResolveSuggestions: function () { return [option1, option2]; } }, value: [option2] })));
            expect(wrapper.find('.ms-BasePicker')).toBeTruthy();
            var form = wrapper.find('form');
            form.simulate('submit');
            expect(result.tag).toEqual([option2]);
        });
    });
    describe('TagPicker update tests', function () {
        jest.useFakeTimers();
        beforeEach(function () {
            jest.useFakeTimers();
        });
        afterEach(function () {
            jest.clearAllTimers();
        });
        var ExtendsTagPicker = /** @class */ (function (_super) {
            tslib_1.__extends(ExtendsTagPicker, _super);
            function ExtendsTagPicker() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ExtendsTagPicker.prototype.setValue = function (value) {
                _super.prototype.setValue.call(this, value);
            };
            return ExtendsTagPicker;
        }(FormTagPicker_1.FormTagPicker));
        // Disabled because of intermittent issues with timer logic.
        it.skip('TagPicker is leading and trailing debounced', function (done) {
            var option1 = { key: '1', name: 'Tag 1' };
            var option2 = { key: '2', name: 'Tag 2' };
            var updateStub = jest.fn();
            var formRef = React.createRef();
            ReactTestUtils.renderIntoDocument(React.createElement(Form_1.Form, { ref: formRef, onUpdated: updateStub },
                React.createElement(ExtendsTagPicker, { inputKey: "tag", value: [option1], tagPickerProps: { onResolveSuggestions: function () { return [option1, option2]; } } })));
            var datePicker = ReactTestUtils.findRenderedComponentWithType(formRef.current, ExtendsTagPicker);
            datePicker.setValue([option2]);
            expect(updateStub).toHaveBeenCalledTimes(1);
            datePicker.setValue([option1, option2]);
            expect(updateStub).toHaveBeenCalledTimes(1);
            jest.runAllTimers();
            expect(updateStub).toHaveBeenCalledTimes(2);
            done();
        });
    });
});
//# sourceMappingURL=FormTagPicker.test.js.map